import{g as _p}from"./index-BAVoGhp1.js";function Ip(e,t){for(var n=0;n<t.length;n++){const s=t[n];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in e)){const a=Object.getOwnPropertyDescriptor(s,r);a&&Object.defineProperty(e,r,a.get?a:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}const Ap=1e-7,xp=1e-4;class Op{constructor(t,n){this.backend=t,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,n){this.dataIdsCount++,this.data.set(t,n)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class Qa{refCount(t){return bt("refCount")}incRef(t){return bt("incRef")}timerAvailable(){return!0}time(t){return bt("time")}read(t){return bt("read")}readSync(t){return bt("readSync")}readToGPU(t,n){return bt("readToGPU")}numDataIds(){return bt("numDataIds")}disposeData(t,n){return bt("disposeData")}write(t,n,s){return bt("write")}move(t,n,s,r,a){return bt("move")}createTensorFromGPUData(t,n,s){return bt("createTensorFromGPUData")}memory(){return bt("memory")}floatPrecision(){return bt("floatPrecision")}epsilon(){return this.floatPrecision()===32?Ap:xp}dispose(){return bt("dispose")}}function bt(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function to(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Fn(e,t,n)}function Dp(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,s=0;for(;n>0;)s=Math.random()*n|0,n--,Fn(e,n,s),Fn(t,n,s)}function Qe(e,t,n){return Math.max(e,Math.min(t,n))}function Cp(e){return e%2===0?e:e+1}function Fn(e,t,n){const s=e[t];e[t]=e[n],e[n]=s}function Rp(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function Fp(e,t){const n=Math.random();return t*n+(1-n)*e}function Lp(e,t){let n=0;for(let s=0;s<e.length;s++){const r=Number(e[s])-Number(t[s]);n+=r*r}return n}function g(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function gt(e,t,n=""){g(Rt(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function Ie(e){g(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function q(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function Bp(e){return e.length===0}function eo(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==null&&t[n]!==null&&e[n]!==t[n])return!1;return!0}function Rt(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Fe(e){return e%1===0}function Pp(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function zp(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Vp(e){const t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return to(t),t}function Je(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Wp(e,t=r=>0,n,s){return new Promise((r,a)=>{let o=0;const i=()=>{if(e()){r();return}o++;const u=t(o);if(n!=null&&o>=n){a();return}s!=null?s(i,u):setTimeout(i,u)};i()})}function Mp(e,t){let n=1,s=-1;for(let a=0;a<e.length;++a)if(e[a]>=0)n*=e[a];else if(e[a]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${a}`);s=a}else if(e[a]<0)throw Error(`Shapes can not be < 0. Found ${e[a]} at dim ${a}`);if(s===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const r=e.slice();return r[s]=t/n,r}function dn(e,t){const n=t.length;return e=e==null?t.map((s,r)=>r):[].concat(e),g(e.every(s=>s>=-n&&s<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),g(e.every(s=>Fe(s)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(s=>s<0?n+s:s)}function no(e,t){const n=[],s=[],r=t!=null&&Array.isArray(t)&&t.length===0,a=t==null||r?null:dn(t,e).sort();let o=0;for(let i=0;i<e.length;++i){if(a!=null){if(a[o]===i&&e[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${e[i]}' is not 1`);(a[o]==null||a[o]>i)&&e[i]===1&&(n.push(e[i]),s.push(i)),a[o]<=i&&o++}e[i]!==1&&(n.push(e[i]),s.push(i))}return{newShape:n,keptDims:s}}function so(e,t){return Ys(e,t)}function Ys(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function ro(e,t){for(let n=0;n<e.length;n++){const s=e[n];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)}}function ao(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function Up(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function Ln(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function oo(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function Qt(e){return typeof e=="string"||e instanceof String}function io(e){return typeof e=="boolean"}function uo(e){return typeof e=="number"}function mn(e){return Array.isArray(e)?mn(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":uo(e)?"float32":Qt(e)?"string":io(e)?"bool":"float32"}function se(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Bn(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function Ue(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let s=t-3;s>=0;--s)n[s]=n[s+1]*e[s+1];return n}function co(e,t,n,s=!1){const r=new Array;if(t.length===1){const a=t[0]*(s?2:1);for(let o=0;o<a;o++)r[o]=n[e+o]}else{const a=t[0],o=t.slice(1),i=o.reduce((u,c)=>u*c)*(s?2:1);for(let u=0;u<a;u++)r[u]=co(e+u*i,o,n,s)}return r}function be(e,t,n=!1){if(e.length===0)return t[0];const s=e.reduce((r,a)=>r*a)*(n?2:1);if(s===0)return[];if(s!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return co(0,e,t,n)}function jp(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function Qs(e,t){const n=Xn(e,t);for(let s=0;s<n.length;s++)n[s]=1;return n}function Xn(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function qp(e,t){const n=e.reduce((s,r)=>s*r,1);if(t==null||t==="float32")return be(e,new Float32Array(n));if(t==="int32")return be(e,new Int32Array(n));if(t==="bool")return be(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Et(e){e.forEach(t=>{g(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function Gp(e,t,n){if(t===0)return 0;if(t===1)return e[0];let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=n[r]*e[r];return s}function Hp(e,t,n){if(t===0)return[];if(t===1)return[e];const s=new Array(t);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(e/n[r]),e-=s[r]*n[r];return s[s.length-1]=e,s}function re(e){return e&&e.then&&typeof e.then=="function"}const ha="tfjsflags";class lo{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Kp,this.populateURLFlags()}setPlatform(t,n){this.platform!=null&&(P().getBool("IS_TEST")||P().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=n}registerFlag(t,n,s){if(this.flagRegistry[t]={evaluationFn:n,setHook:s},this.urlFlags[t]!=null){const r=this.urlFlags[t];P().getBool("IS_TEST")||P().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${r}.`),this.set(t,r)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const n=this.evaluateFlag(t);if(re(n))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=n,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,n){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=n,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(n)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);ha in t&&t[ha].split(",").forEach(s=>{const[r,a]=s.split(":");this.urlFlags[r]=Zp(r,a)})}}function Kp(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...s)=>(Xp(t,s[0],s[1]),s.join("="))),t}function Xp(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function Zp(e,t){const n=t.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:t}function P(){return tr}let tr=null;function Jp(e){tr=e}let fs;function ho(){if(fs==null){let e;if(typeof window<"u")e=window;else if(typeof globalThis<"u")e=globalThis;else if(typeof process<"u")e=process;else if(typeof self<"u")e=self;else throw new Error("Could not find a global object");fs=e}return fs}function Yp(){const e=ho();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function er(e,t){const n=Yp();if(n.has(e))return n.get(e);{const s=t();return n.set(e,s),n.get(e)}}const po="Abs",fo="Acos",mo="Acosh",nr="Add",go="AddN",yo="All",bo="Any",wo="ArgMax",No="ArgMin",So="Asin",To="Asinh",Eo="Atan",$o="Atanh",vo="Atan2",ko="AvgPool",Qp="AvgPoolGrad",_o="AvgPool3D",tf="AvgPool3DGrad",Io="BatchMatMul",Ao="BatchToSpaceND",xo="Bincount",Oo="BitwiseAnd",ef="BroadcastTo",Do="BroadcastArgs",sr="Cast",Co="Ceil",Ro="ClipByValue",Fo="Complex",Lo="ComplexAbs",Bo="Concat",Po="Conv2D",zo="Conv2DBackpropFilter",Vo="Conv2DBackpropInput",Wo="Conv3D",nf="Conv3DBackpropFilterV2",Mo="Conv3DBackpropInputV2",Uo="Cos",jo="Cosh",qo="Cumprod",Go="Cumsum",Ho="CropAndResize",Ko="DenseBincount",Xo="DepthToSpace",Zo="DepthwiseConv2dNative",Jo="DepthwiseConv2dNativeBackpropFilter",Yo="DepthwiseConv2dNativeBackpropInput",Qo="Diag",ti="Dilation2D",sf="Dilation2DBackpropInput",rf="Dilation2DBackpropFilter",rr="Draw",ei="RealDiv",ni="Einsum",si="Elu",af="EluGrad",ri="Erf",ai="Equal",oi="Exp",ii="ExpandDims",ui="Expm1",ci="FFT",li="Fill",hi="FlipLeftRight",pi="Floor",fi="FloorDiv",di="FusedBatchNorm",mi="GatherV2",gi="GatherNd",yi="Greater",bi="GreaterEqual",ar="Identity",wi="IFFT",Ni="Imag",Si="IsFinite",Ti="IsInf",Ei="IsNan",$i="LeakyRelu",vi="Less",ki="LessEqual",_i="LinSpace",Ii="Log",Ai="Log1p",xi="LogicalAnd",Oi="LogicalNot",Di="LogicalOr",of="LogicalXor",uf="LogSoftmax",cf="LowerBound",Ci="LRN",lf="LRNGrad",hf="MatrixBandPart",Ri="Max",Fi="Maximum",Li="MaxPool",pf="MaxPoolGrad",Bi="MaxPool3D",ff="MaxPool3DGrad",Pi="MaxPoolWithArgmax",zi="Mean",Vi="Min",Wi="Minimum",Mi="MirrorPad",Ui="Mod",ji="Multinomial",qi="Multiply",Gi="Neg",Hi="NotEqual",Ki="NonMaxSuppressionV3",Xi="NonMaxSuppressionV4",Zi="NonMaxSuppressionV5",Ji="OnesLike",Yi="OneHot",Qi="Pack",tu="PadV2",df="Pool",eu="Pow",nu="Prelu",su="Prod",ru="RaggedGather",au="RaggedRange",ou="RaggedTensorToTensor",iu="Range",uu="Real",cu="Reciprocal",lu="Relu",hu="Reshape",pu="ResizeNearestNeighbor",mf="ResizeNearestNeighborGrad",fu="ResizeBilinear",gf="ResizeBilinearGrad",du="Relu6",mu="Reverse",gu="Round",yu="Rsqrt",bu="ScatterNd",wu="TensorScatterUpdate",Nu="SearchSorted",Su="Select",Tu="Selu",Eu="Slice",$u="Sin",vu="Sinh",ku="Sign",_u="Sigmoid",Iu="Softplus",Au="Sqrt",xu="Sum",Ou="SpaceToBatchND",Du="SplitV",Cu="Softmax",Ru="SparseFillEmptyRows",Fu="SparseReshape",Lu="SparseSegmentMean",Bu="SparseSegmentSum",Pu="SparseToDense",zu="SquaredDifference",yf="Square",Vu="StaticRegexReplace",Wu="StridedSlice",Mu="StringNGrams",Uu="StringSplit",ju="StringToHashBucketFast",qu="Sub",Gu="Tan",Hu="Tanh",or="Tile",Ku="TopK",Xu="Transform",On="Transpose",Zu="Unique",Ju="Unpack",Yu="UnsortedSegmentSum",bf="UpperBound",Qu="ZerosLike",tc="Step",Ss="FromPixels",ec="RotateWithOffset",Ts="_FusedMatMul",Es="FusedConv2D",$s="FusedDepthwiseConv2D";function Jt(...e){P().getBool("IS_TEST")||P().getBool("PROD")||console.warn(...e)}function wf(...e){P().getBool("IS_TEST")||P().getBool("PROD")||console.log(...e)}const Le=er("kernelRegistry",()=>new Map),tn=er("gradRegistry",()=>new Map);function en(e,t){const n=ir(e,t);return Le.get(n)}function vs(e){return tn.get(e)}function Pn(e){const t=Le.entries(),n=[];for(;;){const{done:s,value:r}=t.next();if(s)break;const[a,o]=r,[i]=a.split("_");i===e&&n.push(o)}return n}function nc(e){const{kernelName:t,backendName:n}=e,s=ir(t,n);Le.has(s)&&Jt(`The kernel '${t}' for backend '${n}' is already registered`),Le.set(s,e)}function Nf(e){const{kernelName:t}=e;tn.has(t)&&P().getBool("DEBUG")&&Jt(`Overriding the gradient for '${t}'`),tn.set(t,e)}function Sf(e,t){const n=ir(e,t);if(!Le.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);Le.delete(n)}function Tf(e){if(!tn.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);tn.delete(e)}function Ef(e,t){Pn(e).forEach(s=>{const r=Object.assign({},s,{backendName:t});nc(r)})}function ir(e,t){return`${t}_${e}`}function sc(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var pa={},fa;function $f(){if(fa)return pa;fa=1,(void 0).exports=t;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function t(v,y,A){this.low=v|0,this.high=y|0,this.unsigned=!!A}t.prototype.__isLong__,Object.defineProperty(t.prototype,"__isLong__",{value:!0});function n(v){return(v&&v.__isLong__)===!0}t.isLong=n;var s={},r={};function a(v,y){var A,L,V;return y?(v>>>=0,(V=0<=v&&v<256)&&(L=r[v],L)?L:(A=i(v,(v|0)<0?-1:0,!0),V&&(r[v]=A),A)):(v|=0,(V=-128<=v&&v<128)&&(L=s[v],L)?L:(A=i(v,v<0?-1:0,!1),V&&(s[v]=A),A))}t.fromInt=a;function o(v,y){if(isNaN(v))return y?O:E;if(y){if(v<0)return O;if(v>=S)return F}else{if(v<=-T)return R;if(v+1>=T)return x}return v<0?o(-v,y).neg():i(v%m|0,v/m|0,y)}t.fromNumber=o;function i(v,y,A){return new t(v,y,A)}t.fromBits=i;var u=Math.pow;function c(v,y,A){if(v.length===0)throw Error("empty string");if(v==="NaN"||v==="Infinity"||v==="+Infinity"||v==="-Infinity")return E;if(typeof y=="number"?(A=y,y=!1):y=!!y,A=A||10,A<2||36<A)throw RangeError("radix");var L;if((L=v.indexOf("-"))>0)throw Error("interior hyphen");if(L===0)return c(v.substring(1),y,A).neg();for(var V=o(u(A,8)),z=E,J=0;J<v.length;J+=8){var Y=Math.min(8,v.length-J),at=parseInt(v.substring(J,J+Y),A);if(Y<8){var et=o(u(A,Y));z=z.mul(et).add(o(at))}else z=z.mul(V),z=z.add(o(at))}return z.unsigned=y,z}t.fromString=c;function l(v,y){return typeof v=="number"?o(v,y):typeof v=="string"?c(v,y):i(v.low,v.high,typeof y=="boolean"?y:v.unsigned)}t.fromValue=l;var h=65536,f=1<<24,m=h*h,S=m*m,T=S/2,N=a(f),E=a(0);t.ZERO=E;var O=a(0,!0);t.UZERO=O;var $=a(1);t.ONE=$;var I=a(1,!0);t.UONE=I;var D=a(-1);t.NEG_ONE=D;var x=i(-1,2147483647,!1);t.MAX_VALUE=x;var F=i(-1,-1,!0);t.MAX_UNSIGNED_VALUE=F;var R=i(0,-2147483648,!1);t.MIN_VALUE=R;var k=t.prototype;return k.toInt=function(){return this.unsigned?this.low>>>0:this.low},k.toNumber=function(){return this.unsigned?(this.high>>>0)*m+(this.low>>>0):this.high*m+(this.low>>>0)},k.toString=function(y){if(y=y||10,y<2||36<y)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(R)){var A=o(y),L=this.div(A),V=L.mul(A).sub(this);return L.toString(y)+V.toInt().toString(y)}else return"-"+this.neg().toString(y);for(var z=o(u(y,6),this.unsigned),J=this,Y="";;){var at=J.div(z),et=J.sub(at.mul(z)).toInt()>>>0,st=et.toString(y);if(J=at,J.isZero())return st+Y;for(;st.length<6;)st="0"+st;Y=""+st+Y}},k.getHighBits=function(){return this.high},k.getHighBitsUnsigned=function(){return this.high>>>0},k.getLowBits=function(){return this.low},k.getLowBitsUnsigned=function(){return this.low>>>0},k.getNumBitsAbs=function(){if(this.isNegative())return this.eq(R)?64:this.neg().getNumBitsAbs();for(var y=this.high!=0?this.high:this.low,A=31;A>0&&(y&1<<A)==0;A--);return this.high!=0?A+33:A+1},k.isZero=function(){return this.high===0&&this.low===0},k.eqz=k.isZero,k.isNegative=function(){return!this.unsigned&&this.high<0},k.isPositive=function(){return this.unsigned||this.high>=0},k.isOdd=function(){return(this.low&1)===1},k.isEven=function(){return(this.low&1)===0},k.equals=function(y){return n(y)||(y=l(y)),this.unsigned!==y.unsigned&&this.high>>>31===1&&y.high>>>31===1?!1:this.high===y.high&&this.low===y.low},k.eq=k.equals,k.notEquals=function(y){return!this.eq(y)},k.neq=k.notEquals,k.ne=k.notEquals,k.lessThan=function(y){return this.comp(y)<0},k.lt=k.lessThan,k.lessThanOrEqual=function(y){return this.comp(y)<=0},k.lte=k.lessThanOrEqual,k.le=k.lessThanOrEqual,k.greaterThan=function(y){return this.comp(y)>0},k.gt=k.greaterThan,k.greaterThanOrEqual=function(y){return this.comp(y)>=0},k.gte=k.greaterThanOrEqual,k.ge=k.greaterThanOrEqual,k.compare=function(y){if(n(y)||(y=l(y)),this.eq(y))return 0;var A=this.isNegative(),L=y.isNegative();return A&&!L?-1:!A&&L?1:this.unsigned?y.high>>>0>this.high>>>0||y.high===this.high&&y.low>>>0>this.low>>>0?-1:1:this.sub(y).isNegative()?-1:1},k.comp=k.compare,k.negate=function(){return!this.unsigned&&this.eq(R)?R:this.not().add($)},k.neg=k.negate,k.add=function(y){n(y)||(y=l(y));var A=this.high>>>16,L=this.high&65535,V=this.low>>>16,z=this.low&65535,J=y.high>>>16,Y=y.high&65535,at=y.low>>>16,et=y.low&65535,st=0,kt=0,ut=0,$t=0;return $t+=z+et,ut+=$t>>>16,$t&=65535,ut+=V+at,kt+=ut>>>16,ut&=65535,kt+=L+Y,st+=kt>>>16,kt&=65535,st+=A+J,st&=65535,i(ut<<16|$t,st<<16|kt,this.unsigned)},k.subtract=function(y){return n(y)||(y=l(y)),this.add(y.neg())},k.sub=k.subtract,k.multiply=function(y){if(this.isZero())return E;if(n(y)||(y=l(y)),e){var A=e.mul(this.low,this.high,y.low,y.high);return i(A,e.get_high(),this.unsigned)}if(y.isZero())return E;if(this.eq(R))return y.isOdd()?R:E;if(y.eq(R))return this.isOdd()?R:E;if(this.isNegative())return y.isNegative()?this.neg().mul(y.neg()):this.neg().mul(y).neg();if(y.isNegative())return this.mul(y.neg()).neg();if(this.lt(N)&&y.lt(N))return o(this.toNumber()*y.toNumber(),this.unsigned);var L=this.high>>>16,V=this.high&65535,z=this.low>>>16,J=this.low&65535,Y=y.high>>>16,at=y.high&65535,et=y.low>>>16,st=y.low&65535,kt=0,ut=0,$t=0,_n=0;return _n+=J*st,$t+=_n>>>16,_n&=65535,$t+=z*st,ut+=$t>>>16,$t&=65535,$t+=J*et,ut+=$t>>>16,$t&=65535,ut+=V*st,kt+=ut>>>16,ut&=65535,ut+=z*et,kt+=ut>>>16,ut&=65535,ut+=J*at,kt+=ut>>>16,ut&=65535,kt+=L*st+V*et+z*at+J*Y,kt&=65535,i($t<<16|_n,kt<<16|ut,this.unsigned)},k.mul=k.multiply,k.divide=function(y){if(n(y)||(y=l(y)),y.isZero())throw Error("division by zero");if(e){if(!this.unsigned&&this.high===-2147483648&&y.low===-1&&y.high===-1)return this;var A=(this.unsigned?e.div_u:e.div_s)(this.low,this.high,y.low,y.high);return i(A,e.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?O:E;var L,V,z;if(this.unsigned){if(y.unsigned||(y=y.toUnsigned()),y.gt(this))return O;if(y.gt(this.shru(1)))return I;z=O}else{if(this.eq(R)){if(y.eq($)||y.eq(D))return R;if(y.eq(R))return $;var J=this.shr(1);return L=J.div(y).shl(1),L.eq(E)?y.isNegative()?$:D:(V=this.sub(y.mul(L)),z=L.add(V.div(y)),z)}else if(y.eq(R))return this.unsigned?O:E;if(this.isNegative())return y.isNegative()?this.neg().div(y.neg()):this.neg().div(y).neg();if(y.isNegative())return this.div(y.neg()).neg();z=E}for(V=this;V.gte(y);){L=Math.max(1,Math.floor(V.toNumber()/y.toNumber()));for(var Y=Math.ceil(Math.log(L)/Math.LN2),at=Y<=48?1:u(2,Y-48),et=o(L),st=et.mul(y);st.isNegative()||st.gt(V);)L-=at,et=o(L,this.unsigned),st=et.mul(y);et.isZero()&&(et=$),z=z.add(et),V=V.sub(st)}return z},k.div=k.divide,k.modulo=function(y){if(n(y)||(y=l(y)),e){var A=(this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,y.low,y.high);return i(A,e.get_high(),this.unsigned)}return this.sub(this.div(y).mul(y))},k.mod=k.modulo,k.rem=k.modulo,k.not=function(){return i(~this.low,~this.high,this.unsigned)},k.and=function(y){return n(y)||(y=l(y)),i(this.low&y.low,this.high&y.high,this.unsigned)},k.or=function(y){return n(y)||(y=l(y)),i(this.low|y.low,this.high|y.high,this.unsigned)},k.xor=function(y){return n(y)||(y=l(y)),i(this.low^y.low,this.high^y.high,this.unsigned)},k.shiftLeft=function(y){return n(y)&&(y=y.toInt()),(y&=63)===0?this:y<32?i(this.low<<y,this.high<<y|this.low>>>32-y,this.unsigned):i(0,this.low<<y-32,this.unsigned)},k.shl=k.shiftLeft,k.shiftRight=function(y){return n(y)&&(y=y.toInt()),(y&=63)===0?this:y<32?i(this.low>>>y|this.high<<32-y,this.high>>y,this.unsigned):i(this.high>>y-32,this.high>=0?0:-1,this.unsigned)},k.shr=k.shiftRight,k.shiftRightUnsigned=function(y){if(n(y)&&(y=y.toInt()),y&=63,y===0)return this;var A=this.high;if(y<32){var L=this.low;return i(L>>>y|A<<32-y,A>>>y,this.unsigned)}else return y===32?i(A,0,this.unsigned):i(A>>>y-32,0,this.unsigned)},k.shru=k.shiftRightUnsigned,k.shr_u=k.shiftRightUnsigned,k.toSigned=function(){return this.unsigned?i(this.low,this.high,!1):this},k.toUnsigned=function(){return this.unsigned?this:i(this.low,this.high,!0)},k.toBytes=function(y){return y?this.toBytesLE():this.toBytesBE()},k.toBytesLE=function(){var y=this.high,A=this.low;return[A&255,A>>>8&255,A>>>16&255,A>>>24,y&255,y>>>8&255,y>>>16&255,y>>>24]},k.toBytesBE=function(){var y=this.high,A=this.low;return[y>>>24,y>>>16&255,y>>>8&255,y&255,A>>>24,A>>>16&255,A>>>8&255,A&255]},t.fromBytes=function(y,A,L){return L?t.fromBytesLE(y,A):t.fromBytesBE(y,A)},t.fromBytesLE=function(y,A){return new t(y[0]|y[1]<<8|y[2]<<16|y[3]<<24,y[4]|y[5]<<8|y[6]<<16|y[7]<<24,A)},t.fromBytesBE=function(y,A){return new t(y[4]<<24|y[5]<<16|y[6]<<8|y[7],y[0]<<24|y[1]<<16|y[2]<<8|y[3],A)},pa}var rc=$f();const ac=_p(rc),vf=Ip({__proto__:null,default:ac},[rc]);const de=ac||vf;function gn(e){return de.fromString(e,!0,16)}const oc=gn("c3a5c85c97cb3127"),fe=gn("b492b66fbe98f273"),ft=gn("9ae16a3b2f90404f");function ks(e){return e.xor(e.shru(47))}function ic(e,t,n){const s=e.slice(t,t+n);return de.fromBytes(Array.from(s),!0,!0)}function H(e,t){return ic(e,t,8)}function da(e,t){return ic(e,t,4)}function ot(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function ne(e,t,n=gn("9ddfea08eb382d69")){let s=e.xor(t).mul(n);s=s.xor(s.shru(47));let r=t.xor(s).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function kf(e,t,n,s,r,a){r=r.add(e),a=ot(a.add(r).add(s),21);const o=r;return r=r.add(t),r=r.add(n),a=a.add(ot(r,44)),[r.add(s),a.add(o)]}function In(e,t,n,s){return kf(H(e,t),H(e,t+8),H(e,t+16),H(e,t+24),n,s)}function _f(e,t=e.length){if(t>=8){const n=ft.add(t*2),s=H(e,0).add(ft),r=H(e,t-8),a=ot(r,37).mul(n).add(s),o=ot(s,25).add(r).mul(n);return ne(a,o,n)}if(t>=4){const n=ft.add(t*2),s=da(e,0);return ne(s.shl(3).add(t),da(e,t-4),n)}if(t>0){const n=e[0],s=e[t>>1],r=e[t-1],a=n+(s<<8),o=t+(r<<2);return ks(ft.mul(a).xor(oc.mul(o))).mul(ft)}return ft}function If(e,t=e.length){const n=ft.add(t*2),s=H(e,0).mul(fe),r=H(e,8),a=H(e,t-8).mul(n),o=H(e,t-16).mul(ft);return ne(ot(s.add(r),43).add(ot(a,30)).add(o),s.add(ot(r.add(ft),18)).add(a),n)}function Af(e,t=e.length){const n=ft.add(t*2),s=H(e,0).mul(ft),r=H(e,8),a=H(e,t-8).mul(n),o=H(e,t-16).mul(ft),i=ot(s.add(r),43).add(ot(a,30)).add(o),u=ne(i,s.add(ot(r.add(ft),18)).add(a),n),c=H(e,16).mul(n),l=H(e,24),h=i.add(H(e,t-32)).mul(n),f=u.add(H(e,t-24)).mul(n);return ne(ot(c.add(l),43).add(ot(h,30)).add(f),c.add(ot(l.add(s),18)).add(h),n)}function xf(e,t=e.length){const n=de.fromNumber(81,!0);if(t<=32)return t<=16?_f(e,t):If(e,t);if(t<=64)return Af(e,t);let s=n,r=n.mul(fe).add(113),a=ks(r.mul(ft).add(113)).mul(ft),o=[de.UZERO,de.UZERO],i=[de.UZERO,de.UZERO];s=s.mul(ft).add(H(e,0));let u=0;const c=(t-1>>6)*64,l=c+(t-1&63)-63;do s=ot(s.add(r).add(o[0]).add(H(e,u+8)),37).mul(fe),r=ot(r.add(o[1]).add(H(e,u+48)),42).mul(fe),s=s.xor(i[1]),r=r.add(o[0]).add(H(e,u+40)),a=ot(a.add(i[0]),33).mul(fe),o=In(e,u,o[1].mul(fe),s.add(i[0])),i=In(e,u+32,a.add(i[1]),r.add(H(e,u+16))),[a,s]=[s,a],u+=64;while(u!==c);const h=fe.add(a.and(255).shl(1));return u=l,i[0]=i[0].add(t-1&63),o[0]=o[0].add(i[0]),i[0]=i[0].add(o[0]),s=ot(s.add(r).add(o[0]).add(H(e,u+8)),37).mul(h),r=ot(r.add(o[1]).add(H(e,u+48)),42).mul(h),s=s.xor(i[1].mul(9)),r=r.add(o[0].mul(9).add(H(e,u+40))),a=ot(a.add(i[0]),33).mul(h),o=In(e,u,o[1].mul(h),s.add(i[0])),i=In(e,u+32,a.add(i[1]),r.add(H(e,u+16))),[a,s]=[s,a],ne(ne(o[0],i[0],h).add(ks(r).mul(oc)).add(a),ne(o[1],i[1],h).add(s),h)}function Of(e,t){return t==="string"?yn(e):Zn([e],t)}function Df(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function Zn(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=ae(e)),P().getBool("DEBUG")&&ro(e,t),Df(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){const n=new Uint8Array(e.length);for(let s=0;s<n.length;++s)Math.round(e[s])!==0&&(n[s]=1);return n}else throw new Error(`Unknown data type ${t}`)}function nn(){return P().platform.now()}function Cf(e,t){return P().platform.fetch(e,t)}function yn(e,t="utf-8"){return t=t||"utf-8",P().platform.encode(e,t)}function zn(e,t="utf-8"){return t=t||"utf-8",P().platform.decode(e,t)}function it(e){return P().platform.isTypedArray!=null?P().platform.isTypedArray(e):sc(e)}function ae(e,t=[],n=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||re(e)||e==null||it(e)&&n)t.push(e);else if(Array.isArray(e)||it(e))for(let s=0;s<e.length;++s)ae(e[s],t,n);else{let s=-1;for(const r of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)ae(e[r],t,n)}return t}const Rf=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:Rt,arraysEqualWithNull:eo,assert:g,assertNonNegativeIntegerDimensions:Et,assertNonNull:Ie,assertShapesMatch:gt,bytesFromStringArray:oo,bytesPerElement:Ln,checkConversionForErrors:ro,clamp:Qe,computeStrides:Ue,convertBackendValuesAndArrayBuffer:jp,createScalarValue:Of,createShuffledIndices:Vp,decodeString:zn,distSquared:Lp,encodeString:yn,fetch:Cf,fingerPrint64:xf,flatten:ae,getArrayFromDType:Ys,getTypedArrayFromDType:so,hasEncodingLoss:Up,hexToLong:gn,indexToLoc:Hp,inferDtype:mn,inferFromImplicitShape:Mp,isBoolean:io,isFunction:se,isInt:Fe,isNumber:uo,isPromise:re,isScalarShape:Bp,isString:Qt,isTypedArray:it,isValidDtype:ao,locToIndex:Gp,makeOnesTypedArray:Qs,makeZerosNestedTypedArray:qp,makeZerosTypedArray:Xn,nearestDivisor:Bn,nearestLargerEven:Cp,now:nn,parseAxisParam:dn,randUniform:Fp,repeatedTry:Wp,rightPad:Je,shuffle:to,shuffleCombo:Dp,sizeFromShape:q,sizeToSquarishShape:zp,squeezeShape:no,sum:Rp,swap:Fn,tanh:Pp,toNestedArray:be,toTypedArray:Zn},Symbol.toStringTag,{value:"Module"}));class Ff{constructor(t,n){this.backendTimer=t,this.logger=n,n==null&&(this.logger=new Bf)}profileKernel(t,n,s){let r;const a=()=>{r=s()};let o;const i=nn();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(a);else{a();for(const c of r)c.dataSync();o=Promise.resolve({kernelMs:nn()-i})}if(P().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<r.length;c++){const l=r[c];l.data().then(h=>{Lf(h,l.dtype,t)})}return{kernelName:t,outputs:r,inputs:n,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:n,outputs:s,timeMs:r,inputs:a,extraInfo:o}=t;s.forEach(i=>{Promise.all([i.data(),r,o]).then(u=>{this.logger.logKernelProfile(n,i,u[0],u[1],a,u[2])})})}}function Lf(e,t,n){if(t!=="float32")return!1;for(let s=0;s<e.length;s++){const r=e[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class Bf{logKernelProfile(t,n,s,r,a,o){const i=typeof r=="number"?Je(`${r}ms`,9):r.error,u=Je(t,25),c=n.rank,l=n.size,h=Je(n.shape.toString(),14);let f="";for(const m in a){const S=a[m];if(S!=null){const T=S.shape||n.shape,N=T.length;f+=`${m}: ${N}D ${N>0?T:""} `}}console.log(`%c${u}	%c${i}	%c${c}D ${h}	%c${l}	%c${f}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Pf(e,t,n){const s={},r={};for(let u=0;u<t.length;u++)s[t[u].id]=!0;for(let u=0;u<e.length;u++){const c=e[u],l=c.inputs;for(const h in l){const f=l[h];let m=!1;for(let S=0;S<t.length;S++)if(s[f.id]){c.outputs.forEach(T=>s[T.id]=!0),m=!0,r[c.id]=!0;break}if(m)break}}const a={};a[n.id]=!0;const o={};for(let u=e.length-1;u>=0;u--){const c=e[u],l=c.inputs;for(let h=0;h<c.outputs.length;h++)if(a[c.outputs[h].id]){for(const f in l)a[l[f].id]=!0,o[c.id]=!0;break}}const i=[];for(let u=0;u<e.length;u++){const c=e[u];if(r[c.id]&&o[c.id]){const l={};for(const f in c.inputs){const m=c.inputs[f];s[m.id]&&(l[f]=m)}const h=Object.assign({},c);h.inputs=l,h.outputs=c.outputs,i.push(h)}}return i}function zf(e,t,n,s){for(let r=t.length-1;r>=0;r--){const a=t[r],o=[];if(a.outputs.forEach(u=>{const c=e[u.id];c!=null?o.push(c):o.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const i=a.gradient(o);for(const u in a.inputs){if(!(u in i))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(i)}.`);const c=n(()=>i[u]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${c.dtype}'`);const l=a.inputs[u];if(!Rt(c.shape,l.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${u}' has shape '${c.shape}', which does not match the shape of the input '${l.shape}'`);if(e[l.id]==null)e[l.id]=c;else{const h=e[l.id];e[l.id]=s(h,c),h.dispose()}}}}const ma=20,He=3,ds=7;function Vf(e,t,n,s){const r=Ue(t),a=Wf(e,t,n,r),o=t.length,i=Dn(e,t,n,r,a),u=["Tensor"];return s&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${o}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(i.map(c=>"    "+c).join(`
`)),u.join(`
`)}function Wf(e,t,n,s){const r=q(t),a=s[s.length-1],o=new Array(a).fill(0),i=t.length,u=n==="complex64"?Ze(e):e;if(i>1)for(let c=0;c<r/a;c++){const l=c*a;for(let h=0;h<a;h++)o[h]=Math.max(o[h],Xe(u[l+h],0,n).length)}return o}function Xe(e,t,n){let s;return Array.isArray(e)?s=`${parseFloat(e[0].toFixed(ds))} + ${parseFloat(e[1].toFixed(ds))}j`:Qt(e)?s=`'${e}'`:n==="bool"?s=uc(e):s=parseFloat(e.toFixed(ds)).toString(),Je(s,t)}function uc(e){return e===0?"false":"true"}function Dn(e,t,n,s,r,a=!0){const o=n==="complex64"?2:1,i=t[0],u=t.length;if(u===0){if(n==="complex64"){const T=Ze(e);return[Xe(T[0],0,n)]}return n==="bool"?[uc(e[0])]:[e[0].toString()]}if(u===1){if(i>ma){const N=He*o;let E=Array.from(e.slice(0,N)),O=Array.from(e.slice((i-He)*o,i*o));return n==="complex64"&&(E=Ze(E),O=Ze(O)),["["+E.map(($,I)=>Xe($,r[I],n)).join(", ")+", ..., "+O.map(($,I)=>Xe($,r[i-He+I],n)).join(", ")+"]"]}return["["+(n==="complex64"?Ze(e):Array.from(e)).map((N,E)=>Xe(N,r[E],n)).join(", ")+"]"]}const c=t.slice(1),l=s.slice(1),h=s[0]*o,f=[];if(i>ma){for(let T=0;T<He;T++){const N=T*h,E=N+h;f.push(...Dn(e.slice(N,E),c,n,l,r,!1))}f.push("...");for(let T=i-He;T<i;T++){const N=T*h,E=N+h;f.push(...Dn(e.slice(N,E),c,n,l,r,T===i-1))}}else for(let T=0;T<i;T++){const N=T*h,E=N+h;f.push(...Dn(e.slice(N,E),c,n,l,r,T===i-1))}const m=u===2?",":"";f[0]="["+(i>0?f[0]+m:"");for(let T=1;T<f.length-1;T++)f[T]=" "+f[T]+m;let S=`,
`;for(let T=2;T<u;T++)S+=`
`;return f[f.length-1]=" "+f[f.length-1]+"]"+(a?"":S),f}function Ze(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class Vn{constructor(t,n,s){if(this.dtype=n,this.shape=t.slice(),this.size=q(t),s!=null){const r=s.length;g(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||Ys(n,this.size),this.strides=Ue(t)}set(t,...n){n.length===0&&(n=[0]),g(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const s=this.locToIndex(n);this.values[s]=t}get(...t){t.length===0&&(t=[0]);let n=0;for(const r of t){if(r<0||r>=this.shape[n]){const a=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(a)}n++}let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=this.strides[r]*t[r];return this.values[s]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let n=t[t.length-1];for(let s=0;s<t.length-1;++s)n+=this.strides[s]*t[s];return n}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const n=new Array(this.shape.length);for(let s=0;s<n.length-1;++s)n[s]=Math.floor(t/this.strides[s]),t-=n[s]*this.strides[s];return n[n.length-1]=t,n}get rank(){return this.shape.length}toTensor(){return xt().makeTensor(this.values,this.shape,this.dtype)}}let xt=null,Ae=null;function Mf(e){xt=e}function Uf(e){Ae=e}class nt{constructor(t,n,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=n||"float32",this.size=q(t),this.strides=Ue(t),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return Ae.buffer(this.shape,this.dtype,t)}bufferSync(){return Ae.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return be(this.shape,t,this.dtype==="complex64")}arraySync(){return be(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=xt().read(this.dataId);if(this.dtype==="string"){const n=await t;try{return n.map(s=>zn(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),xt().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=xt().readSync(this.dataId);if(this.dtype==="string")try{return t.map(n=>zn(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await xt().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),xt().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Ae.print(this,t)}clone(){return this.throwIfDisposed(),Ae.clone(this)}toString(t=!1){const n=this.dataSync();return Vf(n,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Ae.cast(this,t)}variable(t=!0,n,s){return this.throwIfDisposed(),xt().makeVariable(this,t,n,s)}}Object.defineProperty(nt,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function cc(){return er("Tensor",()=>nt)}cc();class sn extends nt{constructor(t,n,s,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=n,this.name=s}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Rt(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);xt().disposeTensor(this),this.dataId=t.dataId,xt().incRef(this,null)}dispose(){xt().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(sn,Symbol.hasInstance,{value:e=>e instanceof nt&&e.assign!=null&&e.assign instanceof Function});var _s;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(_s||(_s={}));var Is;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(Is||(Is={}));var As;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(As||(As={}));var xs;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(xs||(xs={}));var Os;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(Os||(Os={}));const jf={float32:xs,int32:Is,bool:As,complex64:Os};function Jn(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return jf[e][t]}function qf(e){return Jn(e,"int32")}function lc(e){return e!=null&&typeof e=="object"&&"texture"in e&&e.texture instanceof WebGLTexture}function hc(e){return typeof GPUBuffer<"u"&&e!=null&&typeof e=="object"&&"buffer"in e&&e.buffer instanceof GPUBuffer}function tt(e,t){if(e.dtype===t.dtype)return[e,t];const n=Jn(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function pc(e,t){g(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function Gf(e,t){return t.some(n=>n.id===e.id)}function ur(e){const t=[];return fc(e,t,new Set),t}function fc(e,t,n){if(e==null)return;if(e instanceof nt){t.push(e);return}if(!Hf(e))return;const s=e;for(const r in s){const a=s[r];n.has(a)||(n.add(a),fc(a,t,n))}}function Hf(e){return Array.isArray(e)||typeof e=="object"}const Kf=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:pc,getTensorsInContainer:ur,isTensorInList:Gf,makeTypesMatch:tt},Symbol.toStringTag,{value:"Module"}));function ms(e){return e.kernelName!=null}class ga{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class Be{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new ga}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const s=t[n];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,s=1){return t in this.registryFactory?(Jt(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:s},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:n,asyncInit:s}=this.initializeBackend(t);if(!(s?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new Ff(this.backendInstance),!0}setupRegisteredKernels(){Pn(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){Pn(t).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[t])})}initializeBackend(t){const n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const s=n.factory();if(s&&!(s instanceof Qa)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,a=s.then(o=>r<this.pendingBackendInitId?!1:(this.registry[t]=o,this.pendingBackendInit=null,!0)).catch(o=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Jt(`Initialization of backend ${t} failed`),Jt(o.stack||o.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[t]=s,{success:!0,asyncInit:!1}}catch(s){return Jt(`Initialization of backend ${t} failed`),Jt(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const s=t[n],{success:r,asyncInit:a}=this.initializeBackend(s);if(a||r)return{name:s,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){const s=this.state.tensorInfo.get(n),r=s.backend,a=this.readSync(n),o=r.refCount(n);r.disposeData(n,!0),s.backend=t,t.move(n,a,s.shape,s.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let s=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=n(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(t,n,s){t();try{const r=s();return n(),r}catch(r){throw n(),r}}nextTensorId(){return Be.nextTensorId++}nextVariableId(){return Be.nextVariableId++}clone(t){const n=w.runKernel(ar,{x:t}),s={x:t},r=o=>({x:()=>{const i="float32",u={x:o},c={dtype:i};return w.runKernel(sr,u,c)}}),a=[];return this.addTapeNode(this.state.activeScope.name,s,[n],r,a,{}),n}runKernel(t,n,s){if(this.backendName==null&&this.backend,!(en(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,s){const r=this.backend.numDataIds();let a=0;s.forEach(u=>{a+=u.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-n-a-o;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${t}'`)}runKernelFunc(t){let n,s=[];const r=this.isTapeOn(),a=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let u;const c=ms(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(ms(t)){const{kernelName:S,inputs:T,attrs:N}=t;this.backendName==null&&this.backend;const E=en(S,this.backendName);g(E!=null,()=>`Cannot find registered kernel '${S}' for backend '${this.backendName}'`),i=()=>{const O=this.backend.numDataIds();u=E.kernelFunc({inputs:T,attrs:N,backend:this.backend});const $=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(S,O,$);const I=$.map(D=>D.rank!=null?D:this.makeTensorFromTensorInfo(D));if(r){const D=this.getTensorsForGradient(S,T,I);s=this.saveTensorsForBackwardMode(D)}return I}}else{const{forwardFunc:S}=t,T=N=>{r&&(s=N.map(E=>this.keep(this.clone(E))))};i=()=>{const N=this.backend.numDataIds();u=this.tidy(()=>S(this.backend,T));const E=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,N,E),E}}const{inputs:l,attrs:h}=t,f=ms(t)?null:t.backwardsFunc;let m;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=i():(m=this.profiler.profileKernel(c,l,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(m),n=m.outputs)}),r&&this.addTapeNode(c,l,n,f,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map(S=>l[S]!=null?l[S].shape:null),outputShapes:n.map(S=>S.shape),kernelTimeMs:m.timeMs,extraInfo:m.extraInfo}),Array.isArray(u)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(t,n,s){const r=vs(t);if(r!=null){const a=r.inputsToSave||[],o=r.outputsToSave||[];let i;r.saveAllInputs?(g(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(n).map(c=>n[c])):i=a.map(c=>n[c]);const u=s.filter((c,l)=>o[l]);return i.concat(u)}return[]}makeTensor(t,n,s,r){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let a=t;s==="string"&&Qt(t[0])&&(a=t.map(u=>yn(u)));const o=r.write(a,n,s),i=new nt(n,s,o,this.nextTensorId());if(this.trackTensor(i,r),s==="string"){const u=this.state.tensorInfo.get(o),c=oo(a);this.state.numBytes+=c-u.bytes,u.bytes=c}return i}makeTensorFromDataId(t,n,s,r){s=s||"float32";const a={dataId:t,shape:n,dtype:s};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(t,n){const{dataId:s,shape:r,dtype:a}=t,o=new nt(r,a,s,this.nextTensorId());return this.trackTensor(o,n),o}makeVariable(t,n=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==t.dtype&&(t=t.cast(r));const a=new sn(t,n,s,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let s=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(s=t.size*Ln(t.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:s})),t instanceof sn||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const s=t.size*Ln(t.dtype);this.state.numBytes-=s}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const n=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,s,r,a,o){const i={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:s,saved:a},u=vs(t);u!=null&&(r=u.gradFunc),r!=null&&(i.gradient=c=>(c=c.map((l,h)=>{if(l==null){const f=s[h],m=Xn(f.size,f.dtype);return this.makeTensor(m,f.shape,f.dtype)}return l}),r(c.length>1?c:c[0],a,o))),this.state.activeTape.push(i)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){const n=ur(t),s=new Set(n.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){const o=this.state.activeScope.track[a];!o.kept&&!s.has(o.id)&&o.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(a=>{!a.kept&&a.scopeId===r.id&&this.track(a)})}gradients(t,n,s,r=!1){if(g(n.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));g(a instanceof nt,()=>"The result y returned by f() must be a tensor.");const o=Pf(this.state.activeTape,n,a);if(!r&&o.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const i={};i[a.id]=s??Xf(a.shape),zf(i,o,c=>this.tidy(c),Zf);const u=n.map(c=>i[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const l of c.saved)l.dispose()}),this.state.activeTape=null),{value:a,grads:u}})}customGrad(t){return g(se(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{g(n.every(i=>i instanceof nt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};n.forEach((i,u)=>{r[u]=i});const a=(i,u)=>(s=t(...n,u),g(s.value instanceof nt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),g(se(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),o=(i,u)=>{const c=s.gradFunc(i,u),l=Array.isArray(c)?c:[c];g(l.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),g(l.every(f=>f instanceof nt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return l.forEach((f,m)=>{h[m]=()=>f}),h};return this.runKernelFunc({forwardFunc:a,backwardsFunc:o,inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){const n=nn(),s=await this.backend.time(t);return s.wallMs=nn()-n,s}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new ga;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Be.nextTensorId=0;Be.nextVariableId=0;function Xf(e){const t=Qs(q(e),"float32");return w.makeTensor(t,e,"float32")}function dc(){const e=ho();if(e._tfengine==null){const t=new lo(e);e._tfengine=new Be(t)}return Jp(e._tfengine.ENV),Mf(()=>e._tfengine),e._tfengine}const w=dc();function Zf(e,t){const n={a:e,b:t};return w.runKernel(nr,n)}function Jf(){return typeof navigator<"u"&&navigator!=null}let Ds;function Yf(e){Ds=e}function Qf(e){if(Ds!==void 0)return Ds;if(e||Jf()){if(e||(e=navigator),e.product==="ReactNative")return!0;const t=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");if(!t){const n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function mc(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const td=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:mc,isMobile:Qf,mockIsMobile:Yf},Symbol.toStringTag,{value:"Module"}));const yt=P();yt.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});yt.registerFlag("IS_BROWSER",()=>mc());yt.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");yt.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));yt.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));yt.registerFlag("PROD",()=>!1);yt.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>yt.getBool("DEBUG"));yt.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);yt.registerFlag("IS_TEST",()=>!1);yt.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>yt.getBool("DEBUG"));yt.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);yt.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);yt.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Bt(e,t){let n=e;if(it(e))return t==="string"?[]:[e.length];if(lc(e)){const r=e.channels||"RGBA";return[e.height,e.width*r.length]}else if(hc(e))return[e.buffer.size/(t==null?4:Ln(t))];if(!Array.isArray(e))return[];const s=[];for(;Array.isArray(n)||it(n)&&t!=="string";)s.push(n.length),n=n[0];return Array.isArray(e)&&P().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&gc(e,s,[]),s}function gc(e,t,n){if(n=n||[],!Array.isArray(e)&&!it(e)){g(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}g(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),g(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);const s=t.slice(1);for(let r=0;r<e.length;++r)gc(e[r],s,n.concat(r))}function ya(e,t,n,s){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${s}' must be ${e} tensor, but got ${t} tensor`)}}function d(e,t,n,s="numeric"){if(e instanceof cc())return ya(s,e.dtype,t,n),e;let r=mn(e);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),ya(s,r,t,n),e==null||!it(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){const u=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${u}'`)}const a=Bt(e,r);!it(e)&&!Array.isArray(e)&&(e=[e]);const i=r!=="string"?Zn(e,r):ae(e,[],!0);return w.makeTensor(i,a,r)}function rn(e,t,n,s="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((a,o)=>d(a,`${t}[${o}]`,n,s))}const cr="__op";function b(e){const t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const s=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+cr;const r=(...a)=>{w.startScope(n);try{const o=s(...a);return re(o)&&console.error("Cannot return a Promise inside of tidy."),w.endScope(o),o}catch(o){throw w.endScope(null),o}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}function ed(e,t){const n=d(e,"real","complex"),s=d(t,"imag","complex");gt(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:n,imag:s};return w.runKernel(Fo,r)}const Kt=b({complex_:ed});function ce(e,t,n,s){if(s==null)s=mn(e);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(hc(e)||lc(e)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return w.backend.createTensorFromGPUData(e,t||n,s)}if(!it(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Et(t);const r=q(t),a=q(n);g(r===a,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${a}`);for(let o=0;o<n.length;++o){const i=n[o],u=o===n.length-1?i!==q(t.slice(o)):!0;g(n[o]===t[o]||!u,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!it(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=s!=="string"?Zn(e,s):ae(e,[],!0),w.makeTensor(e,t,s)}function Dt(e,t,n){const s=Bt(e,n);return ce(e,t,s,n)}const Se={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Ft{static join(t){return new Ft(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(s=>it(s)?s.buffer:s),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let n=0;for(let s=0;s<t.length;s++){const r=t[s];s!==t.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=n+r.byteLength;this.shards.push({buffer:r,start:n,end:a}),n=a}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,n=isNaN(Number(n))?0:n,t=Math.max(0,t),n=Math.min(this.byteLength,n),n<=t)return new ArrayBuffer(0);const s=this.findShardForByte(t);if(s===-1)throw new Error(`Could not find start shard for byte ${t}`);const r=n-t,a=new ArrayBuffer(r),o=new Uint8Array(a);let i=0;for(let u=s;u<this.shards.length;u++){const c=this.shards[u],h=t+i-c.start,f=i,S=Math.min(n,c.end)-c.start,T=new Uint8Array(c.buffer,h,S-h);if(o.set(T,f),i+=T.length,n<c.end)break}return a}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function n(r){return t<r.start?-1:t>=r.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=nd(this.shards,n);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function nd(e,t){let n=0,s=e.length;for(;n<=s;){const r=Math.floor((s-n)/2)+n,a=t(e[r]);if(a===0)return r;a<0?s=r:n=r+1}return-1}function sd(){P().set("PROD",!0)}function rd(){P().set("DEBUG",!0)}function ad(){P().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function od(e){P().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function id(){w.disposeVariables()}function ud(){return w}function cd(){return w.memory()}function ld(e){return w.profile(e)}function j(e,t){return w.tidy(e,t)}function mt(e){ur(e).forEach(n=>n.dispose())}function Ot(e){return w.keep(e)}function hd(e){return w.time(e)}function pd(e){return w.setBackend(e)}function fd(){return w.ready()}function yc(){return w.backendName}function dd(e){w.removeBackend(e)}function md(e){return w.findBackend(e)}function gd(e){return w.findBackendFactory(e)}function yd(e,t,n=1){return w.registerBackend(e,t,n)}function bc(){return w.backend}function bd(e,t){P().setPlatform(e,t)}const oe=4;async function wd(e,t){const n=[],s=[],r=Array.isArray(e)?e.map(o=>o.name):Object.keys(e);for(let o=0;o<r.length;++o){const i=r[o],u=Array.isArray(e)?e[o].tensor:e[i];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${u.dtype}`);const c={name:i,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const l=new Promise(async h=>{const f=await u.bytes(),m=f.reduce((N,E)=>N+E.length,0)+oe*f.length,S=new Uint8Array(m);let T=0;for(let N=0;N<f.length;N++){const E=f[N],O=new Uint8Array(new Uint32Array([E.length]).buffer);S.set(O,T),T+=oe,S.set(E,T),T+=E.length}h(S)});s.push(l)}else s.push(u.data());t!=null&&(c.group=t),n.push(c)}const a=await Promise.all(s);return{data:Td(a),specs:n}}function wc(e,t){const n=new Ft(e),s={};let r=0;for(const a of t){const o=Nd(a,(i,u)=>n.slice(r+i,r+u));s[a.name]=Nc(a,n.slice(r,r+o)),r+=o}return s}function Nd(e,t){const n=q(e.shape);let s;if("quantization"in e){const r=e.quantization;s=Se[r.dtype]}else if(e.dtype==="string"){let r=0;for(let a=0;a<n;a++)r+=oe+new Uint32Array(t(r,r+oe))[0];return r}else s=Se[e.dtype];return n*s}async function Sd(e,t){const n=q(e.shape);let s;if("quantization"in e){const r=e.quantization;s=Se[r.dtype]}else if(e.dtype==="string"){let r=0;for(let a=0;a<n;a++)r+=oe+new Uint32Array(await t(r,r+oe))[0];return r}else s=Se[e.dtype];return n*s}function Nc(e,t){const n=e.name,s=e.dtype,r=e.shape,a=q(r);let o,i=0;if("quantization"in e){const u=e.quantization;if(u.dtype==="uint8"||u.dtype==="uint16"){if(!("min"in u&&"scale"in u))throw new Error(`Weight ${e.name} with quantization ${u.dtype} doesn't have corresponding metadata min and scale.`)}else if(u.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${e.name} is quantized with ${u.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${e.name} has unknown quantization dtype ${u.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const c=Se[u.dtype],l=u.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(s==="float32")if(u.dtype==="uint8"||u.dtype==="uint16"){o=new Float32Array(l.length);for(let h=0;h<l.length;h++){const f=l[h];o[h]=f*u.scale+u.min}}else if(u.dtype==="float16")o=Ad()(l);else throw new Error(`Unsupported quantization type ${u.dtype} for weight type float32.`);else if(s==="int32"){if(u.dtype!=="uint8"&&u.dtype!=="uint16")throw new Error(`Unsupported quantization type ${u.dtype} for weight type int32.`);o=new Int32Array(l.length);for(let h=0;h<l.length;h++){const f=l[h];o[h]=Math.round(f*u.scale+u.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${s}`);i+=a*c}else if(s==="string"){const u=q(e.shape);o=[];for(let c=0;c<u;c++){const l=new Uint32Array(t.slice(i,i+oe))[0];i+=oe;const h=new Uint8Array(t.slice(i,i+l));o.push(h),i+=l}}else{const u=Se[s];if(s==="float32")o=new Float32Array(t);else if(s==="int32")o=new Int32Array(t);else if(s==="bool")o=new Uint8Array(t);else if(s==="complex64"){o=new Float32Array(t);const c=new Float32Array(o.length/2),l=new Float32Array(o.length/2);for(let S=0;S<c.length;S++)c[S]=o[S*2],l[S]=o[S*2+1];const h=Dt(c,r,"float32"),f=Dt(l,r,"float32"),m=Kt(h,f);return h.dispose(),f.dispose(),m}else throw new Error(`Unsupported dtype in weight '${n}': ${s}`);i+=a*u}return Dt(o,r,s)}async function ba(e,t,n){let s=new Uint8Array(t);for(;s.byteLength<n;){const{done:r,value:a}=await e.read();if(r&&a==null){const i=n-s.byteLength;throw new Error(`Reader is done but ${i} bytes are still expected`)}const o=new Uint8Array(s.length+a.byteLength);o.set(s,0),o.set(new Uint8Array(a),s.length),s=o}return s.buffer}async function Sc(e,t){const n={},s=e.getReader();let r=new ArrayBuffer(0);for(const a of t){const o=await Sd(a,async(c,l)=>(r=await ba(s,r,l),r.slice(c,l)));r=await ba(s,r,o);const i=r.slice(0,o);r=r.slice(o);const u=Nc(a,i);if(n[a.name]=u,yc()==="webgpu"){const c=bc();"uploadToGPU"in c&&q(u.shape)>=P().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&c.uploadToGPU(u.dataId)}}return n}function Td(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach(a=>{if(t+=a.byteLength,n.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});const s=new Uint8Array(t);let r=0;return n.forEach(a=>{s.set(new Uint8Array(a.buffer),r),r+=a.byteLength}),s.buffer}const lr=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function wa(e){return lr?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function Ed(e){if(lr)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let s=0,r=t.length;s<r;s++)n+=String.fromCharCode(t[s]);return btoa(n)}function $d(e){if(lr){const s=Buffer.from(e,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let s=0;s<t.length;++s)n.set([t.charCodeAt(s)],s);return n.buffer}function vd(e){return Ft.join(e)}function Na(e){const t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);const n=e.split(t);return n[n.length-1]}function Tc(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function hr(e,t,n){const s={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(s.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=t,s.weightData=n}return e.signature!=null&&(s.signature=e.signature),e.userDefinedMetadata!=null&&(s.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(s.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(s.initializerSignature=e.initializerSignature),s}async function pr(e,t){let n,s;return e.weightsManifest!=null&&([n,s]=await t(e.weightsManifest)),hr(e,n,s)}function bn(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:wa(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:wa(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new Ft(e.weightData).byteLength}}function Wn(e){const t=[];for(const n of e)t.push(...n.weights);return t}function kd(){const e=n=>{let s=n<<13,r=0;for(;(s&8388608)===0;)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function _d(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function Id(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function Ad(){const e=kd(),t=_d(),n=Id();return s=>{const r=new ArrayBuffer(4*s.length),a=new Uint32Array(r);for(let o=0;o<s.length;o++){const i=s[o],u=e[n[i>>10]+(i&1023)]+t[i>>10];a[o]=u}return new Float32Array(r)}}class Q{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Q.instance==null&&(Q.instance=new Q),Q.instance}static registerSaveRouter(t){Q.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Q.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Q.getHandlers(t,"save")}static getLoadHandlers(t,n){return Q.getHandlers(t,"load",n)}static getHandlers(t,n,s){const r=[];return(n==="load"?Q.getInstance().loadRouters:Q.getInstance().saveRouters).forEach(o=>{const i=o(t,s);i!==null&&r.push(i)}),r}}const xd=e=>Q.registerSaveRouter(e),Od=e=>Q.registerLoadRouter(e),Dd=e=>Q.getSaveHandlers(e),Cd=(e,t)=>Q.getLoadHandlers(e,t);const Cs="tensorflowjs",Rs=1,ye="models_store",te="model_info_store";function Ec(){if(!P().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e=typeof window>"u"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Fs(e){const t=e.result;t.createObjectStore(ye,{keyPath:"modelPath"}),t.createObjectStore(te,{keyPath:"modelPath"})}class Te{constructor(t){if(this.indexedDB=Ec(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,n){return new Promise((s,r)=>{const a=this.indexedDB.open(Cs,Rs);a.onupgradeneeded=()=>Fs(a),a.onsuccess=()=>{const o=a.result;if(n==null){const i=o.transaction(ye,"readonly"),c=i.objectStore(ye).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return o.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=l=>(o.close(),r(c.error)),i.oncomplete=()=>o.close()}else{n.weightData=Ft.join(n.weightData);const i=bn(n),u=o.transaction(te,"readwrite");let c=u.objectStore(te),l;try{l=c.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(f){return r(f)}let h;l.onsuccess=()=>{h=o.transaction(ye,"readwrite");const f=h.objectStore(ye);let m;try{m=f.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:i})}catch(S){return r(S)}m.onsuccess=()=>s({modelArtifactsInfo:i}),m.onerror=S=>{c=u.objectStore(te);const T=c.delete(this.modelPath);T.onsuccess=()=>(o.close(),r(m.error)),T.onerror=N=>(o.close(),r(m.error))}},l.onerror=f=>(o.close(),r(l.error)),u.oncomplete=()=>{h==null?o.close():h.oncomplete=()=>o.close()}}},a.onerror=o=>r(a.error)})}}Te.URL_SCHEME="indexeddb://";const $c=e=>P().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Te.URL_SCHEME)?Rd(e.slice(Te.URL_SCHEME.length)):null;Q.registerSaveRouter($c);Q.registerLoadRouter($c);function Rd(e){return new Te(e)}function Fd(e){return e.startsWith(Te.URL_SCHEME)?e.slice(Te.URL_SCHEME.length):e}class Ld{constructor(){this.indexedDB=Ec()}async listModels(){return new Promise((t,n)=>{const s=this.indexedDB.open(Cs,Rs);s.onupgradeneeded=()=>Fs(s),s.onsuccess=()=>{const r=s.result,a=r.transaction(te,"readonly"),i=a.objectStore(te).getAll();i.onsuccess=()=>{const u={};for(const c of i.result)u[c.modelPath]=c.modelArtifactsInfo;t(u)},i.onerror=u=>(r.close(),n(i.error)),a.oncomplete=()=>r.close()},s.onerror=r=>n(s.error)})}async removeModel(t){return t=Fd(t),new Promise((n,s)=>{const r=this.indexedDB.open(Cs,Rs);r.onupgradeneeded=()=>Fs(r),r.onsuccess=()=>{const a=r.result,o=a.transaction(te,"readwrite"),i=o.objectStore(te),u=i.get(t);let c;u.onsuccess=()=>{if(u.result==null)return a.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const l=i.delete(t),h=()=>{c=a.transaction(ye,"readwrite");const m=c.objectStore(ye).delete(t);m.onsuccess=()=>n(u.result.modelArtifactsInfo),m.onerror=S=>s(u.error)};l.onsuccess=h,l.onerror=f=>(h(),a.close(),s(u.error))}},u.onerror=l=>(a.close(),s(u.error)),o.oncomplete=()=>{c==null?a.close():c.oncomplete=()=>a.close()}},r.onerror=a=>s(r.error)})}}const qt="/",xe="tensorflowjs_models",vc="info",Bd="model_topology",Pd="weight_specs",zd="weight_data",Vd="model_metadata";function kc(e){return{info:[xe,e,vc].join(qt),topology:[xe,e,Bd].join(qt),weightSpecs:[xe,e,Pd].join(qt),weightData:[xe,e,zd].join(qt),modelMetadata:[xe,e,Vd].join(qt)}}function _c(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function Wd(e){const t=e.split(qt);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(qt)}function Md(e){return e.startsWith(Ee.URL_SCHEME)?e.slice(Ee.URL_SCHEME.length):e}class Ee{constructor(t){if(!P().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=kc(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(t.modelTopology),s=JSON.stringify(t.weightSpecs),r=bn(t),a=Ft.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,Ed(a));const o={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:r}}catch{throw _c(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){const i=JSON.parse(a);n.format=i.format,n.generatedBy=i.generatedBy,n.convertedBy=i.convertedBy,i.signature!=null&&(n.signature=i.signature),i.userDefinedMetadata!=null&&(n.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(n.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(n.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(n.trainingConfig=i.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=$d(o),n}}Ee.URL_SCHEME="localstorage://";const Ic=e=>P().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ee.URL_SCHEME)?Ud(e.slice(Ee.URL_SCHEME.length)):null;Q.registerSaveRouter(Ic);Q.registerLoadRouter(Ic);function Ud(e){return new Ee(e)}class jd{constructor(){g(P().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),g(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},n=xe+qt,s=qt+vc;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);if(a.startsWith(n)&&a.endsWith(s)){const o=Wd(a);t[o]=JSON.parse(this.LS.getItem(a))}}return t}async removeModel(t){t=Md(t);const n=kc(t);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(this.LS.getItem(n.info));return _c(n),s}}const Oe="://";class pt{constructor(){this.managers={}}static getInstance(){return pt.instance==null&&(pt.instance=new pt),pt.instance}static registerManager(t,n){g(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(Oe)&&(t=t.slice(0,t.indexOf(Oe))),g(t.length>0,()=>"scheme must not be an empty string.");const s=pt.getInstance();g(s.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),s.managers[t]=n}static getManager(t){const n=pt.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(pt.getInstance().managers)}}function Cn(e){if(e.indexOf(Oe)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${pt.getSchemes().join(",")}`);return{scheme:e.split(Oe)[0],path:e.split(Oe)[1]}}async function Ac(e,t,n=!1){g(e!==t,()=>`Old path and new path are the same: '${e}'`);const s=Q.getLoadHandlers(e);g(s.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),g(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${e}.`);const r=s[0],a=Q.getSaveHandlers(t);g(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),g(a.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${t}.`);const o=a[0],i=Cn(e).scheme,u=Cn(e).path,c=i===Cn(e).scheme,l=await r.load();n&&c&&await pt.getManager(i).removeModel(u);const h=await o.save(l);return n&&!c&&await pt.getManager(i).removeModel(u),h.modelArtifactsInfo}async function qd(){const e=pt.getSchemes(),t={};for(const n of e){const s=await pt.getManager(n).listModels();for(const r in s){const a=n+Oe+r;t[a]=s[r]}}return t}async function Gd(e){const t=Cn(e);return pt.getManager(t.scheme).removeModel(t.path)}async function Hd(e,t){return Ac(e,t,!1)}async function Kd(e,t){return Ac(e,t,!0)}class Xd{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,n){return fetch(t,n)}now(){return performance.now()}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,n){return new TextDecoder(n).decode(t)}setTimeoutCustom(t,n){if(typeof window>"u"||!P().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,n);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return sc(t)}}if(P().get("IS_BROWSER")){P().setPlatform("browser",new Xd);try{pt.registerManager(Ee.URL_SCHEME,new jd)}catch{}try{pt.registerManager(Te.URL_SCHEME,new Ld)}catch{}}const Zd={importFetch:()=>require("node-fetch")};let gs;class Jd{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,n){return P().global.fetch!=null?P().global.fetch(t,n):(gs==null&&(gs=Zd.importFetch()),gs(t,n))}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(t)}decode(t,n){return t.length===0?"":new this.util.TextDecoder(n).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}P().get("IS_NODE")&&!P().get("IS_BROWSER")&&P().setPlatform("node",new Jd);function Pt(e,t="float32",n){return t=t||"float32",Et(e),new Vn(e,t,n)}function Yd(e,t){const n=d(e,"x","cast");if(!ao(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:n},r={dtype:t};return w.runKernel(sr,s,r)}const Z=b({cast_:Yd});function Qd(e){const n={x:d(e,"x","clone","string_or_numeric")};return w.runKernel(ar,n)}const Gt=b({clone_:Qd});function fr(e,t=!1){console.log(e.toString(t))}dc();const tm={buffer:Pt,cast:Z,clone:Gt,print:fr};Uf(tm);function em(e,t){let n=d(e,"a","add"),s=d(t,"b","add");[n,s]=tt(n,s);const r={a:n,b:s};return w.runKernel(nr,r)}const B=b({add_:em});function nm(e,t){let n=d(e,"a","floorDiv"),s=d(t,"b","floorDiv");[n,s]=tt(n,s);const r={a:n,b:s};return w.runKernel(fi,r)}const dr=b({floorDiv_:nm});function sm(e,t){let n=d(e,"a","div"),s=d(t,"b","div");if([n,s]=tt(n,s),n.dtype==="int32"&&s.dtype==="int32")return dr(n,s);const r={a:n,b:s},a={};return w.runKernel(ei,r,a)}const X=b({div_:sm});function rm(e,t){let n=d(e,"a","mul"),s=d(t,"b","mul");[n,s]=tt(n,s);const r={a:n,b:s};return w.runKernel(qi,r)}const C=b({mul_:rm});function am(e){const t=d(e,"x","abs");if(t.dtype==="complex64"){const n={x:t};return w.runKernel(Lo,n)}else{const n={x:t};return w.runKernel(po,n)}}const St=b({abs_:am});function om(e){const n={x:d(e,"x","acos")};return w.runKernel(fo,n)}const xc=b({acos_:om});function im(e){const n={x:d(e,"x","acosh")};return w.runKernel(mo,n)}const Oc=b({acosh_:im});function um(e){g(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),g(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);const t=e.map((r,a)=>d(r,`tensors${a}`,"addN")),n=t[0];t.forEach(r=>{if(r.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(r=>{if(!Rt(r.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=t;return w.runKernel(go,s)}const Dc=b({addN_:um});function cm(e,t=null,n=!1){const r={x:d(e,"x","all","bool")},a={axis:t,keepDims:n};return w.runKernel(yo,r,a)}const Cc=b({all_:cm});function lm(e,t=null,n=!1){const r={x:d(e,"x","any","bool")},a={axis:t,keepDims:n};return w.runKernel(bo,r,a)}const Rc=b({any_:lm});function hm(e,t=0){const s={x:d(e,"x","argMax")},r={axis:t};return w.runKernel(wo,s,r)}const Fc=b({argMax_:hm});function pm(e,t=0){const s={x:d(e,"x","argMin")},r={axis:t};return w.runKernel(No,s,r)}const Lc=b({argMin_:pm});function fm(e){const n={x:d(e,"x","asin")};return w.runKernel(So,n)}const Bc=b({asin_:fm});function dm(e){const n={x:d(e,"x","asinh")};return w.runKernel(To,n)}const Pc=b({asinh_:dm});function mm(e){const n={x:d(e,"x","atan")};return w.runKernel(Eo,n)}const zc=b({atan_:mm});function gm(e,t){let n=d(e,"a","atan2"),s=d(t,"b","atan2");[n,s]=tt(n,s);const r={a:n,b:s};return w.runKernel(vo,r)}const Vc=b({atan2_:gm});function ym(e){const n={x:d(e,"x","atanh")};return w.runKernel($o,n)}const Wc=b({atanh_:ym});function bm(e,t,n,s,r="NHWC",a){const o=e[3],i=[...t,o],u=jc(r);return wn(e,i,n,a,s,null,null,u)}function Mc(e,t,n,s,r,a,o="channelsLast"){const[i,u]=an(t);let c;if(o==="channelsLast")c=[i,u,e[3],e[3]];else if(o==="channelsFirst")c=[i,u,e[1],e[1]];else throw new Error(`Unknown dataFormat ${o}`);return wn(e,c,n,s,r,a,!1,o)}function wm(e,t,n,s,r,a,o="NDHWC"){const[i,u,c]=Ls(t);let l,h;if(o==="NDHWC")h="channelsLast",l=[i,u,c,e[4],e[4]];else if(o==="NCDHW")h="channelsFirst",l=[i,u,c,e[1],e[1]];else throw new Error(`Unknown dataFormat ${o}`);return Uc(e,l,n,s,r,!1,h,a)}function wn(e,t,n,s,r,a,o=!1,i="channelsLast"){let[u,c,l,h]=[-1,-1,-1,-1];if(i==="channelsLast")[u,c,l,h]=e;else if(i==="channelsFirst")[u,h,c,l]=e;else throw new Error(`Unknown dataFormat ${i}`);const[f,m,,S]=t,[T,N]=an(n),[E,O]=an(s),$=De(f,E),I=De(m,O),{padInfo:D,outHeight:x,outWidth:F}=Tm(r,c,l,T,N,$,I,a,i),R=o?S*h:S;let k;return i==="channelsFirst"?k=[u,R,x,F]:i==="channelsLast"&&(k=[u,x,F,R]),{batchSize:u,dataFormat:i,inHeight:c,inWidth:l,inChannels:h,outHeight:x,outWidth:F,outChannels:R,padInfo:D,strideHeight:T,strideWidth:N,filterHeight:f,filterWidth:m,effectiveFilterHeight:$,effectiveFilterWidth:I,dilationHeight:E,dilationWidth:O,inShape:e,outShape:k,filterShape:t}}function Uc(e,t,n,s,r,a=!1,o="channelsLast",i){let[u,c,l,h,f]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[u,c,l,h,f]=e;else if(o==="channelsFirst")[u,f,c,l,h]=e;else throw new Error(`Unknown dataFormat ${o}`);const[m,S,T,,N]=t,[E,O,$]=Ls(n),[I,D,x]=Ls(s),F=De(m,I),R=De(S,D),k=De(T,x),{padInfo:v,outDepth:y,outHeight:A,outWidth:L}=Em(r,c,l,h,E,O,$,F,R,k,i),V=a?N*f:N;let z;return o==="channelsFirst"?z=[u,V,y,A,L]:o==="channelsLast"&&(z=[u,y,A,L,V]),{batchSize:u,dataFormat:o,inDepth:c,inHeight:l,inWidth:h,inChannels:f,outDepth:y,outHeight:A,outWidth:L,outChannels:V,padInfo:v,strideDepth:E,strideHeight:O,strideWidth:$,filterDepth:m,filterHeight:S,filterWidth:T,effectiveFilterDepth:F,effectiveFilterHeight:R,effectiveFilterWidth:k,dilationDepth:I,dilationHeight:D,dilationWidth:x,inShape:e,outShape:z,filterShape:t}}function Nm(e,t,n,s,r){s==null&&(s=mr(e,t,n));const a=e[0],o=e[1],i=on((a-t+2*s)/n+1,r),u=on((o-t+2*s)/n+1,r);return[i,u]}function Sm(e,t,n,s,r,a){r==null&&(r=mr(e,t[0],s[0]));const o=[0,0,0,n];for(let i=0;i<3;i++)e[i]+2*r>=t[i]&&(o[i]=on((e[i]-t[i]+2*r)/s[i]+1,a));return o}function mr(e,t,n,s=1){const r=De(t,s);return Math.floor((e[0]*(n-1)-n+r)/2)}function an(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function Ls(e){return typeof e=="number"?[e,e,e]:e}function De(e,t){return t<=1?e:e+(e-1)*(t-1)}function Tm(e,t,n,s,r,a,o,i,u){let c,l,h;if(typeof e=="number"){c={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};const m=Nm([t,n],a,s,e,i);l=m[0],h=m[1]}else if(e==="same"){l=Math.ceil(t/s),h=Math.ceil(n/r);const f=Math.max(0,(l-1)*s+a-t),m=Math.max(0,(h-1)*r+o-n),S=Math.floor(f/2),T=f-S,N=Math.floor(m/2),E=m-N;c={top:S,bottom:T,left:N,right:E,type:"SAME"}}else if(e==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},l=Math.ceil((t-a+1)/s),h=Math.ceil((n-o+1)/r);else if(typeof e=="object"){const f=u==="channelsLast"?e[1][0]:e[2][0],m=u==="channelsLast"?e[1][1]:e[2][1],S=u==="channelsLast"?e[2][0]:e[3][0],T=u==="channelsLast"?e[2][1]:e[3][1];c={top:f,bottom:m,left:S,right:T,type:f===0&&m===0&&S===0&&T===0?"VALID":"EXPLICIT"},l=on((t-a+f+m)/s+1,i),h=on((n-o+S+T)/r+1,i)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:c,outHeight:l,outWidth:h}}function Em(e,t,n,s,r,a,o,i,u,c,l){let h,f,m,S;if(e==="valid"&&(e=0),typeof e=="number"){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};const N=Sm([t,n,s,1],[i,u,c],1,[r,a,o],e,l);f=N[0],m=N[1],S=N[2]}else if(e==="same"){f=Math.ceil(t/r),m=Math.ceil(n/a),S=Math.ceil(s/o);const T=(f-1)*r+i-t,N=(m-1)*a+u-n,E=(S-1)*o+c-s,O=Math.floor(T/2),$=T-O,I=Math.floor(N/2),D=N-I,x=Math.floor(E/2),F=E-x;h={top:I,bottom:D,left:x,right:F,front:O,back:$,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:h,outDepth:f,outHeight:m,outWidth:S}}function on(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function un(e){const[t,n,s]=an(e);return t===1&&n===1&&s===1}function Xt(e,t){return un(e)||un(t)}function $e(e){return an(e).every(t=>t>0)}function jc(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function At(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")g(Fe(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(s=>{s.forEach(r=>{g(Fe(r),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${r}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}function $m(e,t){const s={x:d(e,"x","reshape","string_or_numeric")},r={shape:t};return w.runKernel(hu,s,r)}const _=b({reshape_:$m});function vm(e,t,n,s,r){const a=d(e,"x","avgPool","float32"),o=1;g(Xt(n,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);let i=a,u=!1;a.rank===3&&(u=!0,i=_(a,[1,a.shape[0],a.shape[1],a.shape[2]])),g(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),At("avgPool",s,r);const c={x:i},l={filterSize:t,strides:n,pad:s,dimRoundingMode:r};let h=w.runKernel(ko,c,l);return h=Z(h,a.dtype),u?_(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const gr=b({avgPool_:vm});function km(e,t,n,s,r,a="NDHWC"){const o=d(e,"x","avgPool3d","float32");let i=o,u=!1;o.rank===4&&(u=!0,i=_(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),g(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),g(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),g(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),At("avgPool3d",s,r);const c={x:i},l={filterSize:t,strides:n,pad:s,dimRoundingMode:r,dataFormat:a};let h=w.runKernel(_o,c,l);return h=Z(h,i.dtype),u?_(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const qc=b({avgPool3d_:km});function _m(e,t=0){g(e.length>=1,()=>"Pass at least one tensor to concat");const n=rn(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),n.length===1)return Gt(n[0]);const s=n,r={axis:t};return w.runKernel(Bo,s,r)}const ht=b({concat_:_m});function Im(e,t,n=!1,s=!1){let r=d(e,"a","matMul"),a=d(t,"b","matMul");[r,a]=tt(r,a);const o={a:r,b:a},i={transposeA:n,transposeB:s};return w.runKernel(Io,o,i)}const U=b({matMul_:Im});function Am(e){const n={x:d(e,"x","sigmoid","float32")};return w.runKernel(_u,n)}const we=b({sigmoid_:Am});function xm(e,t,n){const s=d(e,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},a={begin:t,size:n};return w.runKernel(Eu,r,a)}const G=b({slice_:xm});function Om(e){const n={x:d(e,"x","tanh","float32")};return w.runKernel(Hu,n)}const Mn=b({tanh_:Om});function Dm(e,t,n,s,r,a){const o=d(e,"forgetBias","basicLSTMCell"),i=d(t,"lstmKernel","basicLSTMCell"),u=d(n,"lstmBias","basicLSTMCell"),c=d(s,"data","basicLSTMCell"),l=d(r,"c","basicLSTMCell"),h=d(a,"h","basicLSTMCell"),f=ht([c,h],1),m=U(f,i),S=B(m,u),T=S.shape[0],N=S.shape[1]/4,E=[T,N],O=G(S,[0,0],E),$=G(S,[0,N],E),I=G(S,[0,N*2],E),D=G(S,[0,N*3],E),x=B(C(we(O),Mn($)),C(l,we(B(o,I)))),F=C(Mn(x),we(D));return[x,F]}const Gc=b({basicLSTMCell_:Dm});function Cm(e,t,n){const s=d(e,"x","batchToSpaceND"),r=t.reduce((i,u)=>i*u);g(s.rank>=1+t.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`),g(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),g(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`);const a={x:s},o={blockShape:t,crops:n};return w.runKernel(Ao,a,o)}const yr=b({batchToSpaceND_:Cm});function Rm(e){let t;return e.rank===0||e.rank===1?t=_(e,[1,1,1,e.size]):e.rank===2?t=_(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=_(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}function Fm(e,t,n,s,r,a){a==null&&(a=.001);const o=d(e,"x","batchNorm"),i=d(t,"mean","batchNorm"),u=d(n,"variance","batchNorm");let c;r!=null&&(c=d(r,"scale","batchNorm"));let l;s!=null&&(l=d(s,"offset","batchNorm")),g(i.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),g(l==null||i.rank===l.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),g(c==null||i.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const f={x:Rm(o),scale:c,offset:l,mean:i,variance:u},m={varianceEpsilon:a},S=w.runKernel(di,f,m);return _(S,o.shape)}const Nn=b({batchNorm_:Fm});function Lm(e,t,n,s,r,a){const o=d(e,"x","batchNorm"),i=d(t,"mean","batchNorm"),u=d(n,"variance","batchNorm");let c;r!=null&&(c=d(r,"scale","batchNorm"));let l;return s!=null&&(l=d(s,"offset","batchNorm")),g(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),g(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),g(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&g(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),l!=null&&g(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${l.rank}.`),Nn(o,i,u,l,c,a)}const Hc=b({batchNorm2d_:Lm});function Bm(e,t,n,s,r,a){const o=d(e,"x","batchNorm"),i=d(t,"mean","batchNorm"),u=d(n,"variance","batchNorm");let c;r!=null&&(c=d(r,"scale","batchNorm"));let l;return s!=null&&(l=d(s,"offset","batchNorm")),g(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),g(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),g(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&g(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),l!=null&&g(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${l.rank}.`),Nn(o,i,u,l,c,a)}const Kc=b({batchNorm3d_:Bm});function Pm(e,t,n,s,r,a){const o=d(e,"x","batchNorm"),i=d(t,"mean","batchNorm"),u=d(n,"variance","batchNorm");let c;r!=null&&(c=d(r,"scale","batchNorm"));let l;return s!=null&&(l=d(s,"offset","batchNorm")),g(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),g(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),g(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&g(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),l!=null&&g(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${l.rank}.`),Nn(o,i,u,l,c,a)}const Xc=b({batchNorm4d_:Pm});function zm(e,t,n){const s=d(e,"x","bincount"),r=d(t,"weights","bincount");g(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),g(n>=0,()=>`size must be non-negative, but got ${n}.`),g(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const a={x:s,weights:r},o={size:n};return w.runKernel(xo,a,o)}const br=b({bincount_:zm});function Vm(e,t){const n=d(e,"x","bitwiseAnd"),s=d(t,"y","bitwiseAnd");if(!Rt(n.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${s.shape}`);if(n.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${s.dtype}`);const r={a:n,b:s};return w.runKernel(Oo,r)}const Zc=b({bitwiseAnd_:Vm});function Wm(e,t){const n=d(e,"s0","broadcastArgs","int32"),s=d(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:n,s1:s};return w.runKernel(Do,r)}const Jc=b({broadcastArgs_:Wm});function Mm(e,t){let n=d(e,"broadcastTo","x");const s=n.shape;if(Et(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const c=n.shape.slice();for(;c.length<t.length;)c.unshift(1);n=_(n,c)}const r=n.shape,a=Array.from(t);for(let c=t.length-1;c>=0;c--)if(r[c]===t[c])a[c]=1;else if(n.shape[c]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);if(a.map((c,l)=>c>1?l:-1).filter(c=>c>=0).length===0)return Gt(n);const i={x:n},u={reps:a};return w.runKernel(or,i,u)}const Ye=b({broadcastTo_:Mm});function Um(e){const n={x:d(e,"x","ceil","float32")};return w.runKernel(Co,n)}const Yc=b({ceil_:Um});function je(e,t,n){Et(e),n=n||mn(t);const s={shape:e,value:t,dtype:n};return w.runKernel(li,{},s)}function jm(e,t,n){const s=d(e,"x","clipByValue");if(g(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return je(s.shape,t,s.dtype);const r={x:s},a={clipValueMin:t,clipValueMax:n};return w.runKernel(Ro,r,a)}const Qc=b({clipByValue_:jm});function qm(e){return ht(e,0)}const tl=b({concat1d_:qm});function Gm(e,t){return ht(e,t)}const el=b({concat2d_:Gm});function Hm(e,t){return ht(e,t)}const nl=b({concat3d_:Hm});function Km(e,t){return ht(e,t)}const sl=b({concat4d_:Km});function Xm(e,t,n,s,r="NHWC",a=[1,1],o){const i=d(e,"x","conv2d","float32"),u=d(t,"filter","conv2d","float32");let c=i,l=!1;i.rank===3&&(l=!0,c=_(i,[1,i.shape[0],i.shape[1],i.shape[2]])),g(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),g(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),At("conv2d",s,o);const h=r==="NHWC"?c.shape[3]:c.shape[1];g(h===u.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${u.shape[2]}.`),g(Xt(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),g($e(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),g($e(n),()=>"Error in conv2D: Strides should be larger than 0.");const f={x:c,filter:u},m={strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:o},S=w.runKernel(Po,f,m);return l?_(S,[S.shape[1],S.shape[2],S.shape[3]]):S}const Sn=b({conv2d_:Xm});function Zm(e,t,n,s,r="NWC",a=1,o){const i=d(e,"x","conv1d"),u=d(t,"filter","conv1d");let c=i,l=!1;i.rank===2&&(l=!0,c=_(i,[1,i.shape[0],i.shape[1]])),g(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),g(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),At("conv1d",s,o),g(c.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${u.shape[1]}.`),g(Xt(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),g($e(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),g($e(n),()=>"Error in conv1D: Stride should be larger than 0."),g(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const h=_(u,[1,u.shape[0],u.shape[1],u.shape[2]]),f=_(c,[c.shape[0],1,c.shape[1],c.shape[2]]),N=Sn(f,h,[1,n],s,"NHWC",[1,a],o);return l?_(N,[N.shape[2],N.shape[3]]):_(N,[N.shape[0],N.shape[2],N.shape[3]])}const rl=b({conv1d_:Zm});function Jm(e,t,n,s,r,a="NHWC",o){g(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let i=e,u=t,c=!1;t.rank===3&&(c=!0,u=_(t,[1,t.shape[0],t.shape[1],t.shape[2]]),i=[1,e[0],e[1],e[2]]),g(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),g(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),g(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const l=a==="NHWC"?i[3]:i[1],h=a==="NHWC"?u.shape[3]:u.shape[1];g(l===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[2]}.`),g(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),At("conv2dDerInput",r,o);const f={dy:u,filter:n},m={strides:s,pad:r,dataFormat:a,dimRoundingMode:o,inputShape:i},S=w.runKernel(Vo,f,m);return c?_(S,[S.shape[1],S.shape[2],S.shape[3]]):S}const al=b({conv2DBackpropInput_:Jm});function Ym(e,t,n,s,r,a){const o=d(e,"x","conv2dTranspose"),i=d(t,"filter","conv2dTranspose");return al(n,o,i,s,r,"NHWC",a)}const ol=b({conv2dTranspose_:Ym});function Qm(e,t,n,s,r="NDHWC",a=[1,1,1]){const o=d(e,"x","conv3d"),i=d(t,"filter","conv3d");let u=o,c=!1;o.rank===4&&(c=!0,u=_(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),g(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),g(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),g(u.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${i.shape[3]}.`),g(Xt(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),g(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),g($e(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),g($e(n),()=>"Error in conv3D: Strides should be larger than 0.");const l={x:u,filter:i},h={strides:n,pad:s,dataFormat:r,dilations:a},f=w.runKernel(Wo,l,h);return c?_(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const il=b({conv3d_:Qm});function tg(e,t,n,s,r){g(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e,o=t,i=!1;t.rank===4&&(i=!0,o=_(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);const u=a[4],c=o.shape[4];g(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),g(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),g(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),g(u===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`),g(c===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[4]}.`);const l={dy:o,filter:n},h={pad:r,strides:s,inputShape:a},f=w.runKernel(Mo,l,h);return i?_(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const eg=b({conv3DBackpropInput_:tg});function ng(e,t,n,s,r){const a=d(e,"x","conv3dTranspose"),o=d(t,"filter","conv3dTranspose");return eg(n,a,o,s,r)}const ul=b({conv3dTranspose_:ng});function sg(e){const n={x:d(e,"x","cos","float32")};return w.runKernel(Uo,n)}const cl=b({cos_:sg});function rg(e){const n={x:d(e,"x","cosh","float32")};return w.runKernel(jo,n)}const ll=b({cosh_:rg});function ag(e,t=0,n=!1,s=!1){const a={x:d(e,"x","cumprod")},o={axis:t,exclusive:n,reverse:s};return w.runKernel(qo,a,o)}const hl=b({cumprod_:ag});function og(e,t=0,n=!1,s=!1){const a={x:d(e,"x","cumsum")},o={axis:t,exclusive:n,reverse:s};return w.runKernel(Go,a,o)}const pl=b({cumsum_:og});function ig(e,t,n,s=!1){const r=d(e,"x","denseBincount"),a=d(t,"weights","denseBincount");g(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),g(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),g(n>=0,()=>`size must be non-negative, but got ${n}.`),g(a.size===r.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${a.shape}.`);const o={x:r,weights:a},i={size:n,binaryOutput:s};return w.runKernel(Ko,o,i)}const fl=b({denseBincount_:ig});function ug(e,t,n="NHWC"){const s=d(e,"x","depthToSpace","float32"),r=n==="NHWC"?s.shape[1]:s.shape[2],a=n==="NHWC"?s.shape[2]:s.shape[3],o=n==="NHWC"?s.shape[3]:s.shape[1];g(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),g(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${t}  for depthToSpace with input shape
    ${s.shape}`),g(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${t} for depthToSpace with input shape
        ${s.shape}`),g(o%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${s.shape}`);const i={x:s},u={blockSize:t,dataFormat:n};return w.runKernel(Xo,i,u)}const dl=b({depthToSpace_:ug});function cg(e,t,n,s,r="NHWC",a=[1,1],o){const i=d(e,"x","depthwiseConv2d","float32"),u=d(t,"filter","depthwiseConv2d","float32");let c=i,l=!1;i.rank===3&&(l=!0,c=_(i,[1,i.shape[0],i.shape[1],i.shape[2]])),g(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),g(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const h=r==="NHWC"?c.shape[3]:c.shape[1];g(h===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${u.shape[2]}.`),At("depthwiseConv2d",s,o);const f={x:c,filter:u},m={strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:o},S=w.runKernel(Zo,f,m);return l?_(S,[S.shape[1],S.shape[2],S.shape[3]]):S}const Yn=b({depthwiseConv2d_:cg});function lg(e){const n={x:d(e,"x","diag")};return w.runKernel(Qo,n)}const ml=b({diag_:lg});function hg(e,t,n,s,r=[1,1],a="NHWC"){const o=d(e,"x","dilation2d"),i=d(t,"filter","dilation2d");g(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),g(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),g(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let u=o,c=!1;o.rank===3&&(u=_(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0),g(u.shape[3]===i.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${i.shape[2]}`);const l={x:u,filter:i},h={strides:n,pad:s,dilations:r},f=w.runKernel(ti,l,h);return c?_(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const gl=b({dilation2d_:hg});function yl(e,t){const n=e.length,s=[];for(let r=0;r<n;r++){const a=n-1-r,o=e[a]||1;(t[t.length-1-r]||1)>1&&o===1&&s.unshift(a)}return s}function wr(e,t){const n=[];for(let s=0;s<t.length;s++){const r=e[e.length-s-1],a=t.length-s-1,o=t[a];(r==null||r===1&&o>1)&&n.unshift(a)}return n}function rt(e,t){const n=Math.max(e.length,t.length),s=new Array(n);for(let r=0;r<n;r++){let a=e[e.length-r-1];a==null&&(a=1);let o=t[t.length-r-1];if(o==null&&(o=1),a===1)s[n-r-1]=o;else if(o===1)s[n-r-1]=a;else if(a!==o){const i=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(i)}else s[n-r-1]=a}return s}const pg=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:rt,getBroadcastDims:yl,getReductionAxes:wr},Symbol.toStringTag,{value:"Module"}));function fg(e,t){let n=d(e,"a","equal","string_or_numeric"),s=d(t,"b","equal","string_or_numeric");[n,s]=tt(n,s),rt(n.shape,s.shape);const r={a:n,b:s};return w.runKernel(ai,r)}const Nr=b({equal_:fg});function dg(e,t,n){const s=d(t,"a","where"),r=d(n,"b","where"),a=d(e,"condition","where","bool"),o=rt(rt(a.shape,s.shape),r.shape),i=Ye(a,o),u=Ye(s,o),c=Ye(r,o),l={condition:i,t:u,e:c};return w.runKernel(Su,l)}const Ht=b({where_:dg});function mg(e){const n={x:d(e,"x","zerosLike")};return w.runKernel(Qu,n)}const Tt=b({zerosLike_:mg});function gg(e,t){let n=d(e,"a","div"),s=d(t,"b","div");[n,s]=tt(n,s);const r=X(n,s),a=Tt(r),o=Nr(s,a);return Ht(o,a,r)}const bl=b({divNoNan_:gg});function yg(e,t){const n=d(e,"t1","dot"),s=d(t,"t2","dot");g((n.rank===1||n.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${s.rank}.`);const r=n.rank===1?n.size:n.shape[1],a=s.rank===1?s.size:s.shape[0];if(g(r===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${a}.`),n.rank===1&&s.rank===1){const o=_(n,[1,-1]),i=_(s,[-1,1]),u=U(o,i);return _(u,[])}else if(n.rank===1&&s.rank===2){const o=_(n,[1,-1]),i=_(s,[s.shape[0],s.shape[1]]),u=U(o,i);return _(u,[u.size])}else if(n.rank===2&&s.rank===1){const o=_(s,[-1,1]),i=U(n,o);return _(i,[i.size])}else{const o=_(s,[s.shape[0],s.shape[1]]);return U(n,o)}}const wl=b({dot_:yg});function bg(e,...t){const n=t.map((r,a)=>d(r,`tensors${a}`,"einsum")),s={equation:e};return w.runKernel(ni,n,s)}const me=b({einsum_:bg});function wg(e){const n={x:d(e,"x","elu","float32")};return w.runKernel(si,n)}const Sr=b({elu_:wg});function Ng(e,t){const n=d(e,"x","ensureShape","string_or_numeric");if(!eo(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}const Nl=b({ensureShape_:Ng});function Sg(e){let t=d(e,"x","erf");g(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Z(t,"float32"));const n={x:t};return w.runKernel(ri,n)}const Sl=b({erf_:Sg});function Tr(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Tl(e,t,n){const s=e.length+t.length,r=[];let a=0,o=0;for(let i=0;i<s;i++)n.indexOf(i)===-1?r.push(e[a++]):r.push(t[o++]);return r}function Tg(e,t){const n=[],s=e.length;for(let a=0;a<s;a++)t.indexOf(a)===-1&&n.push(e[a]);const r=t.map(a=>e[a]);return[n,r]}function Tn(e,t){const n=t.map(s=>1);return Tl(e,n,t)}function Eg(e,t,n){g(Tr(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function $g(e,t){if(Tr(e,t))return null;const n=[];for(let s=0;s<t;++s)e.indexOf(s)===-1&&n.push(s);return e.forEach(s=>n.push(s)),n}function vg(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function kg(e,t){const n=[];for(let s=t-e;s<t;++s)n.push(s);return n}function _g(e,t=null,n=!1){const r={x:d(e,"x","max")},a={reductionIndices:t,keepDims:n};return w.runKernel(Ri,r,a)}const Ne=b({max_:_g});function Ig(e,t=null,n=!1){const r={x:d(e,"x","min")},a={axis:t,keepDims:n};return w.runKernel(Vi,r,a)}const Un=b({min_:Ig});function Ag(e,t){let n=d(e,"base","pow"),s=d(t,"exp","pow");[n,s]=tt(n,s);const r={a:n,b:s};return w.runKernel(eu,r)}const Pe=b({pow_:Ag});function M(e,t){if((it(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&it(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ce(e,[],[],t)}function xg(e){const n={x:d(e,"x","sqrt","float32")};return w.runKernel(Au,n)}const zt=b({sqrt_:xg});function Og(e){const t=d(e,"x","square"),n={};return w.runKernel("Square",{x:t},n)}const It=b({square_:Og});function Dg(e,t=null,n=!1){let s=d(e,"x","sum");s.dtype==="bool"&&(s=Z(s,"int32"));const r={x:s},a={axis:t,keepDims:n};return w.runKernel(xu,r,a)}const K=b({sum_:Dg});function Cg(e,t="euclidean",n=null,s=!1){e=d(e,"x","norm");const r=El(e,t,n);let a=r.shape;if(s){const o=dn(n,e.shape);a=Tn(r.shape,o)}return _(r,a)}function El(e,t,n=null){if(e.rank===0)return St(e);if(e.rank!==1&&n===null)return El(_(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return K(St(e),n);if(t===1/0)return Ne(St(e),n);if(t===-1/0)return Un(St(e),n);if(t==="euclidean"||t===2)return zt(K(Pe(St(e),M(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return Ne(K(St(e),n[0]),n[1]-1);if(t===1/0)return Ne(K(St(e),n[1]),n[0]);if(t===-1/0)return Un(K(St(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return zt(K(It(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const En=b({norm_:Cg});function Rg(e,t=null,n=!1){return En(e,"euclidean",t,n)}const $l=b({euclideanNorm_:Rg});function Fg(e){const n={x:d(e,"x","exp")};return w.runKernel(oi,n)}const ie=b({exp_:Fg});function Lg(e,t=0){const n=d(e,"x","expandDims","string_or_numeric");g(t<=n.rank,()=>"Axis must be <= rank of the tensor");const s={input:n},r={dim:t};return w.runKernel(ii,s,r)}const Mt=b({expandDims_:Lg});function Bg(e){const n={x:d(e,"x","expm1")};return w.runKernel(ui,n)}const vl=b({expm1_:Bg});function Pg(e,t){const n=d(e,"x","tile","string_or_numeric");g(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);const s={x:n},r={reps:t};return w.runKernel(or,s,r)}const Ce=b({tile_:Pg});function zg(e,t,n,s="float32"){t==null&&(t=e);const r=Pt([e,t],s),a=e<=t?e:t;for(let i=0;i<a;++i)r.set(1,i,i);const o=_(r.toTensor(),[e,t]);if(n==null)return o;if(n.length===1)return Ce(Mt(o,0),[n[0],1,1]);if(n.length===2)return Ce(Mt(Mt(o,0),0),[n[0],n[1],1,1]);if(n.length===3)return Ce(Mt(Mt(Mt(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const Er=b({eye_:zg});function Vg(e){const n={x:d(e,"x","floor","float32")};return w.runKernel(pi,n)}const $r=b({floor_:Vg});function Wg(e,t,n=0,s=0){const r=d(e,"x","gather"),a=d(t,"indices","gather","int32"),o={x:r,indices:a},i={axis:n,batchDims:s};return w.runKernel(mi,o,i)}const vr=b({gather_:Wg});function Mg(e,t){let n=d(e,"a","greater","string_or_numeric"),s=d(t,"b","greater","string_or_numeric");[n,s]=tt(n,s),rt(n.shape,s.shape);const r={a:n,b:s};return w.runKernel(yi,r)}const $n=b({greater_:Mg});function Ug(e,t){let n=d(e,"a","greaterEqual","string_or_numeric"),s=d(t,"b","greaterEqual","string_or_numeric");[n,s]=tt(n,s),rt(n.shape,s.shape);const r={a:n,b:s};return w.runKernel(bi,r)}const kr=b({greaterEqual_:Ug});function jg(e){const n={input:d(e,"input","imag")};return w.runKernel(Ni,n)}const vn=b({imag_:jg});function qg(e){const n={x:d(e,"x","isFinite")};return w.runKernel(Si,n)}const kl=b({isFinite_:qg});function Gg(e){const n={x:d(e,"x","isInf")};return w.runKernel(Ti,n)}const _l=b({isInf_:Gg});function Hg(e){const n={x:d(e,"x","isNaN")};return w.runKernel(Ei,n)}const Il=b({isNaN_:Hg});function Kg(e,t=.2){const s={x:d(e,"x","leakyRelu")},r={alpha:t};return w.runKernel($i,s,r)}const _r=b({leakyRelu_:Kg});function Xg(e,t){let n=d(e,"a","less","string_or_numeric"),s=d(t,"b","less","string_or_numeric");[n,s]=tt(n,s),rt(n.shape,s.shape);const r={a:n,b:s};return w.runKernel(vi,r)}const jn=b({less_:Xg});function Zg(e,t){let n=d(e,"a","lessEqual","string_or_numeric"),s=d(t,"b","lessEqual","string_or_numeric");[n,s]=tt(n,s),rt(n.shape,s.shape);const r={a:n,b:s};return w.runKernel(ki,r)}const Qn=b({lessEqual_:Zg});function Al(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const s={start:e,stop:t,num:n};return w.runKernel(_i,{},s)}function Jg(e,t=5,n=1,s=1,r=.5){const a=d(e,"x","localResponseNormalization");g(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),g(Fe(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=a,i=!1;a.rank===3&&(i=!0,o=_(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const u={x:o},c={depthRadius:t,bias:n,alpha:s,beta:r},l=w.runKernel(Ci,u,c);return i?_(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const xl=b({localResponseNormalization_:Jg});function Yg(e){const n={x:d(e,"x","log","float32")};return w.runKernel(Ii,n)}const ze=b({log_:Yg});function Qg(e){const n={x:d(e,"x","log1p")};return w.runKernel(Ai,n)}const Ir=b({log1p_:Qg});function ty(e){return g(se(e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{const s=d(t,"x","tf.grad","string_or_numeric"),r=n!=null?d(n,"dy","tf.grad"):null;return w.tidy(()=>{const{value:a,grads:o}=w.gradients(()=>e(s),[s],r);return r!=null&&gt(a.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),ts(o),o[0]})}}function ey(e){return g(se(e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{g(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const s=rn(t,"args","tf.grads","string_or_numeric"),r=n!=null?d(n,"dy","tf.grads"):null;return w.tidy(()=>{const{value:a,grads:o}=w.gradients(()=>e(...s),s,r);return r!=null&&gt(a.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),ts(o),o})}}function ny(e){return g(se(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{g(t instanceof nt,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),g(n==null||n instanceof nt,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:s,value:r}=w.gradients(()=>e(t),[t],n);return ts(s),{grad:s[0],value:r}}}function sy(e){return g(se(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{g(Array.isArray(t)&&t.every(r=>r instanceof nt),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),g(n==null||n instanceof nt,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const s=w.gradients(()=>e(...t),t,n);return n!=null&&gt(s.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),ts(s.grads),s}}function Ol(e,t){g(se(e),()=>"The f passed in variableGrads(f) must be a function"),g(t==null||Array.isArray(t)&&t.every(c=>c instanceof sn),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=t!=null;if(!n){t=[];for(const c in w.registeredVariables)t.push(w.registeredVariables[c])}const s=n?t.filter(c=>!c.trainable):null,r=t.length;t=t.filter(c=>c.trainable),g(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const a=!0,{value:o,grads:i}=w.gradients(e,t,null,a);g(i.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),g(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const u={};return t.forEach((c,l)=>{i[l]!=null&&(u[c.name]=i[l])}),s?.forEach(c=>u[c.name]=null),{value:o,grads:u}}function Vt(e){return w.customGrad(e)}function ts(e){if(e.filter(n=>n==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function ry(e){const n={x:d(e,"x","neg")};return w.runKernel(Gi,n)}const Ct=b({neg_:ry});function ay(e){const n={x:d(e,"x","softplus")};return w.runKernel(Iu,n)}const Ar=b({softplus_:ay});function oy(e){const t=d(e,"x","logSigmoid");return Vt(s=>({value:Ct(Ar(Ct(s))),gradFunc:o=>C(o,we(Ct(s)))}))(t)}const Dl=b({logSigmoid_:oy});function iy(e,t){let n=d(e,"a","sub"),s=d(t,"b","sub");[n,s]=tt(n,s);const r={a:n,b:s};return w.runKernel(qu,r)}const W=b({sub_:iy});function uy(e,t=-1){const n=d(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return Vt((r,a)=>{const i=Ne(r,t,!0),u=W(r,i),c=W(Z(u,"float32"),ze(K(ie(u),t,!0)));return a([c]),{value:c,gradFunc:(h,f)=>{const[m]=f,S=!0,T=ie(m);return W(h,C(K(h,t,S),T))}}})(n)}const Cl=b({logSoftmax_:uy});function cy(e,t=null,n=!1){const s=d(e,"x","logSumExp"),r=dn(t,s.shape),a=Ne(s,r,!0),o=W(s,a),i=ie(o),u=K(i,r),c=ze(u),l=B(_(a,c.shape),c);if(n){const h=Tn(l.shape,r);return _(l,h)}return l}const xr=b({logSumExp_:cy});function ly(e,t){const n=d(e,"a","logicalAnd","bool"),s=d(t,"b","logicalAnd","bool");rt(n.shape,s.shape);const r={a:n,b:s};return w.runKernel(xi,r)}const cn=b({logicalAnd_:ly});function hy(e){const n={x:d(e,"x","logicalNot","bool")};return w.runKernel(Oi,n)}const Or=b({logicalNot_:hy});function py(e,t){const n=d(e,"a","logicalOr","bool"),s=d(t,"b","logicalOr","bool");rt(n.shape,s.shape);const r={a:n,b:s};return w.runKernel(Di,r)}const Dr=b({logicalOr_:py});function fy(e,t){const n=d(e,"a","logicalXor","bool"),s=d(t,"b","logicalXor","bool");return rt(n.shape,s.shape),cn(Dr(e,t),Or(cn(e,t)))}const Rl=b({logicalXor_:fy});const An=2147483648;function dy(e,t,n="left"){const s=d(e,"sortedSequence","searchSorted"),r=d(t,"values","searchSorted"),a=s.shape[s.shape.length-1],o=r.shape[r.shape.length-1],i=_(s,[-1,a]),u=_(r,[-1,o]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(q(u.shape)>=An)throw new Error(`values tensor size must less than ${An}`);if(i.shape[1]>=An)throw new Error(`trailing dim_size must less than ${An} for int32 output type, was ${i.shape[1]}`);const c={sortedSequence:i,values:u},l={side:n};return w.runKernel(Nu,c,l)}const es=b({searchSorted_:dy});function Fl(e,t){return es(e,t,"left")}function my(e,t,n,s,r){const a=d(e,"x","maxPool"),o=1;let i=a,u=!1;a.rank===3&&(u=!0,i=_(a,[1,a.shape[0],a.shape[1],a.shape[2]])),g(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),g(Xt(n,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),At("maxPool",s,r);const c={x:i},l={filterSize:t,strides:n,pad:s,dimRoundingMode:r},h=w.runKernel(Li,c,l);return u?_(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Cr=b({maxPool_:my});function gy(e,t=[1,1,1],n,s,r,a="NDHWC"){const o=d(e,"x","maxPool3d");let i=o,u=!1;o.rank===4&&(u=!0,i=_(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),g(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),g(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),At("maxPool3d",s,r);const c={x:i},l={filterSize:t,strides:n,pad:s,dimRoundingMode:r,dataFormat:a},h=w.runKernel(Bi,c,l);return u?_(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const Ll=b({maxPool3d_:gy});function yy(e,t,n,s,r=!1){const o={x:d(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:s,includeBatchInIndex:r},u=w.runKernel(Pi,o,i);return{result:u[0],indexes:u[1]}}const Bl=b({maxPoolWithArgmax_:yy});function by(e,t){let n=d(e,"a","maximum"),s=d(t,"b","maximum");[n,s]=tt(n,s),n.dtype==="bool"&&(n=Z(n,"int32"),s=Z(s,"int32")),rt(n.shape,s.shape);const r={a:n,b:s};return w.runKernel(Fi,r)}const Rr=b({maximum_:by});function wy(e,t=null,n=!1){const r={x:d(e,"x","mean")},a={axis:t,keepDims:n};return w.runKernel(zi,r,a)}const ln=b({mean_:wy});function ve(e,t="float32"){if(Et(e),t==="complex64"){const s=ve(e,"float32"),r=ve(e,"float32");return Kt(s,r)}const n=Xn(q(e),t);return w.makeTensor(n,e,t)}function ee(e,t="float32"){if(Et(e),t==="complex64"){const s=ee(e,"float32"),r=ve(e,"float32");return Kt(s,r)}const n=Qs(q(e),t);return w.makeTensor(n,e,t)}function Pl(e,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let s=d(e,"x","meshgrid",e instanceof nt?e.dtype:"float32");if(t===void 0)return[s];let r=d(t,"y","meshgrid",t instanceof nt?t.dtype:"float32");const a=q(s.shape),o=q(r.shape);return n==="xy"?(s=_(s,[1,-1]),r=_(r,[-1,1]),[U(ee([o,1],s.dtype),s),U(r,ee([1,a],r.dtype))]):(s=_(s,[-1,1]),r=_(r,[1,-1]),[U(s,ee([1,o],s.dtype)),U(ee([a,1],r.dtype),r)])}function Ny(e,t){let n=d(e,"a","minimum"),s=d(t,"b","minimum");[n,s]=tt(n,s),n.dtype==="bool"&&(n=Z(n,"int32"),s=Z(s,"int32")),rt(n.shape,s.shape);const r={a:n,b:s};return w.runKernel(Wi,r)}const hn=b({minimum_:Ny});function Sy(e,t,n){g(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const s=d(e,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");g(t.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`);const r=n==="reflect"?1:0;for(let i=0;i<s.rank;i++)g(t[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),g(t[i][0]>=0&&t[i][0]<=s.shape[i]-r&&t[i][1]>=0&&t[i][1]<=s.shape[i]-r,()=>`Padding in dimension ${i} cannot be greater than or equal to ${s.shape[i]-r} or less than 0 for input of shape ${s.shape}`);const a={paddings:t,mode:n},o={x:s};return w.runKernel(Mi,o,a)}const zl=b({mirrorPad_:Sy});function Ty(e,t){let n=d(e,"a","mod"),s=d(t,"b","mod");[n,s]=tt(n,s);const r={a:n,b:s};return w.runKernel(Ui,r)}const Vl=b({mod_:Ty});function Ey(e,t=null,n=!1){e=d(e,"x","moments");const s=dn(t,e.shape),r=ln(e,s,n);let a=r.shape;n||(a=Tn(r.shape,s));const o=It(W(Z(e,"float32"),_(r,a))),i=ln(o,s,n);return{mean:r,variance:i}}const Wl=b({moments_:Ey});function $y(e,t,n,s){const r=d(t,"data","multiRNNCell"),a=rn(n,"c","multiRNNCell"),o=rn(s,"h","multiRNNCell");let i=r;const u=[];for(let h=0;h<e.length;h++){const f=e[h](i,a[h],o[h]);u.push(f[0]),u.push(f[1]),i=f[1]}const c=[],l=[];for(let h=0;h<u.length;h+=2)c.push(u[h]),l.push(u[h+1]);return[c,l]}const Ml=b({multiRNNCell_:$y});function vy(e,t,n,s=!1){const r=d(e,"logits","multinomial"),a=r.size,o=r.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);n=n||Math.random();const u={logits:o===1?_(r,[1,-1]):r},c={numSamples:t,seed:n,normalized:s},l=w.runKernel(ji,u,c);return o===1?_(l,[l.size]):l}const Ul=b({multinomial_:vy});function ky(e,t){let n=d(e,"a","notEqual","string_or_numeric"),s=d(t,"b","notEqual","string_or_numeric");[n,s]=tt(n,s),rt(n.shape,s.shape);const r={a:n,b:s};return w.runKernel(Hi,r)}const Fr=b({notEqual_:ky});function _y(e,t,n=1,s=0,r="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const o={indices:d(e,"indices","oneHot","int32")},i={dtype:r,depth:t,onValue:n,offValue:s};return w.runKernel(Yi,o,i)}const qn=b({oneHot_:_y});function Iy(e){const n={x:d(e,"x","onesLike")};return w.runKernel(Ji,n)}const jl=b({onesLike_:Iy});function Ay(e,t){const n=d(e,"v1","outerProduct"),s=d(t,"v2","outerProduct");g(n.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${s.rank}.`);const r=_(n,[-1,1]),a=_(s,[1,-1]);return U(r,a)}const ql=b({outerProduct_:Ay});function xy(e,t,n=0){const s=d(e,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:t,constantValue:n},a={x:s};return w.runKernel(tu,a,r)}const qe=b({pad_:xy});function Oy(e,t,n=0){return g(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),qe(e,[t],n)}const Gl=b({pad1d_:Oy});function Dy(e,t,n=0){return g(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),qe(e,t,n)}const Hl=b({pad2d_:Dy});function Cy(e,t,n=0){return g(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),qe(e,t,n)}const Kl=b({pad3d_:Cy});function Ry(e,t,n=0){return g(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),qe(e,t,n)}const Xl=b({pad4d_:Ry});function Fy(e,t,n){const s=d(e,"x","spaceToBatchND");g(s.rank>=1+t.length,()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`),g(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),g(s.shape.reduce((o,i,u)=>u>0&&u<=t.length?o&&(i+n[u-1][0]+n[u-1][1])%t[u-1]===0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);const r={x:s},a={blockShape:t,paddings:n};return w.runKernel(Ou,r,a)}const Lr=b({spaceToBatchND_:Fy});function Ly(e,t,n,s,r,a,o){r==null&&(r=[1,1]),a==null&&(a=1),s===0&&(s="valid");const i=d(e,"x","maxPool");let u=i,c=!1;i.rank===3&&(c=!0,u=_(i,[1,i.shape[0],i.shape[1],i.shape[2]])),g(Xt(a,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${r}'`);const l=Mc(u.shape,t,a,r,s),h=[l.dilationHeight,l.dilationWidth];let f;s==="same"?f=Py([l.filterHeight,l.filterWidth],h):f=[[0,0],[0,0]];const m=h[0]===1&&h[1]===1,[S,T]=By([l.inHeight,l.inWidth],h,f),N=m?s:"valid",E=m?u:Lr(u,h,S),$=(n==="avg"?()=>gr(E,t,a,N,o):()=>Cr(E,t,a,N,o))(),I=m?$:yr($,h,T);return c?_(I,[I.shape[1],I.shape[2],I.shape[3]]):I}function By(e,t,n){const s=n.map(l=>l[0]),r=n.map(l=>l[1]),a=e.concat(s,r),o=t.map((l,h)=>(l-a[h]%l)%l),i=r.map((l,h)=>l+o[h]),u=t.map((l,h)=>[s[h],i[h]]),c=t.map((l,h)=>[0,o[h]]);return[u,c]}function Py(e,t){const s=e.map((o,i)=>o+(o-1)*(t[i]-1)).map(o=>o-1),r=s.map(o=>Math.floor(o/2)),a=s.map((o,i)=>o-r[i]);return s.map((o,i)=>[r[i],a[i]])}const Zl=b({pool_:Ly});function zy(e,t){const n=d(e,"x","prelu"),s=d(t,"alpha","prelu"),r={x:n,alpha:s};return w.runKernel(nu,r)}const Br=b({prelu_:zy});function Vy(e,t=null,n=!1){let s=d(e,"x","prod");s.dtype==="bool"&&(s=Z(s,"int32"));const r={x:s},a={axis:t,keepDims:n};return w.runKernel(su,r,a)}const Jl=b({prod_:Vy});function Wy(e,t,n,s){const r=e.map((l,h)=>d(l,`tensors${h}`,"raggedGather","int32")),a=d(t,"paramsDenseValues","raggedGather"),o=d(n,"indices","raggedGather","int32"),i={paramsNestedSplits:r,paramsDenseValues:a,indices:o},u={outputRaggedRank:s},c=w.runKernel(ru,i,u);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}const Yl=b({raggedGather_:Wy});function My(e,t,n){const s=d(e,"starts","raggedRange"),r=d(t,"limits","raggedRange",s.dtype),a=d(n,"deltas","raggedRange",s.dtype),o={starts:s,limits:r,deltas:a},i=w.runKernel(au,o);return{rtNestedSplits:i[0],rtDenseValues:i[1]}}const Ql=b({raggedRange_:My});function Uy(e,t,n,s,r){const a=d(e,"shape","raggedTensorToTensor","int32"),o=d(t,"values","raggedTensorToTensor"),i=d(n,"defaultValue","raggedTensorToTensor",o.dtype),u=s.map((h,f)=>d(h,`tensors${f}`,"raggedTensorToTensor","int32")),c={shape:a,values:o,defaultValue:i,rowPartitionTensors:u},l={rowPartitionTypes:r};return w.runKernel(ou,c,l)}const th=b({raggedTensorToTensor_:Uy});function jy(e,t,n){Et(e);const s=q(e);let r=null;if(n==null||n==="float32")r=new Float32Array(s);else if(n==="int32")r=new Int32Array(s);else if(n==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${n}`);for(let a=0;a<s;a++)r[a]=t();return w.makeTensor(r,e,n)}const eh=b({rand_:jy});var Sa={},Ta={},Ea;function qy(){return Ea||(Ea=1,function(e,t,n){function s(i){var u=this,c=o();u.next=function(){var l=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=l-(u.c=l|0)},u.c=1,u.s0=c(" "),u.s1=c(" "),u.s2=c(" "),u.s0-=c(i),u.s0<0&&(u.s0+=1),u.s1-=c(i),u.s1<0&&(u.s1+=1),u.s2-=c(i),u.s2<0&&(u.s2+=1),c=null}function r(i,u){return u.c=i.c,u.s0=i.s0,u.s1=i.s1,u.s2=i.s2,u}function a(i,u){var c=new s(i),l=u&&u.state,h=c.next;return h.int32=function(){return c.next()*4294967296|0},h.double=function(){return h()+(h()*2097152|0)*11102230246251565e-32},h.quick=h,l&&(typeof l=="object"&&r(l,c),h.state=function(){return r(c,{})}),h}function o(){var i=4022871197,u=function(c){c=String(c);for(var l=0;l<c.length;l++){i+=c.charCodeAt(l);var h=.02519603282416938*i;i=h>>>0,h-=i,h*=i,i=h>>>0,h-=i,i+=h*4294967296}return(i>>>0)*23283064365386963e-26};return u}this.alea=a}()),Ta}var $a={},va;function Gy(){return va||(va=1,function(e,t,n){function s(o){var i=this,u="";i.x=0,i.y=0,i.z=0,i.w=0,i.next=function(){var l=i.x^i.x<<11;return i.x=i.y,i.y=i.z,i.z=i.w,i.w^=i.w>>>19^l^l>>>8},o===(o|0)?i.x=o:u+=o;for(var c=0;c<u.length+64;c++)i.x^=u.charCodeAt(c)|0,i.next()}function r(o,i){return i.x=o.x,i.y=o.y,i.z=o.z,i.w=o.w,i}function a(o,i){var u=new s(o),c=i&&i.state,l=function(){return(u.next()>>>0)/4294967296};return l.double=function(){do var h=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(h+f)/(1<<21);while(m===0);return m},l.int32=u.next,l.quick=l,c&&(typeof c=="object"&&r(c,u),l.state=function(){return r(u,{})}),l}this.xor128=a}()),$a}var ka={},_a;function Hy(){return _a||(_a=1,function(e,t,n){function s(o){var i=this,u="";i.next=function(){var l=i.x^i.x>>>2;return i.x=i.y,i.y=i.z,i.z=i.w,i.w=i.v,(i.d=i.d+362437|0)+(i.v=i.v^i.v<<4^(l^l<<1))|0},i.x=0,i.y=0,i.z=0,i.w=0,i.v=0,o===(o|0)?i.x=o:u+=o;for(var c=0;c<u.length+64;c++)i.x^=u.charCodeAt(c)|0,c==u.length&&(i.d=i.x<<10^i.x>>>4),i.next()}function r(o,i){return i.x=o.x,i.y=o.y,i.z=o.z,i.w=o.w,i.v=o.v,i.d=o.d,i}function a(o,i){var u=new s(o),c=i&&i.state,l=function(){return(u.next()>>>0)/4294967296};return l.double=function(){do var h=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(h+f)/(1<<21);while(m===0);return m},l.int32=u.next,l.quick=l,c&&(typeof c=="object"&&r(c,u),l.state=function(){return r(u,{})}),l}this.xorwow=a}()),ka}var Ia={},Aa;function Ky(){return Aa||(Aa=1,function(e,t,n){function s(o){var i=this;i.next=function(){var c=i.x,l=i.i,h,f;return h=c[l],h^=h>>>7,f=h^h<<24,h=c[l+1&7],f^=h^h>>>10,h=c[l+3&7],f^=h^h>>>3,h=c[l+4&7],f^=h^h<<7,h=c[l+7&7],h=h^h<<13,f^=h^h<<9,c[l]=f,i.i=l+1&7,f};function u(c,l){var h,f=[];if(l===(l|0))f[0]=l;else for(l=""+l,h=0;h<l.length;++h)f[h&7]=f[h&7]<<15^l.charCodeAt(h)+f[h+1&7]<<13;for(;f.length<8;)f.push(0);for(h=0;h<8&&f[h]===0;++h);for(h==8?f[7]=-1:f[h],c.x=f,c.i=0,h=256;h>0;--h)c.next()}u(i,o)}function r(o,i){return i.x=o.x.slice(),i.i=o.i,i}function a(o,i){o==null&&(o=+new Date);var u=new s(o),c=i&&i.state,l=function(){return(u.next()>>>0)/4294967296};return l.double=function(){do var h=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(h+f)/(1<<21);while(m===0);return m},l.int32=u.next,l.quick=l,c&&(c.x&&r(c,u),l.state=function(){return r(u,{})}),l}this.xorshift7=a}()),Ia}var xa={},Oa;function Xy(){return Oa||(Oa=1,function(e,t,n){function s(o){var i=this;i.next=function(){var c=i.w,l=i.X,h=i.i,f,m;return i.w=c=c+1640531527|0,m=l[h+34&127],f=l[h=h+1&127],m^=m<<13,f^=f<<17,m^=m>>>15,f^=f>>>12,m=l[h]=m^f,i.i=h,m+(c^c>>>16)|0};function u(c,l){var h,f,m,S,T,N=[],E=128;for(l===(l|0)?(f=l,l=null):(l=l+"\0",f=0,E=Math.max(E,l.length)),m=0,S=-32;S<E;++S)l&&(f^=l.charCodeAt((S+32)%l.length)),S===0&&(T=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,S>=0&&(T=T+1640531527|0,h=N[S&127]^=f+T,m=h==0?m+1:0);for(m>=128&&(N[(l&&l.length||0)&127]=-1),m=127,S=4*128;S>0;--S)f=N[m+34&127],h=N[m=m+1&127],f^=f<<13,h^=h<<17,f^=f>>>15,h^=h>>>12,N[m]=f^h;c.w=T,c.X=N,c.i=m}u(i,o)}function r(o,i){return i.i=o.i,i.w=o.w,i.X=o.X.slice(),i}function a(o,i){o==null&&(o=+new Date);var u=new s(o),c=i&&i.state,l=function(){return(u.next()>>>0)/4294967296};return l.double=function(){do var h=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(h+f)/(1<<21);while(m===0);return m},l.int32=u.next,l.quick=l,c&&(c.X&&r(c,u),l.state=function(){return r(u,{})}),l}this.xor4096=a}()),xa}var Da={},Ca;function Zy(){return Ca||(Ca=1,function(e,t,n){function s(o){var i=this,u="";i.next=function(){var l=i.b,h=i.c,f=i.d,m=i.a;return l=l<<25^l>>>7^h,h=h-f|0,f=f<<24^f>>>8^m,m=m-l|0,i.b=l=l<<20^l>>>12^h,i.c=h=h-f|0,i.d=f<<16^h>>>16^m,i.a=m-l|0},i.a=0,i.b=0,i.c=-1640531527,i.d=1367130551,o===Math.floor(o)?(i.a=o/4294967296|0,i.b=o|0):u+=o;for(var c=0;c<u.length+20;c++)i.b^=u.charCodeAt(c)|0,i.next()}function r(o,i){return i.a=o.a,i.b=o.b,i.c=o.c,i.d=o.d,i}function a(o,i){var u=new s(o),c=i&&i.state,l=function(){return(u.next()>>>0)/4294967296};return l.double=function(){do var h=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(h+f)/(1<<21);while(m===0);return m},l.int32=u.next,l.quick=l,c&&(typeof c=="object"&&r(c,u),l.state=function(){return r(u,{})}),l}this.tychei=a}()),Da}var ys={},Ra;function Jy(){return Ra||(Ra=1,function(e,t,n){var s=256,r=6,a=52,o="random",i=n.pow(s,r),u=n.pow(2,a),c=u*2,l=s-1,h;function f($,I,D){var x=[];I=I==!0?{entropy:!0}:I||{};var F=N(T(I.entropy?[$,O(t)]:$??E(),3),x),R=new m(x),k=function(){for(var v=R.g(r),y=i,A=0;v<u;)v=(v+A)*s,y*=s,A=R.g(1);for(;v>=c;)v/=2,y/=2,A>>>=1;return(v+A)/y};return k.int32=function(){return R.g(4)|0},k.quick=function(){return R.g(4)/4294967296},k.double=k,N(O(R.S),t),(I.pass||D||function(v,y,A,L){return L&&(L.S&&S(L,R),v.state=function(){return S(R,{})}),A?(n[o]=v,y):v})(k,F,"global"in I?I.global:this==n,I.state)}function m($){var I,D=$.length,x=this,F=0,R=x.i=x.j=0,k=x.S=[];for(D||($=[D++]);F<s;)k[F]=F++;for(F=0;F<s;F++)k[F]=k[R=l&R+$[F%D]+(I=k[F])],k[R]=I;(x.g=function(v){for(var y,A=0,L=x.i,V=x.j,z=x.S;v--;)y=z[L=l&L+1],A=A*s+z[l&(z[L]=z[V=l&V+y])+(z[V]=y)];return x.i=L,x.j=V,A})(s)}function S($,I){return I.i=$.i,I.j=$.j,I.S=$.S.slice(),I}function T($,I){var D=[],x=typeof $,F;if(I&&x=="object")for(F in $)try{D.push(T($[F],I-1))}catch{}return D.length?D:x=="string"?$:$+"\0"}function N($,I){for(var D=$+"",x,F=0;F<D.length;)I[l&F]=l&(x^=I[l&F]*19)+D.charCodeAt(F++);return O(I)}function E(){try{var $;return h&&($=h.randomBytes)||($=new Uint8Array(s),(e.crypto||e.msCrypto).getRandomValues($)),O($)}catch{var I=e.navigator,D=I&&I.plugins;return[+new Date,e,D,e.screen,O(t)]}}function O($){return String.fromCharCode.apply(0,$)}N(n.random(),t),n["seed"+o]=f}(typeof self<"u"?self:ys,[],Math)),ys}var Fa;function Yy(){if(Fa)return Sa;Fa=1;var e=qy(),t=Gy(),n=Hy(),s=Ky(),r=Xy(),a=Zy(),o=Jy();return o.alea=e,o.xor128=t,o.xorwow=n,o.xorshift7=s,o.xor4096=r,o.tychei=a,(void 0).exports=o,Sa}var Pr=Yy();const Qy=.001,nh=.1;function tb(e,t,n){return n==null&&(n=zr()),Bs(e,t,(s,r)=>Vr(s,r,n))}function zr(){return w.backend.floatPrecision()===32?Qy:nh}function Bs(e,t,n){let s=!0;if((it(e)||it(t))&&(s=!1),it(e)&&it(t)&&(s=!0),s){const o=e.constructor.name,i=t.constructor.name;if(o!==i)throw new Error(`Arrays are of different type. Actual: ${o}. Expected: ${i}`)}if(Array.isArray(e)&&Array.isArray(t)){const o=Bt(e),i=Bt(t);if(!Rt(o,i))throw new Error(`Arrays have different shapes. Actual: [${o}]. Expected: [${i}]`)}const r=it(e)?e:ae(e),a=it(t)?t:ae(t);if(r.length!==a.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${a.length}.
Actual:   ${r}.
Expected: ${a}.`);for(let o=0;o<a.length;++o){const i=r[o],u=a[o];if(!n(i,u))throw new Error(`Arrays differ: actual[${o}] = ${i}, expected[${o}] = ${u}.
Actual:   ${r}.
Expected: ${a}.`)}typeof expect<"u"&&expect().nothing()}function eb(e,t){e().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function nb(e,t){const n=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return Qt(e)||Qt(e[0])||Qt(t)||Qt(t[0])?Bs(e,n,(s,r)=>s==r):Bs(e,t,(s,r)=>Vr(s,r,0))}function sb(e,t,n){if(n==null&&(n=zr()),!Vr(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function Vr(e,t,n){return!isFinite(e)&&!isFinite(t)?!0:!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function rb(e,t,n){for(let s=0;s<e.length;s++)if(e[s]<t||e[s]>n)throw new Error(`Value out of range:${e[s]} low: ${t}, high: ${n}`)}function ab(e,t){const n=new Float32Array(e),s=new Float32Array(t);if(n.length!==s.length)throw new Error(`Expected ArrayBuffer to be of length ${s.length}, but it was ${n.length}`);for(let r=0;r<s.length;r++)if(n[r]!==s[r])throw new Error(`Expected ArrayBuffer value at ${r} to be ${s[r]} but got ${n[r]} instead`)}function sh(e){for(let t=0;t<e.length;t++){const n=e[t];Array.isArray(n)?sh(n):e[t]=yn(n)}return e}function ob(e){const t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(n=>{t.addEventListener("loadeddata",s=>n(t)),t.load()})}async function ib(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}const ub=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:nh,createVideoElement:ob,encodeStrings:sh,expectArrayBuffersEqual:ab,expectArraysClose:tb,expectArraysEqual:nb,expectNumbersClose:sb,expectPromiseToFail:eb,expectValuesInRange:rb,play:ib,testEpsilon:zr},Symbol.toStringTag,{value:"Module"}));class Wr{constructor(t,n,s,r,a){this.mean=t,this.stdDev=n,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=a||Math.random();this.random=Pr.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let t,n,s=!1;for(;!s;){let r,a,o;do r=2*this.random()-1,a=2*this.random()-1,o=r*r+a*a;while(o>=1||o===0);const i=Math.sqrt(-2*Math.log(o)/o);t=this.mean+this.stdDev*r*i,n=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(t))&&(s=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class cb{constructor(t,n,s,r){this.alpha=t,this.beta=1/n,this.dtype=s;const a=r||Math.random();this.randu=Pr.alea(a.toString()),this.randn=new Wr(0,1,s,!1,this.randu()),t<1?this.d=t+2/3:this.d=t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,n,s,r,a,o;for(;;){do r=this.randn.nextValue(),o=1+this.c*r;while(o<=0);if(o*=o*o,t=r*r,n=1-.331*t*t,s=.5*t+this.d*(1-o+Math.log(o)),a=this.randu(),a<n||Math.log(a)<s)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(t){return this.dtype==="float32"?t:Math.round(t)}}class lb{constructor(t=0,n=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=n-t,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${n} <= 1 and dtype is not float`);this.random=Pr.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function hb(e,t,n=1,s="float32",r){if(Et(e),n==null&&(n=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const a=new cb(t,n,s,r),o=Pt(e,s);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const rh=b({randomGamma_:hb});function pb(e,t=0,n=1,s,r){if(Et(e),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const a=new Wr(t,n,s,!1,r),o=Pt(e,s);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const Mr=b({randomNormal_:pb});function fb(e,t,n){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return Mr(e,0,1,t,n)}const ah=b({randomStandardNormal_:fb});function db(e,t=0,n=1,s="float32",r){Et(e);const a=Pt(e,s),o=new lb(t,n,null,r);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const ns=b({randomUniform_:db});function mb(e,t,n,s){return ns(e,t,n,"int32",s)}const oh=b({randomUniformInt_:mb});function Ve(e,t,n=1,s="float32"){if(n===0)throw new Error("Cannot have a step of zero");const r={start:e,stop:t,step:n,dtype:s};return w.runKernel(iu,{},r)}function gb(e){const n={input:d(e,"input","real")};return w.runKernel(uu,n)}const We=b({real_:gb});function yb(e){const n={x:d(e,"x","reciprocal")};return w.runKernel(cu,n)}const ih=b({reciprocal_:yb});function bb(e){const n={x:d(e,"x","relu")};return w.runKernel(lu,n)}const kn=b({relu_:bb});function wb(e){const n={x:d(e,"x","relu6")};return w.runKernel(du,n)}const Ur=b({relu6_:wb});function Nb(e,t){const s={x:d(e,"x","reverse")},r={dims:t};return w.runKernel(mu,s,r)}const ue=b({reverse_:Nb});function Sb(e){const t=d(e,"x","reverse");return g(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),ue(t,0)}const uh=b({reverse1d_:Sb});function Tb(e,t){const n=d(e,"x","reverse");return g(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),ue(n,t)}const ch=b({reverse2d_:Tb});function Eb(e,t){const n=d(e,"x","reverse");return g(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),ue(n,t)}const lh=b({reverse3d_:Eb});function $b(e,t){const n=d(e,"x","reverse");return g(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),ue(n,t)}const hh=b({reverse4d_:$b});function vb(e){const n={x:d(e,"x","round")};return w.runKernel(gu,n)}const jr=b({round_:vb});function kb(e){const n={x:d(e,"x","rsqrt","float32")};return w.runKernel(yu,n)}const ph=b({rsqrt_:kb});function _b(e){const n={x:d(e,"x","selu")};return w.runKernel(Tu,n)}const fh=b({selu_:_b});function Ib(e,t,n,s,r,a=[1,1],o="NHWC"){const i=d(e,"x","separableConv2d"),u=d(t,"depthwiseFilter","separableConv2d"),c=d(n,"pointwiseFilter","separableConv2d");let l=i,h=!1;if(i.rank===3&&(h=!0,l=_(i,[1,i.shape[0],i.shape[1],i.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");g(l.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${l.rank}.`),g(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),g(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),g(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),g(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const f=u.shape[2],m=u.shape[3];g(c.shape[2]===f*m,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${f*m}, but got ${c.shape[2]}.`);const S=Yn(l,u,s,r,o,a),N=Sn(S,c,1,"valid",o);return h?_(N,[N.shape[1],N.shape[2],N.shape[3]]):N}const dh=b({separableConv2d_:Ib});async function Ab(e,t){const n=d(e,"x","setdiff1d"),s=d(t,"y","setdiff1d");g(n.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${s.dtype}).`),g(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),g(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await n.data(),a=await s.data(),o=new Set(a);let i=0;for(let l=0;l<r.length;l++)o.has(r[l])||i++;const u=new Vn([i],n.dtype),c=new Vn([i],"int32");for(let l=0,h=0;l<r.length;l++)o.has(r[l])||(u.values[h]=r[l],c.values[h]=l,h++);return[u.toTensor(),c.toTensor()]}const mh=Ab;function xb(e){const n={x:d(e,"x","sign")};return w.runKernel(ku,n)}const gh=b({sign_:xb});function Ob(e){const n={x:d(e,"x","sin","float32")};return w.runKernel($u,n)}const yh=b({sin_:Ob});function Db(e){const n={x:d(e,"x","sinh")};return w.runKernel(vu,n)}const bh=b({sinh_:Db});function Cb(e,t,n){const s=d(e,"x","slice1d");return g(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),G(s,[t],[n])}const wh=b({slice1d_:Cb});function Rb(e,t,n){const s=d(e,"x","slice2d");return g(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),G(s,t,n)}const Nh=b({slice2d_:Rb});function Fb(e,t,n){const s=d(e,"x","slice3d");return g(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),G(s,t,n)}const Sh=b({slice3d_:Fb});function Lb(e,t,n){const s=d(e,"x","slice4d");return g(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),G(s,t,n)}const Th=b({slice4d_:Lb});function Bb(e,t=-1){const n=d(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const s={logits:n},r={dim:t};return w.runKernel(Cu,s,r)}const Eh=b({softmax_:Bb});function Pb(e){g(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);const t={input:e};return w.runKernel(ci,t)}const ss=b({fft_:Pb});function zb(e){g(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);const t={input:e};return w.runKernel(wi,t)}const pn=b({ifft_:zb});function Vb(e){const t=e.shape[e.shape.length-1],n=e.size/t;let s;if(t<=2){const r=_(e,[n,t]);s=pn(r)}else{const r=[n,2*(t-1)],a=_(We(e),[n,t]),o=_(vn(e),[n,t]),i=ue(G(a,[0,1],[n,t-2]),1),u=C(ue(G(o,[0,1],[n,t-2]),1),M(-1)),c=ht([a,i],1),l=ht([o,u],1),h=_(Kt(c,l),[r[0],r[1]]);s=pn(h)}if(s=We(s),e.rank===3&&e.shape[0]!==0){const r=s,a=e.shape[0];s=_(s,[a,s.shape[0]/a,s.shape[1]]),r.dispose()}return s}const qr=b({irfft_:Vb});function Wb(e,t,n=0){const r={x:d(e,"x","split")},a={numOrSizeSplits:t,axis:n};return w.runKernel(Du,r,a)}const Me=b({split_:Wb});function Mb(e,t){g(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1];const s=e.size/n;let r;if(t!=null&&t<n){const S=e.shape.map(N=>0),T=e.shape.map(N=>N);T[e.shape.length-1]=t,r=G(e,S,T),n=t}else if(t!=null&&t>n){const S=e.shape.map(T=>T);S[e.shape.length-1]=t-n,r=ht([e,ve(S)],e.shape.length-1),n=t}else r=e;const a=Tt(r),o=_(Kt(r,a),[s,n]),i=ss(o),u=Math.floor(n/2)+1,c=We(i),l=vn(i),h=Me(c,[u,n-u],c.shape.length-1),f=Me(l,[u,n-u],l.shape.length-1),m=r.shape.slice();return m[r.shape.length-1]=u,_(Kt(h[0],f[0]),m)}const rs=b({rfft_:Mb});function Ub(e,t){let n=d(e,"a","squaredDifference"),s=d(t,"b","squaredDifference");[n,s]=tt(n,s),rt(n.shape,s.shape);const r={a:n,b:s},a={};return w.runKernel(zu,r,a)}const Gr=b({squaredDifference_:Ub});function jb(e,t){const n=d(e,"x","squeeze","string_or_numeric");return _(n,no(n.shape,t).newShape)}const as=b({squeeze_:jb});function qb(e,t=0){const n=rn(e,"tensors","stack","string_or_numeric");g(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&g(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");const s=n,r={axis:t};return w.runKernel(Qi,s,r)}const Wt=b({stack_:qb});function Gb(e,t=0){const s={x:d(e,"x","step")},r={alpha:t};return w.runKernel(tc,s,r)}const Hr=b({step_:Gb});function Hb(e,t,n,s,r=0,a=0,o=0,i=0,u=0){const l={x:d(e,"x","stridedSlice","string_or_numeric")},h={begin:t,end:n,strides:s,beginMask:r,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};return w.runKernel(Wu,l,h)}const $h=b({stridedSlice_:Hb});function Kb(e){const n={x:d(e,"x","tan","float32")};return w.runKernel(Gu,n)}const vh=b({tan_:Kb});function vt(e,t){Ie(e);const n=Bt(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return ce(e,null,n,t)}function Re(e,t,n){if(Ie(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=Bt(e,n);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ce(e,t,s,n)}function Kr(e,t,n){if(Ie(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=Bt(e,n);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return ce(e,t,s,n)}function kh(e,t,n){if(Ie(e),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=Bt(e,n);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return ce(e,t,s,n)}function _h(e,t,n){if(Ie(e),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=Bt(e,n);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return ce(e,t,s,n)}function Ih(e,t,n){if(Ie(e),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=Bt(e,n);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||s,ce(e,t,s,n)}function Xr(e,t,n){const s=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${s}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(a+` update.rank < ${r}. `);if(e.length<s+(n.rank-r))throw new Error(a+` Output shape length < ${s+(n.rank-r)}`);if(n.rank!==r+e.length-s)throw new Error(a+` update.rank != ${r+e.length-s}`);for(let o=0;o<r;++o)if(n.shape[o]!==t.shape[o])throw new Error(a+` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<n.rank-r;++o)if(n.shape[o+r]!==e[o+s])throw new Error(a+` updates.shape[${o+r}] (${n.shape[o+r]}) != shape[${o+r}] (${e[o+r]})`)}function os(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}Xr(n,t,e)}function Ah(e,t,n){const s=t.shape.length,r=s>1?t.shape[s-1]:1,a=n.length;let o=1;for(let h=r;h<a;++h)o*=n[h];const i=r<1?1:r,u=q(t.shape)/i,c=[...Ue(n.slice(0,r)),1],l=q(n);return{sliceRank:r,numUpdates:u,sliceSize:o,strides:c,outputSize:l}}const Xb=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:Ah,validateInput:os,validateUpdateShape:Xr},Symbol.toStringTag,{value:"Module"}));function Zb(e,t,n){const s=d(e,"tensor","tensorScatterupdate"),r=d(t,"indices","tensorScatterupdate","int32"),a=d(n,"updates","tensorScatterupdate");if(os(a,r,s.shape),s.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${a.dtype}.`);const o={tensor:s,indices:r,updates:a},i={};return w.runKernel(wu,o,i)}const xh=b({tensorScatterUpdate_:Zb});function Jb(e,t=1,n=!0){const s=d(e,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);const a={x:s},o={k:t,sorted:n},[i,u]=w.runKernel(Ku,a,o);return{values:i,indices:u}}const Oh=b({topk_:Jb});function Yb(e,t=0,n=1,s,r){if(Et(e),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const a=new Wr(t,n,s,!0,r),o=Pt(e,s);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const Dh=b({truncatedNormal_:Yb});function Qb(e,t=0){const n=d(e,"x","unique","string_or_numeric");g(n.rank>0,()=>"The input tensor must be at least 1D");const s={x:n},r={axis:t},[a,o]=w.runKernel(Zu,s,r);return{values:a,indices:o}}const Ch=b({unique_:Qb});function tw(e,t,n){const s=d(e,"x","unsortedSegmentSum"),r=d(t,"segmentIds","unsortedSegmentSum","int32");g(Fe(n),()=>"numSegments must be of dtype int");const a={x:s,segmentIds:r},o={numSegments:n};return w.runKernel(Yu,a,o)}const Rh=b({unsortedSegmentSum_:tw});function ew(e,t=0){const n=d(e,"x","unstack","string_or_numeric");g(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);const s={value:n},r={axis:t};return w.runKernel(Ju,s,r)}const le=b({unstack_:ew});function Fh(e,t){return es(e,t,"right")}function Lh(e,t=!0,n,s){return w.makeVariable(e,t,n,s)}function Bh(e,t){const n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);const s=Pt(e,"int32"),r=Pt([n.length,e.length],"int32");for(let a=0;a<n.length;a++){const o=s.indexToLoc(n[a]),i=a*e.length;r.values.set(o,i)}return r.toTensor()}async function nw(e){const t=d(e,"condition","whereAsync","bool"),n=await t.data(),s=Bh(t.shape,n);return e!==t&&t.dispose(),s}const Zr=nw;async function sw(e,t,n){const s=d(e,"tensor","boolMask"),r=d(t,"mask","boolMask","bool"),a=n??0,o=r.rank,i=s.shape;g(o>0,()=>"mask cannot be scalar"),gt(i.slice(a,a+o),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let T=a;T<a+o;T++)u*=i[T];const c=i.slice(0,a).concat([u],i.slice(a+o)),l=_(s,c),h=_(r,[-1]),f=await Zr(h),m=as(f,[1]),S=vr(l,m,a);return e!==s&&s.dispose(),t!==r&&r.dispose(),m.dispose(),l.dispose(),h.dispose(),f.dispose(),S}const Ph=sw;function rw(e,t,n){const s=d(e,"x","transpose");if(t==null&&(t=s.shape.map((o,i)=>i).reverse()),g(s.rank===t.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${t}.`),t.forEach(o=>{g(o>=0&&o<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${t}`)}),s.rank<=1)return s.clone();const r={x:s},a={perm:t};return s.dtype==="complex64"?j(()=>{let o=We(s),i=vn(s);return o=w.runKernel(On,{x:o},a),i=w.runKernel(On,{x:i},a),n&&(i=Ct(i)),Kt(o,i)}):w.runKernel(On,r,a)}const fn=b({transpose_:rw});function aw(e,t,n,s,r=!0){const a=d(e,"v","movingAverage"),o=d(t,"x","movingAverage"),i=d(n,"decay","movingAverage");pc(a,o),g(Rt(a.shape,o.shape),()=>"Shape mismatch in v and x");const u=M(1),c=W(u,i);let l=C(W(o,a),c);if(r){g(s!=null,()=>"When using zeroDebias: true, step is required.");const h=d(s,"step","movingAverage");l=X(l,W(u,Pe(i,h)))}return B(a,l)}const zh=b({movingAverage_:aw});function ow(e,t,n){Et(n);const s=d(e,"indices","scatterND","int32"),r=d(t,"updates","scatterND");os(r,s,n);const a={indices:s,updates:r},o={shape:n};return w.runKernel(bu,a,o)}const Vh=b({scatterND_:ow});function iw(e,t,n,s){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const r=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);const o=t.size;if(!(t.rank===0||t.rank===1&&o===r))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${r}]`);if(t.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function uw(e,t,n,s=0){Et(n);const r=d(e,"sparseIndices","sparseToDense","int32"),a=d(t,"sparseValues","sparseToDense","string_or_numeric"),o=d(s,"defaultValue","sparseToDense",a.dtype);iw(r,a,n,o);const i={sparseIndices:r,sparseValues:a,defaultValue:o},u={outputShape:n};return w.runKernel(Pu,i,u)}const Wh=b({sparseToDense_:uw});function cw(e,t){const n=d(t,"indices","gatherND","int32"),r={params:d(e,"x","gatherND","string_or_numeric"),indices:n};return w.runKernel(gi,r)}const Mh=b({gatherND_:cw});function lw(e,t){if(t==null)return e.shape.slice();if(Rt(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let s=0;s<e.shape.length;s++)t[s]==null&&e.shape[s]!=null?n.push(e.shape[s]):n.push(t[s]);return n}return t}function hw(e,t,n,s){const r=d(e,"x","dropout");if(g(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),g(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof nt?r.clone():r;const a=lw(r,n),o=1-t,i=X($r(B(ns(a,0,1,"float32",s),o)),o);return C(r,i)}const Uh=b({dropout_:hw});function Jr(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function is(e,t,n){const s=1-e%2,r=new Float32Array(e);for(let a=0;a<e;++a){const o=2*Math.PI*a/(e+s-1);r[a]=t-n*Math.cos(o)}return vt(r,"float32")}async function pw(e,t,n=1){const s=d(e,"predictions","inTopK"),r=d(t,"targets","inTopK");g(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),g(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),gt(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=s.shape[s.shape.length-1];g(n>0&&n<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`);const o=await s.data(),i=await r.data(),[u,c]=[o.length/a,a],l=so("bool",u);for(let h=0;h<u;h++){const f=h*c,m=o.subarray(f,f+c),S=[];for(let T=0;T<m.length;T++)S.push({value:m[T],index:T});S.sort((T,N)=>N.value-T.value),l[h]=0;for(let T=0;T<n;T++)if(S[T].index===i[h]){l[h]=1;break}}return e!==s&&s.dispose(),t!==r&&r.dispose(),Dt(l,r.shape,"bool")}const jh=pw;function fw(e,t,n,s,r,a="NHWC",o){let i=e;e.rank===3&&(i=_(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;u.rank===3&&(u=_(t,[1,t.shape[0],t.shape[1],t.shape[2]])),g(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),g(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),g(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const c=a==="NHWC"?i.shape[3]:i.shape[1],l=a==="NHWC"?u.shape[3]:u.shape[1];g(c===n[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${n[2]}.`),g(l===n[3],()=>`Error in conv2dDerFilter: depth of dy (${l}) must match output depth for filter (${n[3]}).`),At("conv2dDerFilter",r,o);const h={x:i,dy:u},f={strides:s,pad:r,dataFormat:a,dimRoundingMode:o,filterShape:n};return w.runKernel(zo,h,f)}const dw=b({conv2DBackpropFilter_:fw});function us(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return C(e,Hr(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function cs(e,t){let n=t;const s=wr(e.shape,t.shape);return s.length>0&&(n=K(n,s)),_(n,e.shape)}function ls(e,t,n,s){if(t==="linear")return e;if(t==="relu")return kn(e);if(t==="elu")return Sr(e);if(t==="relu6")return Ur(e);if(t==="prelu")return Br(e,n);if(t==="leakyrelu")return _r(e,s);if(t==="sigmoid")return we(e);throw new Error(`Unknown fused activation ${t}.`)}const hs=(e,t)=>!(e>0)||t==="linear";function mw({x:e,filter:t,strides:n,pad:s,dataFormat:r="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:l}){if(u=u||"linear",hs(w.state.gradientDepth,u)===!1){g(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let x=Sn(e,t,n,s,r,a,o);return i!=null&&(x=B(x,i)),ls(x,u,c,l)}const h=d(e,"x","conv2d","float32"),f=d(t,"filter","conv2d","float32");let m=h,S=!1;h.rank===3&&(S=!0,m=_(h,[1,h.shape[0],h.shape[1],h.shape[2]])),g(m.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${m.rank}.`),g(f.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`),At("fused conv2d",s,o);const T=r==="NHWC"?m.shape[3]:m.shape[1];g(f.shape[2]===T,()=>`Error in conv2d: depth of input (${T}) must match input depth for filter ${f.shape[2]}.`),g(Xt(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);const N=wn(m.shape,f.shape,n,a,s,o);let E;i!=null&&(E=d(i,"bias","fused conv2d"),[E]=tt(E,h),r==="NHWC"?rt(N.outShape,E.shape):(g(E.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${E.shape.length}.`),g(E.shape.length===0||E.shape[0]===N.outChannels||E.shape[0]===1,()=>`Error in fused conv2d: bias shape (${E.shape}) is not compatible with the number of output channels (${N.outChannels})`)));let O;if(c!=null){const x=c.shape;if(g(x.length<=1||x.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${x.length}.`),x.length===1)g(x[0]===1||x[0]===N.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${x}) is not compatible with the number of output channels (${N.outChannels}).`);else if(x.length===3)try{rt(x,N.outShape)}catch{const R=`Error in fused conv2d: PReLU activation weights (${x}) is not compatible with the output shape of the conv2d (${N.outShape}).`;throw Error(R)}O=d(c,"prelu weights","fused conv2d")}const $=(x,F)=>{g(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[R,k,v,y]=F,A=us(x,v,u);g(un(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const L=al(k.shape,A,R,n,s),V=dw(k,A,R.shape,n,s),z=[L,V];if(y!=null){const J=cs(y,A);z.push(J)}return z},I={x:m,filter:f,bias:E,preluActivationWeights:O},D={strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:o,activation:u,leakyreluAlpha:l};return i==null?Vt((F,R,k)=>{let v=w.runKernel(Es,I,D);return k([R,F,v]),S&&(v=_(v,[v.shape[1],v.shape[2],v.shape[3]])),{value:v,gradFunc:$}})(m,f):Vt((F,R,k,v)=>{let y=w.runKernel(Es,I,D);return v([R,F,y,k]),S&&(y=_(y,[y.shape[1],y.shape[2],y.shape[3]])),{value:y,gradFunc:$}})(m,f,E)}const gw=b({fusedConv2d_:mw});function yw(e,t,n,s,r,a=[1,1],o){let i=e;e.rank===3&&(i=_(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;u.rank===3&&(u=_(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={x:i,dy:u},l={strides:s,pad:r,dimRoundingMode:o,dilations:a,filterShape:n};return w.runKernel(Jo,c,l)}const bw=b({depthwiseConv2dNativeBackpropFilter_:yw});function ww(e,t,n,s,r,a=[1,1],o){let i=t,u=!1;t.rank===3&&(u=!0,i=_(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const c={dy:i,filter:n},l={strides:s,pad:r,dimRoundingMode:o,dilations:a,inputShape:e},h=w.runKernel(Yo,c,l);return u?_(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Nw=b({depthwiseConv2dNativeBackpropInput_:ww});function Sw({x:e,filter:t,strides:n,pad:s,dataFormat:r="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:l}){if(hs(w.state.gradientDepth,u)===!1){let D=Yn(e,t,n,s,r,a,o);return i!=null&&(D=B(D,i)),ls(D,u,c,l)}const h=d(e,"x","depthwiseConv2d","float32"),f=d(t,"filter","depthwiseConv2d","float32");let m=h,S=!1;h.rank===3&&(S=!0,m=_(h,[1,h.shape[0],h.shape[1],h.shape[2]])),g(m.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${m.rank}.`),g(f.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`),g(m.shape[3]===f.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${m.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`),a==null&&(a=[1,1]),g(Xt(n,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),At("fused depthwiseConv2d",s,o);const T=wn(m.shape,f.shape,n,a,s,o,!0);let N;i!=null&&(N=d(i,"bias","fused conv2d"),[N]=tt(N,h),rt(T.outShape,N.shape));let E;c!=null&&(E=d(c,"prelu weights","fused depthwiseConv2d"));const O=(D,x)=>{g(un(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[F,R,k,v]=x,y=us(D,k,u),A=Nw(R.shape,y,F,n,s,a,o),L=bw(R,y,F.shape,n,s,a,o);if(v!=null){const V=cs(N,y);return[A,L,V]}return[A,L]},$={x:m,filter:f,bias:N,preluActivationWeights:E},I={strides:n,pad:s,dataFormat:r,dilations:a,dimRoundingMode:o,activation:u,leakyreluAlpha:l};return i==null?Vt((x,F,R)=>{let k=w.runKernel($s,$,I);return R([F,x,k]),S&&(k=_(k,[k.shape[1],k.shape[2],k.shape[3]])),{value:k,gradFunc:O}})(m,f):Vt((x,F,R,k)=>{let v=w.runKernel($s,$,I);return k([F,x,v,R]),S&&(v=_(v,[v.shape[1],v.shape[2],v.shape[3]])),{value:v,gradFunc:O}})(m,f,N)}const Tw=b({fusedDepthwiseConv2d_:Sw});function Ew({a:e,b:t,transposeA:n=!1,transposeB:s=!1,bias:r,activation:a="linear",preluActivationWeights:o,leakyreluAlpha:i=.2}){if(hs(w.state.gradientDepth,a)===!1){let y=U(e,t,n,s);return r!=null&&(y=B(y,r)),ls(y,a,o,i)}let u=d(e,"a","fused matMul"),c=d(t,"b","fused matMul");[u,c]=tt(u,c);const l=n?u.shape[u.rank-2]:u.shape[u.rank-1],h=s?c.shape[c.rank-1]:c.shape[c.rank-2],f=n?u.shape[u.rank-1]:u.shape[u.rank-2],m=s?c.shape[c.rank-2]:c.shape[c.rank-1],S=u.shape.slice(0,-2),T=c.shape.slice(0,-2),N=q(S),E=q(T);g(l===h,()=>`Error in fused matMul: inner shapes (${l}) and (${h}) of Tensors with shapes ${u.shape} and ${c.shape} and transposeA=${n} and transposeB=${s} must match.`);const $=rt(u.shape.slice(0,-2),c.shape.slice(0,-2)).concat([f,m]),I=n?_(u,[N,l,f]):_(u,[N,f,l]),D=s?_(c,[E,m,h]):_(c,[E,h,m]);let x;r!=null&&(x=d(r,"bias","fused matMul"),[x]=tt(x,u),rt($,x.shape));let F;o!=null&&(F=d(o,"prelu weights","fused matMul"));const R=(y,A)=>{const[L,V,z,J]=A,Y=us(_(y,z.shape),z,a);let at,et;if(!n&&!s?(at=U(Y,V,!1,!0),et=U(L,Y,!0,!1)):!n&&s?(at=U(Y,V,!1,!1),et=U(Y,L,!0,!1)):n&&!s?(at=U(V,Y,!1,!0),et=U(L,Y,!1,!1)):(at=U(V,Y,!0,!0),et=U(Y,L,!0,!0)),r!=null){const st=cs(J,Y);return[at,et,st]}else return[at,et]},k={a:I,b:D,bias:x,preluActivationWeights:F},v={transposeA:n,transposeB:s,activation:a,leakyreluAlpha:i};return r==null?Vt((A,L,V)=>{const z=w.runKernel(Ts,k,v);return V([A,L,z]),{value:_(z,$),gradFunc:R}})(I,D):Vt((A,L,V,z)=>{const J=w.runKernel(Ts,k,v);return z([A,L,J,V]),{value:_(J,$),gradFunc:R}})(I,D,x)}const $w=b({fusedMatMul_:Ew});const qh=Object.freeze(Object.defineProperty({__proto__:null,conv2d:gw,depthwiseConv2d:Tw,matMul:$w},Symbol.toStringTag,{value:"Module"}));function vw(e){return is(e,.54,.46)}const kw=b({hammingWindow_:vw});function _w(e){return is(e,.5,.5)}const Gh=b({hannWindow_:_w});function Iw(e,t,n,s=!1,r=0){let a=0;const o=[];for(;a+t<=e.size;)o.push(G(e,a,t)),a+=n;if(s)for(;a<e.size;){const i=a+t-e.size,u=ht([G(e,a,t-i),je([i],r)]);o.push(u),a+=n}return o.length===0?Re([],[0,t]):_(ht(o),[o.length,t])}const Hh=b({frame_:Iw});function Aw(e,t,n,s,r=Gh){s==null&&(s=Jr(t));const a=Hh(e,t,n),o=C(a,r(t));return rs(o,s)}const xw=b({stft_:Aw});function Ow(e,t,n,s,r="bilinear",a=0){const o=d(e,"image","cropAndResize"),i=d(t,"boxes","cropAndResize","float32"),u=d(n,"boxInd","cropAndResize","int32"),c=i.shape[0];g(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),g(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${i.shape}.`),g(u.rank===1&&u.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${i.shape}.`),g(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),g(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),g(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const l={image:o,boxes:i,boxInd:u},h={method:r,extrapolationValue:a,cropSize:s};return w.runKernel(Ho,l,h)}const Dw=b({cropAndResize_:Ow});function Cw(e){const t=d(e,"image","flipLeftRight","float32");g(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const n={image:t};return w.runKernel(hi,n,{})}const Rw=b({flipLeftRight_:Cw});function Fw(e){const t=d(e,"image","grayscaleToRGB"),n=t.rank-1,s=t.shape[n];g(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),g(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(t.rank);return r.fill(1,0,n),r[n]=3,Ce(t,r)}const Lw=b({grayscaleToRGB_:Fw});function Bw(e){const t=d(e,"image","RGBToGrayscale"),n=t.rank-1,s=t.shape[n];g(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),g(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=t.dtype,a=Z(t,"float32"),o=vt([.2989,.587,.114]);let i;switch(t.rank){case 2:i=me("ij,j->i",a,o);break;case 3:i=me("ijk,k->ij",a,o);break;case 4:i=me("ijkl,l->ijk",a,o);break;case 5:i=me("ijklm,m->ijkl",a,o);break;case 6:i=me("ijklmn,n->ijklm",a,o);break;default:throw new Error("Not a valid tensor rank.")}return i=Mt(i,-1),Z(i,r)}const Pw=b({rgbToGrayscale_:Bw});function zw(e,t,n=0,s=.5){const r=d(e,"image","rotateWithOffset","float32");g(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const a={image:r},o={radians:t,fillValue:n,center:s};return w.runKernel(ec,a,o)}const Vw=b({rotateWithOffset_:zw});function Ge(e,t,n,s,r,a){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),a==null&&(a=0);const o=e.shape[0];return n=Math.min(n,o),g(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),g(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),g(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),g(t.rank===1,()=>"scores must be a 1D tensor"),g(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),g(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:a}}function Ww(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY){const a=d(e,"boxes","nonMaxSuppression","float32"),o=d(t,"scores","nonMaxSuppression","float32"),i=Ge(a,o,n,s,r);n=i.maxOutputSize,s=i.iouThreshold,r=i.scoreThreshold;const u={maxOutputSize:n,iouThreshold:s,scoreThreshold:r};return w.runKernel(Ki,{boxes:a,scores:o},u)}const Mw=b({nonMaxSuppression_:Ww});function Uw(e,t,n){const s=jw(e,t,n),r=s<0?-(s+1):s;e.splice(r,0,t)}function jw(e,t,n){return Gw(e,t,n||qw)}function qw(e,t){return e>t?1:e<t?-1:0}function Gw(e,t,n){let s=0,r=e.length,a=0,o=!1;for(;s<r;){a=s+(r-s>>>1);const i=n(t,e[a]);i>0?s=a+1:(r=a,o=!i)}return o?s:-s-1}function Kh(e,t,n,s,r){return Yr(e,t,n,s,r,0)}function Xh(e,t,n,s,r,a){return Yr(e,t,n,s,r,0,!1,a,!0)}function Zh(e,t,n,s,r,a){return Yr(e,t,n,s,r,a,!0)}function Yr(e,t,n,s,r,a,o=!1,i=!1,u=!1){const c=[];for(let N=0;N<t.length;N++)t[N]>r&&c.push({score:t[N],boxIndex:N,suppressBeginIndex:0});c.sort(La);const l=a>0?-.5/a:0,h=[],f=[];for(;h.length<n&&c.length>0;){const N=c.pop(),{score:E,boxIndex:O,suppressBeginIndex:$}=N;if(E<r)break;let I=!1;for(let D=h.length-1;D>=$;--D){const x=Hw(e,O,h[D]);if(x>=s){I=!0;break}if(N.score=N.score*Kw(s,l,x),N.score<=r)break}N.suppressBeginIndex=h.length,I||(N.score===E?(h.push(O),f.push(N.score)):N.score>r&&Uw(c,N,La))}const m=h.length,S=n-m;i&&S>0&&(h.push(...new Array(S).fill(0)),f.push(...new Array(S).fill(0)));const T={selectedIndices:h};return o&&(T.selectedScores=f),u&&(T.validOutputs=m),T}function Hw(e,t,n){const s=e.subarray(t*4,t*4+4),r=e.subarray(n*4,n*4+4),a=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),i=Math.max(s[0],s[2]),u=Math.max(s[1],s[3]),c=Math.min(r[0],r[2]),l=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),f=Math.max(r[1],r[3]),m=(i-a)*(u-o),S=(h-c)*(f-l);if(m<=0||S<=0)return 0;const T=Math.max(a,c),N=Math.max(o,l),E=Math.min(i,h),O=Math.min(u,f),$=Math.max(E-T,0)*Math.max(O-N,0);return $/(m+S-$)}function Kw(e,t,n){const s=Math.exp(t*n*n);return n<=e?s:0}function La(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function Xw(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY){const a=d(e,"boxes","nonMaxSuppressionAsync"),o=d(t,"scores","nonMaxSuppressionAsync"),i=Ge(a,o,n,s,r);n=i.maxOutputSize,s=i.iouThreshold,r=i.scoreThreshold;const u=await Promise.all([a.data(),o.data()]),c=u[0],l=u[1],{selectedIndices:h}=Kh(c,l,n,s,r);return a!==e&&a.dispose(),o!==t&&o.dispose(),vt(h,"int32")}const Zw=Xw;function Jw(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,a=0){const o=d(e,"boxes","nonMaxSuppression"),i=d(t,"scores","nonMaxSuppression"),u=Ge(o,i,n,s,r,a);n=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,a=u.softNmsSigma;const c={boxes:o,scores:i},l={maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:a},h=w.runKernel(Zi,c,l);return{selectedIndices:h[0],selectedScores:h[1]}}const Yw=b({nonMaxSuppressionWithScore_:Jw});async function Qw(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,a=0){const o=d(e,"boxes","nonMaxSuppressionAsync"),i=d(t,"scores","nonMaxSuppressionAsync"),u=Ge(o,i,n,s,r,a);n=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,a=u.softNmsSigma;const c=await Promise.all([o.data(),i.data()]),l=c[0],h=c[1],{selectedIndices:f,selectedScores:m}=Zh(l,h,n,s,r,a);return o!==e&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:vt(f,"int32"),selectedScores:vt(m)}}const t1=Qw;function e1(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,a=!1){const o=d(e,"boxes","nonMaxSuppression"),i=d(t,"scores","nonMaxSuppression"),u=Ge(o,i,n,s,r,null),c=u.maxOutputSize,l=u.iouThreshold,h=u.scoreThreshold,f={boxes:o,scores:i},m={maxOutputSize:c,iouThreshold:l,scoreThreshold:h,padToMaxOutputSize:a},S=w.runKernel(Xi,f,m);return{selectedIndices:S[0],validOutputs:S[1]}}const n1=b({nonMaxSuppressionPadded_:e1});async function s1(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,a=!1){const o=d(e,"boxes","nonMaxSuppressionAsync"),i=d(t,"scores","nonMaxSuppressionAsync"),u=Ge(o,i,n,s,r,null),c=u.maxOutputSize,l=u.iouThreshold,h=u.scoreThreshold,[f,m]=await Promise.all([o.data(),i.data()]),{selectedIndices:S,validOutputs:T}=Xh(f,m,c,l,h,a);return o!==e&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:vt(S,"int32"),validOutputs:M(T,"int32")}}const r1=s1;function a1(e,t,n=!1,s=!1){const r=d(e,"images","resizeBilinear");g(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),g(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),g(s===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=r,o=!1;r.rank===3&&(o=!0,a=_(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const i={images:a},u={alignCorners:n,halfPixelCenters:s,size:t},c=w.runKernel(fu,i,u);return o?_(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const o1=b({resizeBilinear_:a1});function i1(e,t,n=!1,s=!1){const r=d(e,"images","resizeNearestNeighbor");g(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),g(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),g(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),g(s===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=r,o=!1;r.rank===3&&(o=!0,a=_(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const i={images:a},u={alignCorners:n,halfPixelCenters:s,size:t},c=w.runKernel(pu,i,u);return o?_(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const u1=b({resizeNearestNeighbor_:i1});function c1(e,t="binary",n=!1,s=.5){const r=d(e,"image","threshold"),a=.2989,o=.587,i=.114,u=r.shape[0]*r.shape[1];let c=C(vt([s]),255),l,h,f,m;if(g(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),g(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),g(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),g(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),r.shape[2]===3){[l,h,f]=Me(r,[1,1,1],-1);const N=C(l,a),E=C(h,o),O=C(f,i);m=B(B(N,E),O)}else m=e;if(t==="otsu"){const N=br(Z(jr(m),"int32"),Dt([]),256);c=l1(N,u)}const S=n?Qn(m,c):$n(m,c);return Z(C(S,255),"int32")}function l1(e,t){let n=vt([-1]),s=vt([0]),r=vt([0]),a,o,i,u,c,l;for(let h=0;h<e.size-1;h++){a=G(e,0,h+1),o=G(e,h+1),c=X(K(a),t),l=X(K(o),t);const f=K(C(a,Ve(0,a.size)));i=X(f,K(a));const m=je(o.shape,a.size),S=B(Ve(0,o.size),m),T=C(o,S);u=X(K(T),K(o));const N=W(i,u),E=W(i,u),O=C(c,l);r=C(C(O,N),E);const $=$n(r,s);s=Ht($,r,s),n=Ht($,vt([h]),n)}return n}const h1=b({threshold_:c1});function p1(e,t,n="nearest",s="constant",r=0,a){const o=d(e,"image","transform","float32"),i=d(t,"transforms","transform","float32");g(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),g(i.rank===2&&(i.shape[0]===o.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),g(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);const u={image:o,transforms:i},c={interpolation:n,fillMode:s,fillValue:r,outputShape:a};return w.runKernel(Xu,u,c)}const f1=b({transform_:p1});function d1(e,t,n){const s=d(e,"a","bandPart");g(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[a,o]=s.shape.slice(-2);let i,u;typeof t=="number"?(g(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),g(t<=a,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`),i=d(t<0?a:t,"numLower","bandPart")):(g(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),i=Ht(jn(t,0),a,hn(t,a))),typeof n=="number"?(g(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),g(n<=o,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`),u=d(n<0?o:n,"numUpper","bandPart")):(g(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=Ht(jn(n,0),o,hn(n,o)));const c=_(Ve(0,a,1,"int32"),[-1,1]),l=Ve(0,o,1,"int32"),h=W(c,l),f=cn(Qn(h,i),kr(h,Ct(u))),m=ve([a,o],s.dtype);return _(Wt(le(_(s,[-1,a,o])).map(S=>Ht(f,S,m))),r)}const m1=b({bandPart_:d1});function g1(e){let t;if(Array.isArray(e)){t=!1,g(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=e[0].shape[0];for(let a=1;a<e.length;++a)g(e[a].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[a].shape[0]} vs. ${r})`)}else t=!0,e=Me(e,e.shape[0],0).map(r=>as(r,[0]));g(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);const n=[],s=e;for(let r=0;r<e.length;++r)n.push(w.tidy(()=>{let a=s[r];if(r>0)for(let o=0;o<r;++o){const i=C(K(C(n[o],a)),n[o]);a=W(a,i)}return X(a,En(a,"euclidean"))}));return t?Wt(n,0):n}const y1=b({gramSchmidt_:g1});function b1(e,t=!1){if(g(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return Ba(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce((u,c)=>u*c),s=le(_(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],a=[];s.forEach(u=>{const[c,l]=Ba(u,t);r.push(c),a.push(l)});const o=_(Wt(r,0),e.shape),i=_(Wt(a,0),e.shape);return[o,i]}}function Ba(e,t=!1){return w.tidy(()=>{g(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);const n=e.shape[0],s=e.shape[1];let r=Er(n),a=Gt(e);const o=Re([[1]],[1,1]);let i=Gt(o);const u=n>=s?s:n;for(let c=0;c<u;++c){const l=a,h=i,f=r;[i,a,r]=w.tidy(()=>{const m=G(a,[c,c],[n-c,1]),S=En(m),T=G(a,[c,c],[1,1]),N=Ht($n(T,0),Re([[-1]]),Re([[1]])),E=W(T,C(N,S)),O=X(m,E);O.shape[0]===1?i=Gt(o):i=ht([o,G(O,[1,0],[O.shape[0]-1,O.shape[1]])],0);const $=Ct(X(U(N,E),S)),I=G(a,[c,0],[n-c,s]),D=C($,i),x=fn(i);if(c===0)a=W(I,U(D,U(x,I)));else{const k=W(I,U(D,U(x,I)));a=ht([G(a,[0,0],[c,s]),k],0)}const F=fn(D),R=G(r,[0,c],[n,r.shape[1]-c]);if(c===0)r=W(R,U(U(R,i),F));else{const k=W(R,U(U(R,i),F));r=ht([G(r,[0,0],[n,c]),k],1)}return[i,a,r]}),mt([l,h,f])}return!t&&n>s&&(r=G(r,[0,0],[n,s]),a=G(a,[0,0],[s,s])),[r,a]})}const w1=b({qr_:b1});var dt;(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(dt||(dt={}));function N1(e,t,n=dt.SUM_BY_NONZERO_WEIGHTS){const s=d(e,"losses","computeWeightedLoss");let r=null;t!=null&&(r=d(t,"weights","computeWeightedLoss"));const a=r==null?s:C(s,r);if(n===dt.NONE)return a;if(n===dt.SUM)return K(a);if(n===dt.MEAN){if(r==null)return ln(a);{const o=s.size/r.size,i=X(K(a),K(r));return o>1?X(i,M(o)):i}}if(n===dt.SUM_BY_NONZERO_WEIGHTS){if(r==null)return X(K(a),M(s.size));{const o=C(r,ee(s.shape)),i=Z(K(Fr(o,M(0))),"float32");return X(K(a),i)}}throw Error(`Unknown reduction: ${n}`)}const Zt=b({computeWeightedLoss_:N1});function S1(e,t,n,s=dt.SUM_BY_NONZERO_WEIGHTS){const r=d(e,"labels","absoluteDifference"),a=d(t,"predictions","absoluteDifference");let o=null;n!=null&&(o=d(n,"weights","absoluteDifference")),gt(r.shape,a.shape,"Error in absoluteDifference: ");const i=St(W(r,a));return Zt(i,o,s)}const T1=b({absoluteDifference_:S1});function E1(e,t,n,s,r=dt.SUM_BY_NONZERO_WEIGHTS){const a=d(e,"labels","cosineDistance"),o=d(t,"predictions","cosineDistance");let i=null;s!=null&&(i=d(s,"weights","cosineDistance")),gt(a.shape,o.shape,"Error in cosineDistance: ");const u=M(1),c=W(u,K(C(a,o),n,!0));return Zt(c,i,r)}const $1=b({cosineDistance_:E1});function v1(e,t,n,s=dt.SUM_BY_NONZERO_WEIGHTS){let r=d(e,"labels","hingeLoss");const a=d(t,"predictions","hingeLoss");let o=null;n!=null&&(o=d(n,"weights","hingeLoss")),gt(r.shape,a.shape,"Error in hingeLoss: ");const i=M(1);r=W(C(M(2),r),i);const u=kn(W(i,C(r,a)));return Zt(u,o,s)}const k1=b({hingeLoss_:v1});function _1(e,t,n,s=1,r=dt.SUM_BY_NONZERO_WEIGHTS){const a=d(e,"labels","huberLoss"),o=d(t,"predictions","huberLoss");let i=null;n!=null&&(i=d(n,"weights","huberLoss")),gt(a.shape,o.shape,"Error in huberLoss: ");const u=M(s),c=St(W(o,a)),l=hn(c,u),h=W(c,l),f=B(C(M(.5),It(l)),C(u,h));return Zt(f,i,r)}const I1=b({huberLoss_:_1});function A1(e,t,n,s=1e-7,r=dt.SUM_BY_NONZERO_WEIGHTS){const a=d(e,"labels","logLoss"),o=d(t,"predictions","logLoss");let i=null;n!=null&&(i=d(n,"weights","logLoss")),gt(a.shape,o.shape,"Error in logLoss: ");const u=M(1),c=M(s),l=Ct(C(a,ze(B(o,c)))),h=C(W(u,a),ze(B(W(u,o),c))),f=W(l,h);return Zt(f,i,r)}const x1=b({logLoss_:A1});function O1(e,t,n,s=dt.SUM_BY_NONZERO_WEIGHTS){const r=d(e,"labels","meanSquaredError"),a=d(t,"predictions","meanSquaredError");let o=null;n!=null&&(o=d(n,"weights","meanSquaredError")),gt(r.shape,a.shape,"Error in meanSquaredError: ");const i=Gr(r,a);return Zt(i,o,s)}const D1=b({meanSquaredError_:O1});function C1(e,t){const n=d(e,"labels","sigmoidCrossEntropyWithLogits"),s=d(t,"logits","sigmoidCrossEntropyWithLogits");gt(n.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=kn(s),a=C(s,n),o=Ir(ie(Ct(St(s))));return B(W(r,a),o)}function R1(e,t,n,s=0,r=dt.SUM_BY_NONZERO_WEIGHTS){let a=d(e,"multiClassLabels","sigmoidCrossEntropy");const o=d(t,"logits","sigmoidCrossEntropy");let i=null;if(n!=null&&(i=d(n,"weights","sigmoidCrossEntropy")),gt(a.shape,o.shape,"Error in sigmoidCrossEntropy: "),s>0){const c=M(s),l=M(1),h=M(.5);a=B(C(a,W(l,c)),C(h,c))}const u=C1(a,o);return Zt(u,i,r)}const F1=b({sigmoidCrossEntropy_:R1});function L1(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return Vt((r,a,o)=>{const u=xr(a,[n],!0),c=W(Z(a,"float32"),u);o([r,c]);const l=Ct(C(c,r));return{value:K(l,[n]),gradFunc:(m,S)=>{const[T,N]=S,E=Tn(m.shape,[n]);return[C(_(m,E),W(Z(T,"float32"),ie(N))),C(_(m,E),W(ie(N),Z(T,"float32")))]}}})(e,t)}function B1(e,t,n,s=0,r=dt.SUM_BY_NONZERO_WEIGHTS){let a=d(e,"onehotLabels","softmaxCrossEntropy");const o=d(t,"logits","softmaxCrossEntropy");let i=null;if(n!=null&&(i=d(n,"weights","softmaxCrossEntropy")),gt(a.shape,o.shape,"Error in softmaxCrossEntropy: "),s>0){const c=M(s),l=M(1),h=M(a.shape[1]);a=B(C(a,W(l,c)),X(c,h))}const u=L1(a,o);return Zt(u,i,r)}const P1=b({softmaxCrossEntropy_:B1});function z1(e,t,n,s){const r=d(e,"indices","sparseFillEmptyRows","int32"),a=d(t,"values","sparseFillEmptyRows"),o=d(n,"denseShape","sparseFillEmptyRows","int32"),i=d(s,"defaultValue","sparseFillEmptyRows",a.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(a.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);const u={indices:r,values:a,denseShape:o,defaultValue:i},c=w.runKernel(Ru,u);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const V1=b({sparseFillEmptyRows_:z1});function W1(e,t,n){const s=d(e,"inputIndices","sparseReshape","int32"),r=d(t,"inputShape","sparseReshape","int32"),a=d(n,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(a.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const o={inputIndices:s,inputShape:r,newShape:a},i=w.runKernel(Fu,o);return{outputIndices:i[0],outputShape:i[1]}}const M1=b({sparseReshape_:W1});function U1(e,t,n){const s=d(e,"data","sparseSegmentMean"),r=d(t,"indices","sparseSegmentMean","int32"),a=d(n,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);const o={data:s,indices:r,segmentIds:a};return w.runKernel(Lu,o)}const j1=b({sparseSegmentMean_:U1});function q1(e,t,n){const s=d(e,"data","sparseSegmentSum"),r=d(t,"indices","sparseSegmentSum","int32"),a=d(n,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);const o={data:s,indices:r,segmentIds:a};return w.runKernel(Bu,o)}const G1=b({sparseSegmentSum_:q1});function H1(e,t,n,s,r,a,o,i){const u=d(e,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);const c=d(t,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const l={separator:n,nGramWidths:s,leftPad:r,rightPad:a,padWidth:o,preserveShortSequences:i},h={data:u,dataSplits:c},f=w.runKernel(Mu,h,l);return{nGrams:f[0],nGramsSplits:f[1]}}const K1=b({stringNGrams_:H1});function X1(e,t,n=!0){const s=d(e,"input","stringSplit","string"),r=d(t,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const a={skipEmpty:n},o={input:s,delimiter:r},i=w.runKernel(Uu,o,a);return{indices:i[0],values:i[1],shape:i[2]}}const Z1=b({stringSplit_:X1});function J1(e,t){const n=d(e,"input","stringToHashBucketFast","string"),s={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const r={input:n};return w.runKernel(ju,r,s)}const Y1=b({stringToHashBucketFast_:J1});function Q1(e,t,n,s=!0){const r=d(e,"input","staticRegexReplace","string"),a={pattern:t,rewrite:n,replaceGlobal:s};return w.runKernel(Vu,{x:r},a)}const t0=b({staticRegexReplace_:Q1});const Jh={fft:ss,ifft:pn,rfft:rs,irfft:qr},Yh={hammingWindow:kw,hannWindow:Gh,frame:Hh,stft:xw},Qh={flipLeftRight:Rw,grayscaleToRGB:Lw,resizeNearestNeighbor:u1,resizeBilinear:o1,rgbToGrayscale:Pw,rotateWithOffset:Vw,cropAndResize:Dw,nonMaxSuppression:Mw,nonMaxSuppressionAsync:Zw,nonMaxSuppressionWithScore:Yw,nonMaxSuppressionWithScoreAsync:t1,nonMaxSuppressionPadded:n1,nonMaxSuppressionPaddedAsync:r1,threshold:h1,transform:f1},tp={bandPart:m1,gramSchmidt:y1,qr:w1},ep={absoluteDifference:T1,computeWeightedLoss:Zt,cosineDistance:$1,hingeLoss:k1,huberLoss:I1,logLoss:x1,meanSquaredError:D1,sigmoidCrossEntropy:F1,softmaxCrossEntropy:P1},np={sparseFillEmptyRows:V1,sparseReshape:M1,sparseSegmentMean:j1,sparseSegmentSum:G1},sp={stringNGrams:K1,stringSplit:Z1,stringToHashBucketFast:Y1,staticRegexReplace:t0};const e0=new Map,Ps=new Map;class rp{getClassName(){return this.constructor.className}static fromConfig(t,n){return new t(n)}}class Yt{constructor(){this.classNameMap={}}static getMap(){return Yt.instance==null&&(Yt.instance=new Yt),Yt.instance}static register(t){Yt.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function ap(e,t,n){g(e.className!=null,()=>"Class being registered does not have the static className property defined."),g(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),g(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof n>"u"&&(n=e.className);const s=n,r=t+">"+s;return Yt.register(e),e0.set(r,e),Ps.set(e,r),e}function n0(e){return Ps.has(e)?Ps.get(e):e.className}const s0=Object.freeze(Object.defineProperty({__proto__:null,Serializable:rp,SerializationMap:Yt,getRegisteredName:n0,registerClass:ap},Symbol.toStringTag,{value:"Module"}));class he extends rp{minimize(t,n=!1,s){const{value:r,grads:a}=this.computeGradients(t,s);if(s!=null){const o=s.map(i=>({name:i.name,tensor:a[i.name]}));this.applyGradients(o)}else this.applyGradients(a);return mt(a),n?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,n){return Ol(t,n)}dispose(){this.iterations_!=null&&mt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:M(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(he,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});class Qr extends he{static get className(){return"Adadelta"}constructor(t,n,s=null){super(),this.learningRate=t,this.rho=n,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=w.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const a=w.registeredVariables[s],o=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:j(()=>Tt(a).variable(o))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:j(()=>Tt(a).variable(o))});const i=Array.isArray(t)?t[r].tensor:t[s];if(i==null)return;const u=this.accumulatedGrads[r].variable,c=this.accumulatedUpdates[r].variable;j(()=>{const l=B(C(u,this.rho),C(It(i),1-this.rho)),h=C(X(zt(B(c,this.epsilon)),zt(B(u,this.epsilon))),i),f=B(C(c,this.rho),C(It(h),1-this.rho));u.assign(l),c.assign(f);const m=B(C(h,-this.learningRate),a);a.assign(m)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(mt(this.accumulatedGrads.map(t=>t.variable)),mt(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=t.length/2,s=!1;this.accumulatedGrads=t.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=t.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.rho,n.epsilon)}}class ta extends he{static get className(){return"Adagrad"}constructor(t,n=.1){super(),this.learningRate=t,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const a=w.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:j(()=>je(a.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(t)?t[r].tensor:t[s];if(o==null)return;const i=this.accumulatedGrads[r].variable;j(()=>{const u=B(i,It(o));i.assign(u);const c=B(C(X(o,zt(B(u,w.backend.epsilon()))),-this.learningRate),a);a.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&mt(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=!1;this.accumulatedGrads=t.map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,n){return new t(n.learningRate,n.initialAccumulatorValue)}}class ea extends he{static get className(){return"Adam"}constructor(t,n,s,r=null){super(),this.learningRate=t,this.beta1=n,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],j(()=>{this.accBeta1=M(n).variable(),this.accBeta2=M(s).variable()}),r==null&&(this.epsilon=w.backend.epsilon())}applyGradients(t){const n=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);j(()=>{const s=W(1,this.accBeta1),r=W(1,this.accBeta2);n.forEach((a,o)=>{const i=w.registeredVariables[a],u=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${a}/m`,variable:j(()=>Tt(i).variable(u))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${a}/v`,variable:j(()=>Tt(i).variable(u))});const c=Array.isArray(t)?t[o].tensor:t[a];if(c==null)return;const l=this.accumulatedFirstMoment[o].variable,h=this.accumulatedSecondMoment[o].variable,f=B(C(l,this.beta1),C(c,1-this.beta1)),m=B(C(h,this.beta2),C(It(c),1-this.beta2)),S=X(f,s),T=X(m,r);l.assign(f),h.assign(m);const N=B(C(X(S,B(zt(T),this.epsilon)),-this.learningRate),i);i.assign(N)}),this.accBeta1.assign(C(this.accBeta1,this.beta1)),this.accBeta2.assign(C(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&mt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&mt(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t),j(()=>{this.accBeta1.assign(Pe(this.beta1,this.iterations_+1)),this.accBeta2.assign(Pe(this.beta2,this.iterations_+1))});const n=t.length/2,s=!1;this.accumulatedFirstMoment=t.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=t.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon)}}class na extends he{static get className(){return"Adamax"}constructor(t,n,s,r=null,a=0){super(),this.learningRate=t,this.beta1=n,this.beta2=s,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],j(()=>{this.iteration=M(0).variable(),this.accBeta1=M(n).variable()}),r==null&&(this.epsilon=w.backend.epsilon())}applyGradients(t){const n=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);j(()=>{const s=W(1,this.accBeta1),r=X(-this.learningRate,B(C(this.iteration,this.decay),1));n.forEach((a,o)=>{const i=w.registeredVariables[a],u=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${a}/m`,variable:Tt(i).variable(u)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${a}/v`,variable:Tt(i).variable(u)});const c=Array.isArray(t)?t[o].tensor:t[a];if(c==null)return;const l=this.accumulatedFirstMoment[o].variable,h=this.accumulatedWeightedInfNorm[o].variable,f=B(C(l,this.beta1),C(c,1-this.beta1)),m=C(h,this.beta2),S=St(c),T=Rr(m,S);l.assign(f),h.assign(T);const N=B(C(X(r,s),X(f,B(T,this.epsilon))),i);i.assign(N)}),this.iteration.assign(B(this.iteration,1)),this.accBeta1.assign(C(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&mt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&mt(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}class ps extends he{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const a=Array.isArray(t)?t[r].tensor:t[s];if(a==null)return;const o=w.registeredVariables[s];j(()=>{const i=B(C(this.c,a),o);o.assign(i)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=Ot(M(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,n){return new t(n.learningRate)}}class sa extends ps{static get className(){return"Momentum"}constructor(t,n,s=!1){super(t),this.learningRate=t,this.momentum=n,this.useNesterov=s,this.accumulations=[],this.m=M(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const a=w.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:j(()=>Tt(a).variable(!1))});const o=this.accumulations[r].variable,i=Array.isArray(t)?t[r].tensor:t[s];i!=null&&j(()=>{let u;const c=B(C(this.m,o),i);this.useNesterov?u=B(C(this.c,B(i,C(c,this.m))),a):u=B(C(this.c,c),a),o.assign(c),a.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&mt(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=!1;this.accumulations=t.map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,n){return new t(n.learningRate,n.momentum,n.useNesterov)}}class ra extends he{static get className(){return"RMSProp"}constructor(t,n=.9,s=0,r=null,a=!1){if(super(),this.learningRate=t,this.decay=n,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,r==null&&(this.epsilon=w.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const a=w.registeredVariables[s],o=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:j(()=>Tt(a).variable(o))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:j(()=>Tt(a).variable(o))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:j(()=>Tt(a).variable(o))});const i=Array.isArray(t)?t[r].tensor:t[s];if(i==null)return;const u=this.accumulatedMeanSquares[r].variable,c=this.accumulatedMoments[r].variable;j(()=>{const l=B(C(u,this.decay),C(It(i),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[r].variable,f=B(C(h,this.decay),C(i,1-this.decay)),m=X(C(i,this.learningRate),zt(W(l,B(It(f),this.epsilon)))),S=B(C(c,this.momentum),m);u.assign(l),h.assign(f),c.assign(S);const T=W(a,S);a.assign(T)}else{const h=B(C(u,this.decay),C(It(i),1-this.decay)),f=B(C(c,this.momentum),X(C(i,this.learningRate),zt(B(h,this.epsilon))));u.assign(h),c.assign(f);const m=W(a,f);a.assign(m)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&mt(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&mt(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&mt(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=this.centered?t.length/3:t.length/2,s=!1;this.accumulatedMeanSquares=t.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=t.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=t.slice(n*2,n*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,n){return new t(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}const r0=[Qr,ta,ea,na,sa,ra,ps];function a0(){for(const e of r0)ap(e)}const o0="model",i0=".json",u0=".weights.bin";function Pa(e){return new Promise(t=>setTimeout(t)).then(e)}class ke{constructor(t){if(!P().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(ke.URL_SCHEME)&&(t=t.slice(ke.URL_SCHEME.length)),(t==null||t.length===0)&&(t=o0),this.modelJsonFileName=t+i0,this.weightDataFileName=t+u0}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=Ft.join(t.weightData),s=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],a=Tc(t,r),o=window.URL.createObjectURL(new Blob([JSON.stringify(a)],{type:"application/json"})),i=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(i.download=this.modelJsonFileName,i.href=o,await Pa(()=>i.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){const u=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=s,await Pa(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:bn(t)}}}}ke.URL_SCHEME="downloads://";class c0{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}async load(){return new Promise((t,n)=>{const s=new FileReader;s.onload=r=>{const a=JSON.parse(r.target.result),o=a.modelTopology;if(o==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(a.weightsManifest==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){t({modelTopology:o});return}const u=pr(a,c=>this.loadWeights(c));t(u)},s.onerror=r=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(t){const n=[],s=[];for(const o of t)n.push(...o.weights),s.push(...o.paths);const r=this.checkManifestAndWeightFiles(t),a=s.map(o=>this.loadWeightsFile(o,r[o]));return Promise.all(a).then(o=>[n,o])}loadWeightsFile(t,n){return new Promise((s,r)=>{const a=new FileReader;a.onload=o=>{const i=o.target.result;s(i)},a.onerror=o=>r(`Failed to weights data from file of path '${t}'.`),a.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(t){const n=[],s=this.weightsFiles.map(a=>Na(a.name)),r={};for(const a of t)a.paths.forEach(o=>{const i=Na(o);if(n.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(n.push(i),s.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);r[o]=this.weightsFiles[s.indexOf(i)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const l0=e=>P().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(ke.URL_SCHEME)?h0(e.slice(ke.URL_SCHEME.length)):null;Q.registerSaveRouter(l0);function h0(e="model"){return new ke(e)}function p0(e){return new c0(e)}function za(e,t,n,s){o(e),n=n??0,s=s??1,i(n,s);let r=0;const a=u=>(u.then(c=>{const l=n+ ++r/e.length*(s-n);return t(l),c}),u);function o(u){g(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function i(u,c){g(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),g(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),g(c>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${c}`)}return Promise.all(e.map(a))}async function op(e,t){t==null&&(t={});const n=t.fetchFunc==null?P().platform.fetch:t.fetchFunc,s=e.map(h=>n(h,t.requestInit,{isBinary:!0})),i=(t.onProgress==null?await Promise.all(s):await za(s,t.onProgress,0,.5)).map(h=>h.arrayBuffer());return t.onProgress==null?await Promise.all(i):await za(i,t.onProgress,.5,1)}function f0(e,t){var n;const s=t.fetchFunc==null?P().platform.fetch:t.fetchFunc;let r=0,a;return(n=t.onProgress)===null||n===void 0||n.call(t,0),new ReadableStream({pull:async o=>{for(var i;r<e.length;){a||(a=(await s(e[r],t.requestInit,{isBinary:!0})).body.getReader());const{done:u,value:c}=await a.read();if(u){r++,a=void 0,(i=t.onProgress)===null||i===void 0||i.call(t,r/e.length);continue}o.enqueue(c);return}o.close()}})}async function d0(e,t="",n,s){return ip(o=>op(o,{requestInit:s}))(e,t,n)}function ip(e){return async(t,n="",s)=>{const r=t.map(()=>!1),a={},o=s!=null?s.map(()=>!1):[],i=[];if(t.forEach((m,S)=>{let T=0;m.weights.forEach(N=>{const E="quantization"in N?N.quantization.dtype:N.dtype,O=Se[E]*q(N.shape),$=()=>{r[S]=!0,a[S]==null&&(a[S]=[]),a[S].push({manifestEntry:N,groupOffset:T,sizeBytes:O})};s!=null?s.forEach((I,D)=>{I===N.name&&($(),o[D]=!0)}):$(),i.push(N.name),T+=O})}),!o.every(m=>m)){const m=s.filter((S,T)=>!o[T]);throw new Error(`Could not find weights in manifest with names: ${m.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}const u=r.reduce((m,S,T)=>(S&&m.push(T),m),[]),c=[];u.forEach(m=>{t[m].paths.forEach(S=>{const T=n+(n.endsWith("/")?"":"/")+S;c.push(T)})});const l=await e(c),h={};let f=0;return u.forEach(m=>{const S=t[m].paths.length,T=new Ft(l.slice(f,f+S));a[m].forEach(E=>{const O=T.slice(E.groupOffset,E.groupOffset+E.sizeBytes),$=wc(O,[E.manifestEntry]);for(const I in $)h[I]=$[I]}),f+=S}),h}}const m0="application/octet-stream",g0="application/json";class aa{constructor(t,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(g(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=P().platform.fetch,g(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&g(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{},this.loadOptions=n}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],r=Tc(t,s);if(n.body.append("model.json",new Blob([JSON.stringify(r)],{type:g0}),"model.json"),t.weightData!=null){const o=Ft.join(t.weightData);n.body.append("model.weights.bin",new Blob([o],{type:m0}),"model.weights.bin")}const a=await this.fetch(this.path,n);if(a.ok)return{modelArtifactsInfo:bn(t),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async loadModelJSON(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await t.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const s=n.modelTopology,r=n.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return n}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const t=await this.loadModelJSON();return pr(t,n=>this.loadWeights(n))}async loadStream(){const t=await this.loadModelJSON(),n=await this.getWeightUrls(t.weightsManifest),s=Wn(t.weightsManifest),r=()=>f0(n,this.loadOptions);return Object.assign(Object.assign({},t),{weightSpecs:s,getWeightStream:r})}async getWeightUrls(t){const n=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=y0(n),a=this.weightPathPrefix||s,o=[],i=[];for(const u of t)for(const c of u.paths)this.weightUrlConverter!=null?i.push(this.weightUrlConverter(c)):o.push(a+c+r);return this.weightUrlConverter&&o.push(...await Promise.all(i)),o}async loadWeights(t){const n=await this.getWeightUrls(t),s=Wn(t),r=await op(n,this.loadOptions);return[s,r]}}aa.URL_SCHEME_REGEX=/^https?:\/\//;function y0(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),s=e.substring(0,t),r=n>t?e.substring(n):"";return[s+"/",r]}function zs(e){return e.match(aa.URL_SCHEME_REGEX)!=null}const up=(e,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(s=>zs(s)):n=zs(e),n)return oa(e,t)}return null};Q.registerSaveRouter(up);Q.registerLoadRouter(up);function oa(e,t){return new aa(e,t)}function b0(e,t){return oa(e,t)}class bs{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class cp{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class w0{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=n=>Promise.resolve(t.save(n)))}}function N0(e,t,n,s){const r=arguments;return new w0(Gn(...r))}function Gn(e,t,n,s){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new bs(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new bs({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new bs({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:s}))}function S0(e){return new cp(e)}function T0(e){return new cp(e)}const ia=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Ft,browserFiles:p0,browserHTTPRequest:b0,concatenateArrayBuffers:vd,copyModel:Hd,decodeWeights:wc,decodeWeightsStream:Sc,encodeWeights:wd,fromMemory:N0,fromMemorySync:Gn,getLoadHandlers:Cd,getModelArtifactsForJSON:pr,getModelArtifactsForJSONSync:hr,getModelArtifactsInfoForJSON:bn,getSaveHandlers:Dd,getWeightSpecs:Wn,http:oa,isHTTPScheme:zs,listModels:qd,loadWeights:d0,moveModel:Kd,registerLoadRouter:Od,registerSaveRouter:xd,removeModel:Gd,weightsLoaderFactory:ip,withSaveHandler:S0,withSaveHandlerSync:T0},Symbol.toStringTag,{value:"Module"}));function E0(e,t,n){const s=d(e,"labels","confusionMatrix"),r=d(t,"predictions","confusionMatrix");g(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),g(s.rank===1,()=>`Expected the rank of labels to be 1, but got ${s.rank}`),g(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),g(s.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${s.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),g(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);const a=qn(Z(s,"int32"),n),o=qn(Z(r,"int32"),n),i=fn(a),u=U(i,o);return Z(u,"int32")}const $0=b({confusionMatrix_:E0});const v0=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:$0},Symbol.toStringTag,{value:"Module"}));let pe,Va=!1;function lp(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,s=!1,r=!1,a=!1,o=!1,i=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&e instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement)a=!0;else if(e.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&e instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(en(Ss,w.backendName)!=null){const S={pixels:e},T={numChannels:t};return w.runKernel(Ss,S,T)}const[c,l]=r?[e.videoWidth,e.videoHeight]:[e.width,e.height];let h;if(o)h=e.getContext("2d").getImageData(0,0,c,l).data;else if(s||n)h=e.data;else if(a||r||i){if(pe==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")pe=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else pe=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});pe.canvas.width=c,pe.canvas.height=l,pe.drawImage(e,0,0,c,l),h=pe.getImageData(0,0,c,l).data}let f;if(t===4)f=new Int32Array(h);else{const S=c*l;f=new Int32Array(S*t);for(let T=0;T<S;T++)for(let N=0;N<t;++N)f[T*t+N]=h[T*4+N]}return Kr(f,[l,c,t],"int32")}function k0(e){return e!=null&&e.data instanceof Uint8Array}function _0(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function I0(e){return e!=null&&e.width!==0&&e.height!==0}function A0(e){return _0()&&!(e instanceof ImageBitmap)&&I0(e)&&!k0(e)}async function x0(e,t=3){let n=null;if(P().getBool("WRAP_TO_IMAGEBITMAP")&&A0(e)){let s;try{s=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch{s=null}s!=null&&s.width===e.width&&s.height===e.height?n=s:n=e}else n=e;return lp(n,t)}function hp(e){if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);const t=e.rank===2?1:e.shape[2];if(t>4||t===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}function O0(e){const t=e?.alpha||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}async function D0(e,t){let n=d(e,"img","toPixels");if(!(e instanceof nt)){const c=n;n=Z(c,"int32"),c.dispose()}hp(n);const[s,r]=n.shape.slice(0,2),a=n.rank===2?1:n.shape[2],o=await n.data(),i=n.dtype==="float32"?255:1,u=new Uint8ClampedArray(r*s*4);for(let c=0;c<s*r;++c){const l=[0,0,0,255];for(let f=0;f<a;f++){const m=o[c*a+f];if(n.dtype==="float32"){if(m<0||m>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${m}.`)}else if(n.dtype==="int32"&&(m<0||m>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${m}.`);a===1?(l[0]=m*i,l[1]=m*i,l[2]=m*i):l[f]=m*i}const h=c*4;u[h+0]=Math.round(l[0]),u[h+1]=Math.round(l[1]),u[h+2]=Math.round(l[2]),u[h+3]=Math.round(l[3])}if(t!=null){Va||en(rr,w.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),Va=!0),t.width=r,t.height=s;const c=t.getContext("2d"),l=new ImageData(u,r,s);c.putImageData(l,0,0)}return n!==e&&n.dispose(),u}function C0(e,t,n){let s=d(e,"img","draw");if(!(e instanceof nt)){const o=s;s=Z(o,"int32"),o.dispose()}hp(s),O0(n?.imageOptions);const r={image:s},a={canvas:t,options:n};w.runKernel(rr,r,a)}const R0=b({fromPixels_:lp}),F0=Object.freeze(Object.defineProperty({__proto__:null,draw:C0,fromPixels:R0,fromPixelsAsync:x0,toPixels:D0},Symbol.toStringTag,{value:"Module"}));function pp(e,t){const n=e.shape.length,s=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[s-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[s-1]} vs. ${n}`);if(q(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const r=t.shape,a=r[r.length-1];let o=1;for(let h=0;h<r.length-1;++h)o*=r[h];const i=e.shape,u=r.slice();u.pop();let c=1;for(let h=a;h<n;++h)c*=i[h],u.push(i[h]);const l=[...Ue(e.shape).map(h=>h/c),1].slice(0,a);return[u,o,c,l]}const L0=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:pp},Symbol.toStringTag,{value:"Module"}));const Vs=-2,B0=-1;function P0(e,t,n){const s=e.shape.length;g(s===t.length,()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`),g(s===n.length,()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)g(t[r]+n[r]<=e.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${t[r]+n[r]}) would overflow input.shape[${r}] (${e.shape[r]})`)}function z0(e){const t=[];let n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function V0(e,t,n){const s=[];for(let r=0;r<e.length;r++)s[r]=Math.ceil((t[r]-e[r])/n[r]);return s}function fp(e,t,n,s){const r=[...e];for(let a=r.length;a<s.length;a++)r.push(1);for(let a=0;a<n;a++)a===0?r[t]=1:(r.splice(t,0,1),r.pop());return r}function dp(e,t,n){return n<=e?n:n-(t-1)}function mp(e,t){const n=[];for(let s=0;s<e;s++)n.push(t+s);return n}function W0(e,t,n,s,r,a,o,i,u){const c=e.length;let l=new Array(c),h=new Array(c),f=new Array(c);if(t.length&&n>0){const m=t[0],S=n+1;l=gp(o,m,S,s,e),h=yp(i,m,S,r,e),f=fp(a,m,S,e)}else for(let m=0;m<c;m++)l[m]=wp(o,s,a,e,m,u),h[m]=Np(i,r,a,e,m,u),f[m]=bp(a,m,u);return{begin:l,end:h,strides:f}}function gp(e,t,n,s,r){const a=[...r],o=mp(n,t);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=0;else{const u=dp(t,n,i);let c=s[u];e&1<<u&&(c=0),a[i]=c}return a}function yp(e,t,n,s,r){const a=[...r],o=mp(n,t);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=Number.MAX_SAFE_INTEGER;else{const u=dp(t,n,i);let c=s[u];e&1<<u&&(c=Number.MAX_SAFE_INTEGER),a[i]=c}for(let i=0;i<a.length;i++){const u=r[i];a[i]<0&&(a[i]+=u),a[i]=Qe(0,a[i],r[i])}return a}function bp(e,t,n){let s=e[t];return(n&1<<t||s==null)&&(s=1),s}function wp(e,t,n,s,r,a){let o=t[r];const i=n[r]||1;(e&1<<r||a&1<<r||o==null)&&(i>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const u=s[r];return o<0&&(o+=u),o=Qe(0,o,u-1),o}function Np(e,t,n,s,r,a){let o=t[r];const i=n[r]||1;(e&1<<r||a&1<<r||o==null)&&(i>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const u=s[r];return o<0&&(o+=u),i>0?o=Qe(0,o,u):o=Qe(-1,o,u-1),o}function M0(e,t,n){let s=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){s=r;break}for(let r=s+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function U0(e,t){let n=e.length>0?e[e.length-1]:1;for(let s=0;s<e.length-1;s++)n+=e[s]*t[s];return n}function j0(e,t,n){let s;const r=e.shape.length;typeof t=="number"?s=[t,...new Array(r-1).fill(0)]:t.length<r?s=t.concat(new Array(r-t.length).fill(0)):s=t.slice(),s.forEach(o=>{g(o!==-1,()=>"slice() does not support negative begin indexing.")});let a;return n==null?a=new Array(r).fill(-1):typeof n=="number"?a=[n,...new Array(r-1).fill(-1)]:n.length<r?a=n.concat(new Array(r-n.length).fill(-1)):a=n,a=a.map((o,i)=>o>=0?o:(g(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${i}.`),e.shape[i]-s[i])),[s,a]}function q0(e,t,n,s,r,a,o,i,u){let c;if(s==null?(c=new Array(t.length),c.fill(1)):c=s,o!=null&&(o&o-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let l=!1;const h={dims:c.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:c.slice(),beginMask:r,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};for(let $=0;$<h.dims;$++)l&&(1<<$&i)!==0&&h.numAddAxisAfterEllipsis++,1<<$&o&&(l=!0);l||(h.ellipsisMask|=1<<h.dims,h.dims++);const f={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};G0(h,f);let m=!0,S=!0,T=!0;const N=[],E=[];for(let $=0;$<e.length;++$){if(f.strides[$]===0)throw Error(`strides[${$}] must be non-zero`);const I=!!(f.shrinkAxisMask&1<<$),D=e[$];if(D===-1){N.push(I?1:-1);continue}const x=[f.beginMask&1<<$,f.endMask&1<<$],F=[f.strides[$]>0?0:-1,f.strides[$]>0?D:D-1];if(I&&f.strides[$]<=0)throw Error("only stride 1 allowed on non-range indexing.");T=T&&f.strides[$]===1;const R=!!(f.beginMask&1<<$&&f.endMask&1<<$);if(f.beginValid&&f.endValid){if(I){const A=f.begin[$]<0?D+f.begin[$]:f.begin[$];if(f.begin[$]=A,f.end[$]=f.begin[$]+1,A<0||A>=D)throw Error(`slice index ${f.begin[$]} of dimension ${$} out of bounds.`)}else f.begin[$]=Wa(f.begin[$],0,f.strides[$],D,x,F),f.end[$]=Wa(f.end[$],1,f.strides[$],D,x,F);const y=f.strides[$]===1&&f.begin[$]===0&&f.end[$]===D;m=m&&y,S=S&&($===0&&f.strides[$]===1||y)}else m=m&&f.strides[$]===1&&R,S=S&&($===0&&f.strides[$]===1||R);let k,v=!1;if(f.beginValid&&f.endValid?(k=f.end[$]-f.begin[$],v=!0):I?(k=1,v=!0):R&&D>=0&&(f.strides[$]<0?k=-D:k=D,v=!0),v){let y;k===0||k<0!=f.strides[$]<0?y=0:y=Math.trunc(k/f.strides[$])+(k%f.strides[$]!==0?1:0),N.push(y)}else N.push(-1)}for(let $=0;$<f.finalShapeGatherIndices.length;++$){const I=f.finalShapeGatherIndices[$];I>=0?E.push(N[I]):I===Vs&&E.push(1)}return{finalShapeSparse:E.filter(($,I)=>f.finalShapeGatherIndices[I]!==Vs),finalShape:E,isIdentity:m,sliceDim0:S,isSimpleSlice:T,begin:f.begin,end:f.end,strides:f.strides}}function G0(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let s=0;s<e.dims;s++)if(1<<s&e.ellipsisMask){const r=Math.min(t.dims-(e.dims-s)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=s}else if(1<<s&e.newAxisMask)t.finalShapeGatherIndices.push(Vs),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[s]),e.end!=null&&(t.end[n]=e.end[s]),t.strides[n]=e.strides[s],e.beginMask&1<<s&&(t.beginMask|=1<<n),e.endMask&1<<s&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<s?(t.finalShapeGatherIndices.push(B0),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(s)),t.inputShapeGatherIndicesSparse[n]=s,n++}}function Wa(e,t,n,s,r,a){if(r[t])return n>0?a[t]:a[t+1&1];{const o=e<0?s+e:e;return o<a[0]?a[0]:o>a[1]?a[1]:o}}const Sp=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:P0,computeFlatOffset:U0,computeOutShape:V0,getNormalizedAxes:W0,isSliceContinous:M0,maskToAxes:z0,parseSliceParams:j0,sliceInfo:q0,startForAxis:wp,startIndicesWithElidedDims:gp,stopForAxis:Np,stopIndicesWithElidedDims:yp,stridesForAxis:bp,stridesWithElidedDims:fp},Symbol.toStringTag,{value:"Module"}));const H0="4.22.0";class Tp{static sgd(t){return new ps(t)}static momentum(t,n,s=!1){return new sa(t,n,s)}static rmsprop(t,n=.9,s=0,r=null,a=!1){return new ra(t,n,s,r,a)}static adam(t=.001,n=.9,s=.999,r=null){return new ea(t,n,s,r)}static adadelta(t=.001,n=.95,s=null){return new Qr(t,n,s)}static adamax(t=.002,n=.9,s=.999,r=null,a=0){return new na(t,n,s,r,a)}static adagrad(t,n=.1){return new ta(t,n)}}const K0=Tp;const X0=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:e=>e();function Z0(){return new Promise(e=>X0(()=>e()))}function J0(e,t){const n=e[0].length;e.forEach((r,a)=>{g(r.length===n,()=>`Error in concat${n}D: rank of tensors[${a}] must be the same as the rank of the rest (${n})`)}),g(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const s=e[0];e.forEach((r,a)=>{for(let o=0;o<n;o++)g(o===t||r[o]===s[o],()=>`Error in concat${n}D: Shape of tensors[${a}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${a}.`)})}function Y0(e,t){const n=e[0].slice();for(let s=1;s<e.length;s++)n[t]+=e[s][t];return n}var Lt;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(Lt||(Lt={}));function Q0(e,t,n){let s=new Array;if(n==null&&t==null)return s;if(t==null)for(;s.length<e+n.length;)s.push(-1);else s=t.slice();if(n==null)return s;if(e+n.length!==s.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${s.length}`);for(let r=1;r<n.length;++r){const a=n[r],o=s[s.length-n.length+r],i=s[o];if(a>=0)if(i>=0){if(i!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${r+e}] = ${a} but shape[${r+e}] = ${i}`)}else s[o]=a}return s}function tN(e){const t={FIRST_DIM_SIZE:Lt.FIRST_DIM_SIZE,VALUE_ROWIDS:Lt.VALUE_ROWIDS,ROW_LENGTHS:Lt.ROW_LENGTHS,ROW_SPLITS:Lt.ROW_SPLITS,ROW_LIMITS:Lt.ROW_LIMITS,ROW_STARTS:Lt.ROW_STARTS},n=[];for(const s of e)if(s in t)n.push(t[s]);else break;return n}function eN(e){return e.length===0?0:e[0]===Lt.FIRST_DIM_SIZE?e.length-1:e.length}function nN(e,t){if(e==null||t==null)return;const n=e.length,s=t.length;if(n>=s)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(n,s-1);++r){const a=e[r],o=t[r+1];if(a>=0&&o>=0&&a!==1&&a!==o)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${r-e.length}] = ${a} but ragged tensor input.flatValues.shape[${r-e.length}] = ${o}`)}}const ua=30;function sN(e){return e<=ua?e:Bn(e,Math.floor(Math.sqrt(e)))}function rN(e,t,n){const s=n*(typeof e=="number"?e:e[0]),r=t*(typeof e=="number"?e:e[1]);return[s,r]}function aN(e,t,n,s=!0){let r=[];if(s)r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);const a=t.length;for(let o=0;o<a;++o)r=r.concat([e[o+1]/t[o],t[o]]);r=r.concat(e.slice(a+1))}return r}function oN(e,t,n=!0){const s=[];if(n){s.push(t);for(let r=t+1;r<e;++r)r<=2*t?(s.push(r),s.push(r-(t+1))):s.push(r)}else{const r=[],a=[];for(let o=1;o<e;++o)o>=t*2+1||o%2===1?a.push(o):r.push(o);s.push(...r),s.push(0),s.push(...a)}return s}function iN(e,t,n,s=!0){const r=[];s?r.push(e[0]/n):r.push(e[0]*n);for(let a=1;a<e.length;++a)a<=t.length?s?r.push(t[a-1]*e[a]):r.push(e[a]/t[a-1]):r.push(e[a]);return r}function uN(e,t){const n=[0];for(let s=0;s<t;++s)n.push(e[s][0]);return n}function cN(e,t,n){const s=e.slice(0,1);for(let r=0;r<n;++r)s.push(e[r+1]-t[r][0]-t[r][1]);return s}const lN=1.7580993408473768,hN=1.0507009873554805;const pN=.3275911,fN=.254829592,dN=-.284496736,mN=1.421413741,gN=-1.453152027,yN=1.061405429;function bN(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(e.length*2);for(let s=0;s<n.length;s+=2)n[s]=e[s/2],n[s+1]=t[s/2];return n}function wN(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let s=0;s<e.length;s+=2)t[s/2]=e[s],n[s/2]=e[s+1];return{real:t,imag:n}}function NN(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),s=new Float32Array(t);for(let r=0;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],s[Math.floor(r/4)]=e[r+1];return{real:n,imag:s}}function SN(e){const t=Math.floor(e.length/4),n=new Float32Array(t),s=new Float32Array(t);for(let r=2;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],s[Math.floor(r/4)]=e[r+1];return{real:n,imag:s}}function TN(e,t){const n=e[t*2],s=e[t*2+1];return{real:n,imag:s}}function EN(e,t,n,s){e[s*2]=t,e[s*2+1]=n}function $N(e,t){const n=new Float32Array(e/2),s=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){const a=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(a),s[r]=Math.sin(a)}return{real:n,imag:s}}function vN(e,t,n){const s=(n?2:-2)*Math.PI*(e/t),r=Math.cos(s),a=Math.sin(s);return{real:r,imag:a}}const ws="->",kN=/->/g,Ma=",",Ua="...";function _N(e,t){e=e.replace(/\s/g,"");const n=(e.length-e.replace(kN,"").length)/ws.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${ws}").`);const[s,r]=e.split(ws);g(s.indexOf(Ua)===-1,()=>`The ellipsis notation ("${Ua}") is not supported yet.`);const a=s.split(Ma),o=a.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let f=0;f<r.length;++f){const m=r[f];if(!a.some(S=>S.indexOf(m)!==-1))throw new Error(`Output subscripts contain the label ${m} not present in the input subscripts.`);i.indexOf(m)===-1&&i.push(m)}for(let f=0;f<s.length;++f){const m=s[f];i.indexOf(m)===-1&&m!==Ma&&i.push(m)}const u=new Array(a.length);for(let f=0;f<o;++f){if(new Set(a[f].split("")).size!==a[f].length)throw new Error(`Found duplicate axes in input component ${a[f]}. Support for duplicate axes in input is not implemented yet.`);u[f]=[];for(let m=0;m<a[f].length;++m)u[f].push(i.indexOf(a[f][m]))}const c=i.length,l=r.length,h=[];for(let f=l;f<c;++f)h.push(f);return{allDims:i,summedDims:h,idDims:u}}function IN(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r)n[t[r]]=r;const s=[];for(let r=0;r<e;++r)n[r]===-1&&s.push(r);return n=n.filter(r=>r!==-1),{permutationIndices:n,expandDims:s}}function AN(e,t,n){const s=new Array(e);for(let r=0;r<n.length;++r){const a=n[r].shape;for(let o=0;o<t[r].length;++o)s[t[r][o]]===void 0?s[t[r][o]]=a[o]:g(s[t[r][o]]===a[o],()=>`Expected dimension ${s[t[r][o]]} at axis ${o} of input shaped ${JSON.stringify(a)}, but got dimension ${a[o]}`)}}function xN(e,t){const n=e,s=[];let r=0;e.length===0&&n.push(-1),r=e.length+1;for(let o=0;o<r;++o)s.push([]);const a=[];for(let o=0;o<n.length;++o){const i=n[o],u=DN(t,i);for(const c of u)a.indexOf(c)===-1&&(s[o].push(c),a.push(c))}return{path:n,steps:s}}function ON(e){return e.every((t,n)=>t===n)}function DN(e,t){const n=[];for(let s=0;s<e.length;++s)(e[s].length===0||e[s].indexOf(t)!==-1||t===-1)&&n.push(s);return n}function CN(e,t,n=0){let s=[];if(typeof t=="number")g(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),s=new Array(t).fill(e.shape[n]/t);else{const r=t.reduce((o,i)=>(i===-1&&(o+=1),o),0);g(r<=1,()=>"There should be only one negative value in split array.");const a=t.indexOf(-1);if(a!==-1){const o=t.reduce((i,u)=>u>0?i+u:i);t[a]=e.shape[n]-o}g(e.shape[n]===t.reduce((o,i)=>o+i),()=>"The sum of sizes must match the size of the axis dimension."),s=t}return s}function RN(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function FN(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function LN(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function BN(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function PN(e,t){return`size ${e} must be non-negative, not ${t}`}function zN(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function VN(e,t){const n=q(e),s=q(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${e} outputShape= ${t}`}function WN(e,t){const n=q(e),s=q(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${s}. inputShape=${e} outputShape=${t}`}function MN(){return"segment ids must be >= 0"}function UN(){return"segment ids are not increasing"}function jN(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function qN(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function GN(e,t){let n=!1,s;for(e<=ua?(s=e,n=!0):s=Bn(e,Math.floor(Math.sqrt(e)));!n;)s>t||s===e?n=!0:s=Bn(e,s+1);return s}function HN(e,t,n){const s=[],r=e.length;for(let a=0;a<r;a++)a!==t?s.push(e[a]):s.push(n);return s}function KN(e,t,n,s){const r=t.shape.length,a=e.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>a)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${a}).`);if(n<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${n}).`);for(let h=0;h<s;++h)if(e.shape[h]!==t.shape[h])throw new Error(`x.shape[${h}]: ${e.shape[h]} should be equal to indices.shape[${h}]: ${t.shape[h]}.`);const o=e.shape[n],i=[];let u=1,c=1,l=1;for(let h=0;h<s;++h)i.push(e.shape[h]),u*=e.shape[h];for(let h=s;h<n;h++)i.push(e.shape[h]),c*=e.shape[h];for(let h=s;h<r;h++)i.push(t.shape[h]);for(let h=n+1;h<a;h++)i.push(e.shape[h]),l*=e.shape[h];return{batchSize:u,sliceSize:l,outerSize:c,dimSize:o,outputShape:i}}const XN=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:KN,computeOutShape:HN,segOpComputeOptimalWindowSize:GN},Symbol.toStringTag,{value:"Module"}));function ZN(e){try{return e.map(t=>zn(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function JN(e){return e.map(t=>yn(t))}const YN=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:fN,ERF_A2:dN,ERF_A3:mN,ERF_A4:gN,ERF_A5:yN,ERF_P:pN,PARALLELIZE_THRESHOLD:ua,get RowPartitionType(){return Lt},SELU_SCALE:hN,SELU_SCALEALPHA:lN,applyActivation:ls,assertAndGetBroadcastShape:rt,assertAxesAreInnerMostDims:Eg,assertParamsConsistent:J0,assignToTypedArray:EN,axesAreInnerMostDims:Tr,calculateShapes:Ah,checkEinsumDimSizes:AN,checkPadOnDimRoundingMode:At,combineLocations:Tl,combineRaggedTensorToTensorShapes:Q0,complexWithEvenIndex:NN,complexWithOddIndex:SN,computeConv2DInfo:wn,computeConv3DInfo:Uc,computeDefaultPad:mr,computeDilation2DInfo:bm,computeOptimalWindowSize:sN,computeOutAndReduceShapes:Tg,computeOutShape:Y0,computePool2DInfo:Mc,computePool3DInfo:wm,convertConv2DDataFormat:jc,decodeEinsumEquation:_N,eitherStridesOrDilationsAreOne:Xt,expandShapeToKeepDim:Tn,exponent:vN,exponents:$N,fromStringArrayToUint8:JN,fromUint8ToStringArray:ZN,getAxesPermutation:$g,getBroadcastDims:yl,getComplexWithIndex:TN,getEinsumComputePath:xN,getEinsumPermutation:IN,getFusedBiasGradient:cs,getFusedDyActivation:us,getImageCenter:rN,getInnerMostAxes:kg,getPermuted:oN,getRaggedRank:eN,getReductionAxes:wr,getReshaped:aN,getReshapedPermuted:iN,getRowPartitionTypesHelper:tN,getSliceBeginCoords:uN,getSliceSize:cN,getSparseFillEmptyRowsIndicesDenseShapeMismatch:RN,getSparseFillEmptyRowsNegativeIndexErrorMessage:FN,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:LN,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:zN,getSparseReshapeInputOutputMismatchErrorMessage:WN,getSparseReshapeInputOutputMultipleErrorMessage:VN,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:BN,getSparseReshapeNegativeOutputDimErrorMessage:PN,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:qN,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:MN,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:UN,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:jN,getUndoAxesPermutation:vg,isIdentityPermutation:ON,log:wf,mergeRealAndImagArrays:bN,prepareAndValidate:pp,prepareSplitSize:CN,segment_util:XN,shouldFuse:hs,slice_util:Sp,splitRealAndImagArrays:wN,stridesOrDilationsArePositive:$e,tupleValuesAreOne:un,upcastType:Jn,validateDefaultValueShape:nN,validateInput:os,validateUpdateShape:Xr,warn:Jt},Symbol.toStringTag,{value:"Module"}));const QN=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:Kh,nonMaxSuppressionV4Impl:Xh,nonMaxSuppressionV5Impl:Zh,whereImpl:Bh},Symbol.toStringTag,{value:"Module"}));a0();const _T=Object.freeze(Object.defineProperty({__proto__:null,Abs:po,Acos:fo,Acosh:mo,AdadeltaOptimizer:Qr,AdagradOptimizer:ta,AdamOptimizer:ea,AdamaxOptimizer:na,Add:nr,AddN:go,All:yo,Any:bo,ArgMax:wo,ArgMin:No,Asin:So,Asinh:To,Atan:Eo,Atan2:vo,Atanh:$o,AvgPool:ko,AvgPool3D:_o,AvgPool3DGrad:tf,AvgPoolGrad:Qp,BatchMatMul:Io,BatchToSpaceND:Ao,Bincount:xo,BitwiseAnd:Oo,BroadcastArgs:Do,BroadcastTo:ef,Cast:sr,Ceil:Co,ClipByValue:Ro,Complex:Fo,ComplexAbs:Lo,Concat:Bo,Conv2D:Po,Conv2DBackpropFilter:zo,Conv2DBackpropInput:Vo,Conv3D:Wo,Conv3DBackpropFilterV2:nf,Conv3DBackpropInputV2:Mo,Cos:Uo,Cosh:jo,CropAndResize:Ho,Cumprod:qo,Cumsum:Go,DataStorage:Op,DenseBincount:Ko,DepthToSpace:Xo,DepthwiseConv2dNative:Zo,DepthwiseConv2dNativeBackpropFilter:Jo,DepthwiseConv2dNativeBackpropInput:Yo,Diag:Qo,Dilation2D:ti,Dilation2DBackpropFilter:rf,Dilation2DBackpropInput:sf,Draw:rr,get ENV(){return tr},Einsum:ni,Elu:si,EluGrad:af,Environment:lo,Equal:ai,Erf:ri,Exp:oi,ExpandDims:ii,Expm1:ui,FFT:ci,Fill:li,FlipLeftRight:hi,Floor:pi,FloorDiv:fi,FromPixels:Ss,FusedBatchNorm:di,FusedConv2D:Es,FusedDepthwiseConv2D:$s,GatherNd:gi,GatherV2:mi,Greater:yi,GreaterEqual:bi,IFFT:wi,Identity:ar,Imag:Ni,IsFinite:Si,IsInf:Ti,IsNan:Ei,KernelBackend:Qa,LRN:Ci,LRNGrad:lf,LeakyRelu:$i,Less:vi,LessEqual:ki,LinSpace:_i,Log:Ii,Log1p:Ai,LogSoftmax:uf,LogicalAnd:xi,LogicalNot:Oi,LogicalOr:Di,LogicalXor:of,LowerBound:cf,MatrixBandPart:hf,Max:Ri,MaxPool:Li,MaxPool3D:Bi,MaxPool3DGrad:ff,MaxPoolGrad:pf,MaxPoolWithArgmax:Pi,Maximum:Fi,Mean:zi,Min:Vi,Minimum:Wi,MirrorPad:Mi,Mod:Ui,MomentumOptimizer:sa,Multinomial:ji,Multiply:qi,Neg:Gi,NonMaxSuppressionV3:Ki,NonMaxSuppressionV4:Xi,NonMaxSuppressionV5:Zi,NotEqual:Hi,OP_SCOPE_SUFFIX:cr,OneHot:Yi,OnesLike:Ji,Optimizer:he,OptimizerConstructors:Tp,Pack:Qi,PadV2:tu,Pool:df,Pow:eu,Prelu:nu,Prod:su,RMSPropOptimizer:ra,RaggedGather:ru,RaggedRange:au,RaggedTensorToTensor:ou,Range:iu,get Rank(){return _s},Real:uu,RealDiv:ei,Reciprocal:cu,get Reduction(){return dt},Relu:lu,Relu6:du,Reshape:hu,ResizeBilinear:fu,ResizeBilinearGrad:gf,ResizeNearestNeighbor:pu,ResizeNearestNeighborGrad:mf,Reverse:mu,RotateWithOffset:ec,Round:gu,Rsqrt:yu,SGDOptimizer:ps,ScatterNd:bu,SearchSorted:Nu,Select:Su,Selu:Tu,Sigmoid:_u,Sign:ku,Sin:$u,Sinh:vu,Slice:Eu,Softmax:Cu,Softplus:Iu,SpaceToBatchND:Ou,SparseFillEmptyRows:Ru,SparseReshape:Fu,SparseSegmentMean:Lu,SparseSegmentSum:Bu,SparseToDense:Pu,SplitV:Du,Sqrt:Au,Square:yf,SquaredDifference:zu,StaticRegexReplace:Vu,Step:tc,StridedSlice:Wu,StringNGrams:Mu,StringSplit:Uu,StringToHashBucketFast:ju,Sub:qu,Sum:xu,Tan:Gu,Tanh:Hu,Tensor:nt,TensorBuffer:Vn,TensorScatterUpdate:wu,Tile:or,TopK:Ku,Transform:Xu,Transpose:On,Unique:Zu,Unpack:Ju,UnsortedSegmentSum:Yu,UpperBound:bf,Variable:sn,ZerosLike:Qu,_FusedMatMul:Ts,abs:St,acos:xc,acosh:Oc,add:B,addN:Dc,all:Cc,any:Rc,argMax:Fc,argMin:Lc,asin:Bc,asinh:Pc,atan:zc,atan2:Vc,atanh:Wc,avgPool:gr,avgPool3d:qc,backend:bc,backend_util:YN,basicLSTMCell:Gc,batchNorm:Nn,batchNorm2d:Hc,batchNorm3d:Kc,batchNorm4d:Xc,batchToSpaceND:yr,bincount:br,bitwiseAnd:Zc,booleanMaskAsync:Ph,broadcastArgs:Jc,broadcastTo:Ye,broadcast_util:pg,browser:F0,buffer:Pt,cast:Z,ceil:Yc,clipByValue:Qc,clone:Gt,complex:Kt,concat:ht,concat1d:tl,concat2d:el,concat3d:nl,concat4d:sl,conv1d:rl,conv2d:Sn,conv2dTranspose:ol,conv3d:il,conv3dTranspose:ul,copyRegisteredKernels:Ef,cos:cl,cosh:ll,cosineWindow:is,cumprod:hl,cumsum:pl,customGrad:Vt,denseBincount:fl,deprecationWarn:od,depthToSpace:dl,depthwiseConv2d:Yn,device_util:td,diag:ml,dilation2d:gl,disableDeprecationWarnings:ad,dispose:mt,disposeVariables:id,div:X,divNoNan:bl,dot:wl,dropout:Uh,einsum:me,elu:Sr,enableDebugMode:rd,enableProdMode:sd,enclosingPowerOfTwo:Jr,engine:ud,ensureShape:Nl,env:P,equal:Nr,erf:Sl,euclideanNorm:$l,exp:ie,expandDims:Mt,expm1:vl,eye:Er,fft:ss,fill:je,findBackend:md,findBackendFactory:gd,floor:$r,floorDiv:dr,fused:qh,gather:vr,gatherND:Mh,gather_util:L0,getBackend:yc,getGradient:vs,getKernel:en,getKernelsForBackend:Pn,grad:ty,grads:ey,greater:$n,greaterEqual:kr,ifft:pn,imag:vn,image:Qh,inTopKAsync:jh,io:ia,irfft:qr,isFinite:kl,isInf:_l,isNaN:Il,keep:Ot,kernel_impls:QN,leakyRelu:_r,less:jn,lessEqual:Qn,linalg:tp,linspace:Al,localResponseNormalization:xl,log:ze,log1p:Ir,logSigmoid:Dl,logSoftmax:Cl,logSumExp:xr,logicalAnd:cn,logicalNot:Or,logicalOr:Dr,logicalXor:Rl,losses:ep,lowerBound:Fl,matMul:U,math:v0,max:Ne,maxPool:Cr,maxPool3d:Ll,maxPoolWithArgmax:Bl,maximum:Rr,mean:ln,memory:cd,meshgrid:Pl,min:Un,minimum:hn,mirrorPad:zl,mod:Vl,moments:Wl,movingAverage:zh,mul:C,multiRNNCell:Ml,multinomial:Ul,neg:Ct,nextFrame:Z0,norm:En,notEqual:Fr,oneHot:qn,ones:ee,onesLike:jl,op:b,outerProduct:ql,pad:qe,pad1d:Gl,pad2d:Hl,pad3d:Kl,pad4d:Xl,pool:Zl,pow:Pe,prelu:Br,print:fr,prod:Jl,profile:ld,raggedGather:Yl,raggedRange:Ql,raggedTensorToTensor:th,rand:eh,randomGamma:rh,randomNormal:Mr,randomStandardNormal:ah,randomUniform:ns,randomUniformInt:oh,range:Ve,ready:fd,real:We,reciprocal:ih,registerBackend:yd,registerGradient:Nf,registerKernel:nc,relu:kn,relu6:Ur,removeBackend:dd,reshape:_,reverse:ue,reverse1d:uh,reverse2d:ch,reverse3d:lh,reverse4d:hh,rfft:rs,round:jr,rsqrt:ph,scalar:M,scatterND:Vh,scatter_util:Xb,searchSorted:es,selu:fh,separableConv2d:dh,serialization:s0,setBackend:pd,setPlatform:bd,setdiff1dAsync:mh,sigmoid:we,sign:gh,signal:Yh,sin:yh,sinh:bh,slice:G,slice1d:wh,slice2d:Nh,slice3d:Sh,slice4d:Th,slice_util:Sp,softmax:Eh,softplus:Ar,spaceToBatchND:Lr,sparse:np,sparseToDense:Wh,spectral:Jh,split:Me,sqrt:zt,square:It,squaredDifference:Gr,squeeze:as,stack:Wt,step:Hr,stridedSlice:$h,string:sp,sub:W,sum:K,sumOutType:qf,tan:vh,tanh:Mn,tensor:Dt,tensor1d:vt,tensor2d:Re,tensor3d:Kr,tensor4d:kh,tensor5d:_h,tensor6d:Ih,tensorScatterUpdate:xh,tensor_util:Kf,test_util:ub,tidy:j,tile:Ce,time:hd,topk:Oh,train:K0,transpose:fn,truncatedNormal:Dh,unique:Ch,unregisterGradient:Tf,unregisterKernel:Sf,unsortedSegmentSum:Rh,unstack:le,upcastType:Jn,upperBound:Fh,util:Rf,valueAndGrad:ny,valueAndGrads:sy,variable:Lh,variableGrads:Ol,version_core:H0,where:Ht,whereAsync:Zr,zeros:ve,zerosLike:Tt},Symbol.toStringTag,{value:"Module"}));const tS=P();tS.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var wt;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(wt||(wt={}));var ja;(function(e){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(ja||(ja={}));const ca={};function IT(e,t){const n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};ca[e]=n}function Ep(e){return ca[e]}function AT(e){delete ca[e]}function p(e,t,n,s,r){const a=t.inputParams[e];if(a&&a.inputIndexStart!==void 0){const i=a.inputIndexStart,u=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?i+1:a.inputIndexEnd,c=i<0?t.inputNames.length+i:i;if(a.type==="tensor")return ct(t.inputNames[c],n,s,r);if(a.type==="tensors"){const f=t.inputs.slice(i,u);return t.inputNames.slice(i,u).filter((S,T)=>{var N;return((N=f[T])===null||N===void 0?void 0:N.op)!=="NoOp"}).map(S=>ct(S,n,s,r))}const l=ct(t.inputNames[c],n,s,r),h=l.dataSync();return a.type==="number"?h[0]:be(l.shape,h)}const o=t.attrParams[e];return o&&o.value}function ct(e,t,n,s){const[r,a]=Nt(e,n);if(s!=null){const i=s.getHashTableHandleByName(r);if(i!=null)return i}const o=n.currentContextIds.find(i=>!!t[Hn(r,i)]);return o!==void 0?t[Hn(r,o)][a]:void 0}function qa(e,t,n){return t[Hn(e,n.currentContextId)]}function Ut(e,t){const[n,s,r]=Nt(e,t);return[Hn(n,t&&t.currentContextId),s,r]}function Hn(e,t){return t?`${e}-${t}`:e}function Nt(e,t){if(e==="")return["",0,void 0];const n=t!=null&&t.parseNodeNameCache!=null;if(n){const a=t.parseNodeNameCache.get(e);if(a!=null)return a}const s=e.split(":");let r;if(s.length===1)r=[e,0,void 0];else{const a=s[0],o=s.length===3?s[1]:void 0,i=Number(s[s.length-1]);r=[a,i,o]}return n&&t.parseNodeNameCache.set(e,r),r}function Rn(e,t,n){let s=p("pad",e,t,n);if(s==="explicit"){s=p("explicitPaddings",e,t,n);const r=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)r[a][0]=s[a*2],r[a][1]=s[a*2+1];return r}return s}function jt(e){return e.kept?e:Gt(e)}const eS=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],nS=Object.freeze(Object.defineProperty({__proto__:null,json:eS},Symbol.toStringTag,{value:"Module"}));const sS=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],rS=Object.freeze(Object.defineProperty({__proto__:null,json:sS},Symbol.toStringTag,{value:"Module"}));const aS=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],oS=Object.freeze(Object.defineProperty({__proto__:null,json:aS},Symbol.toStringTag,{value:"Module"}));const iS=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],uS=Object.freeze(Object.defineProperty({__proto__:null,json:iS},Symbol.toStringTag,{value:"Module"}));const cS=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],lS=Object.freeze(Object.defineProperty({__proto__:null,json:cS},Symbol.toStringTag,{value:"Module"}));const hS=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],pS=Object.freeze(Object.defineProperty({__proto__:null,json:hS},Symbol.toStringTag,{value:"Module"}));const fS=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],dS=Object.freeze(Object.defineProperty({__proto__:null,json:fS},Symbol.toStringTag,{value:"Module"}));const mS=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],gS=Object.freeze(Object.defineProperty({__proto__:null,json:mS},Symbol.toStringTag,{value:"Module"}));const yS=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],bS=Object.freeze(Object.defineProperty({__proto__:null,json:yS},Symbol.toStringTag,{value:"Module"}));const wS=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],NS=Object.freeze(Object.defineProperty({__proto__:null,json:wS},Symbol.toStringTag,{value:"Module"}));const SS=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],TS=Object.freeze(Object.defineProperty({__proto__:null,json:SS},Symbol.toStringTag,{value:"Module"}));const ES=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],$S=Object.freeze(Object.defineProperty({__proto__:null,json:ES},Symbol.toStringTag,{value:"Module"}));const vS=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],kS=Object.freeze(Object.defineProperty({__proto__:null,json:vS},Symbol.toStringTag,{value:"Module"}));const _S=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],IS=Object.freeze(Object.defineProperty({__proto__:null,json:_S},Symbol.toStringTag,{value:"Module"}));const AS=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],xS=Object.freeze(Object.defineProperty({__proto__:null,json:AS},Symbol.toStringTag,{value:"Module"}));const OS=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],DS=Object.freeze(Object.defineProperty({__proto__:null,json:OS},Symbol.toStringTag,{value:"Module"}));const CS=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],RS=Object.freeze(Object.defineProperty({__proto__:null,json:CS},Symbol.toStringTag,{value:"Module"}));const FS=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],LS=Object.freeze(Object.defineProperty({__proto__:null,json:FS},Symbol.toStringTag,{value:"Module"}));const BS=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],PS=Object.freeze(Object.defineProperty({__proto__:null,json:BS},Symbol.toStringTag,{value:"Module"}));class Ga{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[nS,rS,oS,uS,lS,pS,dS,gS,bS,NS,TS,$S,kS,IS,xS,DS,RS,LS,PS],n=[].concat(...t.map(s=>s.json));this.opMappers=n.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(t,n={}){const s=t.node,r=[],a=[],o=[],i=s.reduce((T,N)=>(T[N.name]=this.mapNode(N),N.op.startsWith("Placeholder")?r.push(T[N.name]):N.op==="Const"?a.push(T[N.name]):(N.input==null||N.input.length===0)&&o.push(T[N.name]),T),{});let u=[];const c=[];let l={},h={};n!=null&&(l=this.mapSignatureEntries(n.inputs),h=this.mapSignatureEntries(n.outputs));const f=Object.keys(i);f.forEach(T=>{const N=i[T];N.inputNames.forEach((E,O)=>{const[$,,I]=Ut(E),D=i[$];if(D.outputs!=null){const x=D.outputs.indexOf(I);if(x!==-1){const F=`${$}:${x}`;N.inputNames[O]=F}}N.inputs.push(D),D.children.push(N)})}),Object.keys(h).length===0?f.forEach(T=>{const N=i[T];N.children.length===0&&c.push(N)}):Object.keys(h).forEach(T=>{const[N]=Ut(T),E=i[N];E!=null&&(E.signatureKey=h[T],c.push(E))}),Object.keys(l).length>0?Object.keys(l).forEach(T=>{const[N]=Ut(T),E=i[N];E&&(E.signatureKey=l[T],u.push(E))}):u=r;let m={};t.library!=null&&t.library.function!=null&&(m=t.library.function.reduce((T,N)=>(T[N.signature.name]=this.mapFunction(N),T),{}));const S={nodes:i,inputs:u,outputs:c,weights:a,placeholders:r,signature:n,functions:m};return o.length>0&&(S.initNodes=o),S}mapSignatureEntries(t){return Object.keys(t||{}).reduce((n,s)=>(n[t[s].name]=s,n),{})}mapNode(t){const n=Ep(t.op)||this.opMappers[t.op]||{};t.attr==null&&(t.attr={});const s={name:t.name,op:t.op,category:n.category,inputNames:(t.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:n.outputs};return n.inputs!=null&&(s.inputParams=n.inputs.reduce((r,a)=>(r[a.name]={type:a.type,inputIndexStart:a.start,inputIndexEnd:a.end},r),{})),n.attrs!=null&&(s.attrParams=n.attrs.reduce((r,a)=>{const o=a.type;let i;switch(a.type){case"string":i=Ws(t.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Ws(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":i=Ks(t.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Ks(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":i=Us(t.attr,a.tfName,a.defaultValue||0),i===void 0&&a.tfDeprecatedName&&(i=Us(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":i=Hs(t.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Hs(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":i=Ms(t.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Ms(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":i=Zs(t.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Zs(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":i=Gs(t.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Gs(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":i=Xs(t.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Xs(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":i=js(t.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=js(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":i=qs(t.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=qs(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":i=Ha(t.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Ha(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${t.op}`)}return r[a.name]={value:i,type:o},r},{})),s}mapFunction(t){const n=t.nodeDef,s=[],r=[];let a={};n!=null&&(a=n.reduce((h,f)=>(h[f.name]=this.mapNode(f),f.op==="Const"&&r.push(h[f.name]),h),{}));const o=[],i=[];t.signature.inputArg.forEach(h=>{const[f]=Ut(h.name),m={name:f,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:la(h.type),type:"dtype"}},children:[]};m.signatureKey=h.name,o.push(m),a[f]=m}),Object.keys(a).forEach(h=>{const f=a[h];f.inputNames.forEach((m,S)=>{const[T,,N]=Ut(m),E=a[T];if(E.outputs!=null){const O=E.outputs.indexOf(N);if(O!==-1){const $=`${T}:${O}`;f.inputNames[S]=$}}f.inputs.push(E),E.children.push(f)})});const c=t.ret;t.signature.outputArg.forEach(h=>{const[f,m]=Ut(c[h.name]),S=a[f];S!=null&&(S.defaultOutput=m,i.push(S))});const l=this.mapArgsToSignature(t);return{nodes:a,inputs:o,outputs:i,weights:r,placeholders:s,signature:l}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((n,s)=>(n[s.name]=this.mapArgToTensorInfo(s),n),{}),outputs:t.signature.outputArg.reduce((n,s)=>(n[s.name]=this.mapArgToTensorInfo(s,t.ret),n),{})}}mapArgToTensorInfo(t,n){let s=t.name;return n!=null&&(s=n[s]),{name:s,dtype:t.type}}}function zS(e){const t=P().global;if(typeof t.atob<"u")return t.atob(e);if(typeof Buffer<"u")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function $p(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):zS(e);return t?n:n.toLowerCase()}function Ws(e,t,n,s=!1){const r=e[t];return r!=null?$p(r.s,s):n}function Ms(e,t,n){const s=e[t];return s?s.b:n}function Us(e,t,n){const s=e[t]||{},r=s.i!=null?s.i:s.f!=null?s.f:n;return typeof r=="number"?r:parseInt(r,10)}function la(e){switch(typeof e=="string"&&(e=wt[e]),e){case wt.DT_FLOAT:case wt.DT_HALF:return"float32";case wt.DT_INT32:case wt.DT_INT64:case wt.DT_INT8:case wt.DT_UINT8:return"int32";case wt.DT_BOOL:return"bool";case wt.DT_DOUBLE:return"float32";case wt.DT_STRING:return"string";case wt.DT_COMPLEX64:case wt.DT_COMPLEX128:return"complex64";default:return null}}function Ha(e,t,n){const s=e[t];return s&&s.func?s.func.name:n}function js(e,t,n){const s=e[t];return s&&s.type?la(s.type):n}function qs(e,t,n){const s=e[t];return s&&s.list&&s.list.type?s.list.type.map(r=>la(r)):n}function vp(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function Gs(e,t,n){const s=e[t];return s&&s.shape?vp(s.shape):n}function Hs(e,t,n){const s=e[t];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):n}function Ks(e,t,n,s=!1){const r=e[t];return r&&r.list&&r.list.s?r.list.s.map(a=>$p(a,s)):n}function Xs(e,t,n){const s=e[t];return s&&s.list&&s.list.shape?s.list.shape.map(r=>vp(r)):n}function Zs(e,t,n){const s=e[t];return s&&s.list&&s.list.b?s.list.b:n}class VS{constructor(t,n,s){this.node=t,this.tensorMap=n,this.context=s,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(r=>this.getInput(r)),t.rawAttrs!=null&&(this.attrs=Object.keys(t.rawAttrs).reduce((r,a)=>(r[a]=this.getAttr(a),r),{}))}getInput(t){return ct(t,this.tensorMap,this.context)}getAttr(t,n){const s=this.node.rawAttrs[t];if(s.tensor!=null)return ct(t,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return Us(this.node.rawAttrs,t,n);if(s.s!=null)return Ws(this.node.rawAttrs,t,n);if(s.b!=null)return Ms(this.node.rawAttrs,t,n);if(s.shape!=null)return Gs(this.node.rawAttrs,t,n);if(s.type!=null)return js(this.node.rawAttrs,t,n);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return Hs(this.node.rawAttrs,t,n);if(s.list.s!=null)return Ks(this.node.rawAttrs,t,n);if(s.list.shape!=null)return Xs(this.node.rawAttrs,t,n);if(s.list.b!=null)return Zs(this.node.rawAttrs,t,n);if(s.list.type!=null)return qs(this.node.rawAttrs,t,n)}return n}}const lt=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:cr,abs:St,acos:xc,acosh:Oc,add:B,addN:Dc,all:Cc,any:Rc,argMax:Fc,argMin:Lc,asin:Bc,asinh:Pc,atan:zc,atan2:Vc,atanh:Wc,avgPool:gr,avgPool3d:qc,basicLSTMCell:Gc,batchNorm:Nn,batchNorm2d:Hc,batchNorm3d:Kc,batchNorm4d:Xc,batchToSpaceND:yr,bincount:br,bitwiseAnd:Zc,booleanMaskAsync:Ph,broadcastArgs:Jc,broadcastTo:Ye,buffer:Pt,cast:Z,ceil:Yc,clipByValue:Qc,clone:Gt,complex:Kt,concat:ht,concat1d:tl,concat2d:el,concat3d:nl,concat4d:sl,conv1d:rl,conv2d:Sn,conv2dTranspose:ol,conv3d:il,conv3dTranspose:ul,cos:cl,cosh:ll,cosineWindow:is,cumprod:hl,cumsum:pl,denseBincount:fl,depthToSpace:dl,depthwiseConv2d:Yn,diag:ml,dilation2d:gl,div:X,divNoNan:bl,dot:wl,dropout:Uh,einsum:me,elu:Sr,enclosingPowerOfTwo:Jr,ensureShape:Nl,equal:Nr,erf:Sl,euclideanNorm:$l,exp:ie,expandDims:Mt,expm1:vl,eye:Er,fft:ss,fill:je,floor:$r,floorDiv:dr,fused:qh,gather:vr,gatherND:Mh,greater:$n,greaterEqual:kr,ifft:pn,imag:vn,image:Qh,inTopKAsync:jh,irfft:qr,isFinite:kl,isInf:_l,isNaN:Il,leakyRelu:_r,less:jn,lessEqual:Qn,linalg:tp,linspace:Al,localResponseNormalization:xl,log:ze,log1p:Ir,logSigmoid:Dl,logSoftmax:Cl,logSumExp:xr,logicalAnd:cn,logicalNot:Or,logicalOr:Dr,logicalXor:Rl,losses:ep,lowerBound:Fl,matMul:U,max:Ne,maxPool:Cr,maxPool3d:Ll,maxPoolWithArgmax:Bl,maximum:Rr,mean:ln,meshgrid:Pl,min:Un,minimum:hn,mirrorPad:zl,mod:Vl,moments:Wl,movingAverage:zh,mul:C,multiRNNCell:Ml,multinomial:Ul,neg:Ct,norm:En,notEqual:Fr,oneHot:qn,ones:ee,onesLike:jl,op:b,outerProduct:ql,pad:qe,pad1d:Gl,pad2d:Hl,pad3d:Kl,pad4d:Xl,pool:Zl,pow:Pe,prelu:Br,print:fr,prod:Jl,raggedGather:Yl,raggedRange:Ql,raggedTensorToTensor:th,rand:eh,randomGamma:rh,randomNormal:Mr,randomStandardNormal:ah,randomUniform:ns,randomUniformInt:oh,range:Ve,real:We,reciprocal:ih,relu:kn,relu6:Ur,reshape:_,reverse:ue,reverse1d:uh,reverse2d:ch,reverse3d:lh,reverse4d:hh,rfft:rs,round:jr,rsqrt:ph,scalar:M,scatterND:Vh,searchSorted:es,selu:fh,separableConv2d:dh,setdiff1dAsync:mh,sigmoid:we,sign:gh,signal:Yh,sin:yh,sinh:bh,slice:G,slice1d:wh,slice2d:Nh,slice3d:Sh,slice4d:Th,softmax:Eh,softplus:Ar,spaceToBatchND:Lr,sparse:np,sparseToDense:Wh,spectral:Jh,split:Me,sqrt:zt,square:It,squaredDifference:Gr,squeeze:as,stack:Wt,step:Hr,stridedSlice:$h,string:sp,sub:W,sum:K,tan:vh,tanh:Mn,tensor:Dt,tensor1d:vt,tensor2d:Re,tensor3d:Kr,tensor4d:kh,tensor5d:_h,tensor6d:Ih,tensorScatterUpdate:xh,tile:Ce,topk:Oh,transpose:fn,truncatedNormal:Dh,unique:Ch,unsortedSegmentSum:Rh,unstack:le,upperBound:Fh,variable:Lh,where:Ht,whereAsync:Zr,zeros:ve,zerosLike:Tt},Symbol.toStringTag,{value:"Module"}));const WS=(e,t,n,s=lt)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(p("a",e,t,n),p("b",e,t,n))];case"AddN":return[s.addN(p("tensors",e,t,n))];case"FloorMod":case"Mod":return[s.mod(p("a",e,t,n),p("b",e,t,n))];case"Mul":return[s.mul(p("a",e,t,n),p("b",e,t,n))];case"RealDiv":case"Div":return[s.div(p("a",e,t,n),p("b",e,t,n))];case"DivNoNan":return[s.divNoNan(p("a",e,t,n),p("b",e,t,n))];case"FloorDiv":return[s.floorDiv(p("a",e,t,n),p("b",e,t,n))];case"Sub":return[s.sub(p("a",e,t,n),p("b",e,t,n))];case"Minimum":return[s.minimum(p("a",e,t,n),p("b",e,t,n))];case"Maximum":return[s.maximum(p("a",e,t,n),p("b",e,t,n))];case"Pow":return[s.pow(p("a",e,t,n),p("b",e,t,n))];case"SquaredDifference":return[s.squaredDifference(p("a",e,t,n),p("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};const MS=(e,t,n,s=lt)=>{switch(e.op){case"Abs":case"ComplexAbs":return[s.abs(p("x",e,t,n))];case"Acos":return[s.acos(p("x",e,t,n))];case"Acosh":return[s.acosh(p("x",e,t,n))];case"Asin":return[s.asin(p("x",e,t,n))];case"Asinh":return[s.asinh(p("x",e,t,n))];case"Atan":return[s.atan(p("x",e,t,n))];case"Atan2":return[s.atan2(p("x",e,t,n),p("y",e,t,n))];case"Atanh":return[s.atanh(p("x",e,t,n))];case"Ceil":return[s.ceil(p("x",e,t,n))];case"Complex":return[s.complex(p("real",e,t,n),p("imag",e,t,n))];case"Cos":return[s.cos(p("x",e,t,n))];case"Cosh":return[s.cosh(p("x",e,t,n))];case"Elu":return[s.elu(p("x",e,t,n))];case"Erf":return[s.erf(p("x",e,t,n))];case"Exp":return[s.exp(p("x",e,t,n))];case"Expm1":return[s.expm1(p("x",e,t,n))];case"Floor":return[s.floor(p("x",e,t,n))];case"Log":return[s.log(p("x",e,t,n))];case"Log1p":return[s.log1p(p("x",e,t,n))];case"Imag":return[s.imag(p("x",e,t,n))];case"Neg":return[s.neg(p("x",e,t,n))];case"Reciprocal":return[s.reciprocal(p("x",e,t,n))];case"Real":return[s.real(p("x",e,t,n))];case"Relu":return[s.relu(p("x",e,t,n))];case"Round":return[s.round(p("x",e,t,n))];case"Selu":return[s.selu(p("x",e,t,n))];case"Sigmoid":return[s.sigmoid(p("x",e,t,n))];case"Sin":return[s.sin(p("x",e,t,n))];case"Sign":return[s.sign(p("x",e,t,n))];case"Sinh":return[s.sinh(p("x",e,t,n))];case"Softplus":return[s.softplus(p("x",e,t,n))];case"Sqrt":return[s.sqrt(p("x",e,t,n))];case"Square":return[s.square(p("x",e,t,n))];case"Tanh":return[s.tanh(p("x",e,t,n))];case"Tan":return[s.tan(p("x",e,t,n))];case"ClipByValue":return[s.clipByValue(p("x",e,t,n),p("clipValueMin",e,t,n),p("clipValueMax",e,t,n))];case"Relu6":return[s.relu6(p("x",e,t,n))];case"Rsqrt":return[s.rsqrt(ct(e.inputNames[0],t,n))];case"LeakyRelu":return[s.leakyRelu(p("x",e,t,n),p("alpha",e,t,n))];case"Prelu":return[s.prelu(p("x",e,t,n),p("alpha",e,t,n))];case"IsNan":return[s.isNaN(ct(e.inputNames[0],t,n))];case"IsInf":return[s.isInf(ct(e.inputNames[0],t,n))];case"IsFinite":return[s.isFinite(ct(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function _t(e,t,n=""){if(!(typeof e=="number"||typeof t=="number")){g(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let s=0;s<e.length;s++){const r=e[s],a=t[s];g(r<0||a<0||r===a,()=>n+` Shapes ${e} and ${t} must match`)}}}function Ka(e){return!(typeof e=="number"||e.some(t=>t<0))}function Ke(e,t,n){let s=Js(e,n);const r=!Ka(s);if(r&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&t.forEach(a=>{s=Js(a.shape,s)}),!Ka(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function Js(e,t){if(typeof e=="number")return t;if(typeof t=="number")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let s=0;s<e.length;++s){const r=e[s],a=t[s];if(r>=0&&a>=0&&r!==a)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[s]=r>=0?r:a}return n}class US{constructor(t,n,s,r,a,o,i){this.name=t,this.dtype=n,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=o,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=M(0),Ot(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.tensor.id))&&n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const n=this.tensors[t];if(n.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(t){return t.map(n=>this.read(n))}write(t,n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[t]||{};if(n.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=n.shape),_t(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);s.tensor=n,Ot(n),s.written=!0,this.tensors[t]=s}writeMany(t,n){if(t.length!==n.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${n.length}.`);t.forEach((s,r)=>this.write(s,n[r]))}gather(t,n){if(n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);if(t)t=t.slice(0,this.size());else{t=[];for(let r=0;r<this.size();r++)t.push(r)}if(t.length===0)return Dt([],[0].concat(this.elementShape));const s=this.readMany(t);return _t(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),Wt(s,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(this.size()===0)return Dt([],[0].concat(this.elementShape));const n=[];for(let r=0;r<this.size();r++)n.push(r);const s=this.readMany(n);return _t(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),ht(s,0)}scatter(t,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);const s=Math.max(...t);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(t,le(n,0))}split(t,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);let s=0;const r=t.map(u=>(s+=u,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const a=s===0?0:n.size/s,o=[];j(()=>{n=_(n,[1,s,a]);for(let u=0;u<t.length;++u){const l=[0,u===0?0:r[u-1],0],h=[1,t[u],a];o[u]=_(G(n,l,h),this.elementShape)}return o});const i=[];for(let u=0;u<t.length;u++)i[u]=u;this.writeMany(i,o)}}class _e{get id(){return this.idTensor.id}constructor(t,n,s,r=-1){this.tensors=t,this.elementShape=n,this.elementDtype=s,t?.forEach(a=>{if(s!==a.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${a.dtype}`);_t(n,a.shape,"TensorList shape mismatch: "),Ot(a)}),this.idTensor=M(0),this.maxNumElements=r,Ot(this.idTensor)}copy(){return new _e([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,s=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);_t(t,this.elementShape,"TensorList shape mismatch: ");const r=Ke(this.elementShape,this.tensors,t);return j(()=>{const a=this.tensors.map(o=>_(o,r));return Wt(a,0)})}popBack(t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=Ke(this.elementShape,this.tensors,t),r=this.tensors.pop();return r.kept=!1,_t(r.shape,t,"TensorList shape mismatch: "),_(r,s)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(_t(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Ot(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const n=new _e([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let s=0;s<Math.min(this.tensors.length,t);++s)n.tensors[s]=this.tensors[s];return n}getItem(t,n,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);_t(this.tensors[t].shape,n,"TensorList shape mismatch: ");const r=Ke(this.elementShape,this.tensors,n);return _(this.tensors[t],r)}setItem(t,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);_t(this.elementShape,n.shape,"TensorList shape mismatch: "),Ot(n),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=n}gather(t,n,s){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);_t(this.elementShape,s,"TensorList shape mismatch: "),t=t.slice(0,this.size());const r=Ke(this.elementShape,this.tensors,s);return t.length===0?Dt([],[0].concat(r)):j(()=>{const a=t.map(o=>_(this.tensors[o],r));return Wt(a,0)})}concat(t,n){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);_t(this.elementShape,n,"TensorList shape mismatch: ");const s=Ke(this.elementShape,this.tensors,n);return this.size()===0?Dt([],[0].concat(s)):j(()=>{const r=this.tensors.map(a=>_(a,s));return ht(r,0)})}}function jS(e,t,n){const s=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);const r=e.shape.slice(1);_t(r,t,"TensorList shape mismatch: ");const a=le(e);return new _e(a,t,s)}function qS(e,t,n,s){return new _e([],e,t,s)}function GS(e,t,n,s){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const r=Math.max(...t);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const a=new _e([],n,e.dtype,s),o=le(e,0);return t.forEach((i,u)=>{a.setItem(i,o[u])}),a}function HS(e,t,n){let s=0;const r=t.map(l=>(s+=l,s));if(s!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${e.shape}`);const a=e.shape.slice(1),o=Js(a,n),i=s===0?0:e.size/s,u=j(()=>{const l=[];e=_(e,[1,s,i]);for(let h=0;h<t.length;++h){const m=[0,h===0?0:r[h-1],0],S=[1,t[h],i];l[h]=_(G(e,m,S),o)}return e.dispose(),l}),c=new _e([],n,e.dtype,t.length);for(let l=0;l<u.length;l++)c.setItem(l,u[l]);return c}const KS=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const s=p("thenBranch",e,t,n),r=p("elseBranch",e,t,n),a=p("cond",e,t,n),o=p("args",e,t,n);return(await a.data())[0]?n.functionMap[s].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const s=p("body",e,t,n),r=p("cond",e,t,n),a=p("args",e,t,n),o=await n.functionMap[r].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),i=a.map(l=>l.id);let u=await o[0].data();o.forEach(l=>{!l.kept&&i.indexOf(l.id)===-1&&l.dispose()});let c=a;for(;u[0];){const l=c;c=await n.functionMap[s].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);const h=c.map(m=>m.id);l.forEach(m=>{!m.kept&&i.indexOf(m.id)===-1&&h.indexOf(m.id)===-1&&m.dispose()});const f=await n.functionMap[r].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);u=await f[0].data(),f.forEach(m=>{!m.kept&&i.indexOf(m.id)===-1&&h.indexOf(m.id)===-1&&m.dispose()})}return c}case"LoopCond":{const s=p("pred",e,t,n);return[jt(s)]}case"Switch":{const s=p("pred",e,t,n);let r=p("data",e,t,n);return r.kept||(r=jt(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=e.inputNames.find(r=>ct(r,t,n)!==void 0);if(s){const r=ct(s,t,n);return[jt(r)]}return}case"Enter":{const s=p("frameName",e,t,n),r=p("tensor",e,t,n);return n.enterFrame(s),[jt(r)]}case"Exit":{const s=p("tensor",e,t,n);return n.exitFrame(),[jt(s)]}case"NextIteration":{const s=p("tensor",e,t,n);return n.nextIteration(),[jt(s)]}case"TensorArrayV3":{const s=p("size",e,t,n),r=p("dtype",e,t,n),a=p("elementShape",e,t,n),o=p("dynamicSize",e,t,n),i=p("clearAfterRead",e,t,n),u=p("identicalElementShapes",e,t,n),c=p("name",e,t,n),l=new US(c,r,s,a,u,o,i);return n.addTensorArray(l),[l.idTensor,M(1)]}case"TensorArrayWriteV3":{const s=p("tensorArrayId",e,t,n),r=p("index",e,t,n),a=p("tensor",e,t,n),o=n.getTensorArray(s.id);return o.write(r,a),[o.idTensor]}case"TensorArrayReadV3":{const s=p("tensorArrayId",e,t,n),r=p("index",e,t,n);return[n.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=p("tensorArrayId",e,t,n),r=p("indices",e,t,n),a=p("dtype",e,t,n);return[n.getTensorArray(s.id).gather(r,a)]}case"TensorArrayScatterV3":{const s=p("tensorArrayId",e,t,n),r=p("indices",e,t,n),a=p("tensor",e,t,n),o=n.getTensorArray(s.id);return o.scatter(r,a),[o.idTensor]}case"TensorArrayConcatV3":{const s=p("tensorArrayId",e,t,n),r=n.getTensorArray(s.id),a=p("dtype",e,t,n);return[r.concat(a)]}case"TensorArraySplitV3":{const s=p("tensorArrayId",e,t,n),r=p("tensor",e,t,n),a=p("lengths",e,t,n),o=n.getTensorArray(s.id);return o.split(a,r),[o.idTensor]}case"TensorArraySizeV3":{const s=p("tensorArrayId",e,t,n),r=n.getTensorArray(s.id);return[M(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=p("tensorArrayId",e,t,n),r=n.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=p("tensorListId",e,t,n),r=p("index",e,t,n),a=p("tensor",e,t,n),o=n.getTensorList(s.id);return o.setItem(r,a),[o.idTensor]}case"TensorListGetItem":{const s=p("tensorListId",e,t,n),r=p("index",e,t,n),a=p("elementShape",e,t,n),o=p("elementDType",e,t,n);return[n.getTensorList(s.id).getItem(r,a,o)]}case"TensorListScatterV2":case"TensorListScatter":{const s=p("indices",e,t,n),r=p("tensor",e,t,n),a=p("elementShape",e,t,n),o=p("numElements",e,t,n),i=GS(r,s,a,o);return n.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=p("elementShape",e,t,n),r=p("elementDType",e,t,n);let a;e.op==="TensorListReserve"?a="numElements":a="maxNumElements";const o=p(a,e,t,n),i=e.op==="TensorListReserve"?-1:o,u=qS(s,r,o,i);return n.addTensorList(u),[u.idTensor]}case"TensorListGather":{const s=p("tensorListId",e,t,n),r=p("indices",e,t,n),a=p("elementShape",e,t,n),o=p("elementDType",e,t,n);return[n.getTensorList(s.id).gather(r,o,a)]}case"TensorListStack":{const s=p("tensorListId",e,t,n),r=p("elementShape",e,t,n),a=p("elementDType",e,t,n),o=p("numElements",e,t,n);return[n.getTensorList(s.id).stack(r,a,o)]}case"TensorListFromTensor":{const s=p("tensor",e,t,n),r=p("elementShape",e,t,n),a=p("elementDType",e,t,n),o=jS(s,r,a);return n.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=p("tensorListId",e,t,n),r=n.getTensorList(s.id),a=p("dtype",e,t,n),o=p("elementShape",e,t,n);return[r.concat(a,o)]}case"TensorListPushBack":{const s=p("tensorListId",e,t,n),r=p("tensor",e,t,n),a=n.getTensorList(s.id);return a.pushBack(r),[a.idTensor]}case"TensorListPopBack":{const s=p("tensorListId",e,t,n),r=p("elementShape",e,t,n),a=p("elementDType",e,t,n);return[n.getTensorList(s.id).popBack(r,a)]}case"TensorListSplit":{const s=p("tensor",e,t,n),r=p("elementShape",e,t,n),a=p("lengths",e,t,n),o=HS(s,a,r);return n.addTensorList(o),[o.idTensor]}case"TensorListLength":{const s=p("tensorListId",e,t,n),r=n.getTensorList(s.id);return[M(r.size(),"int32")]}case"TensorListResize":{const s=p("tensorListId",e,t,n),r=p("size",e,t,n),o=n.getTensorList(s.id).resize(r);return n.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Xa(e,t,n){const[s,r]=p("fusedOps",e,t,n),a=s==="biasadd",o=!a,i=r==="prelu",u=s==="fusedbatchnorm",c=p("numArgs",e,t,n);if(a){if(i&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&a&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const l=p("strides",e,t,n),h=Rn(e,t,n),f=p("dataFormat",e,t,n).toUpperCase(),m=p("dilations",e,t,n);let[S,T]=p("args",e,t,n);o&&(T=S,S=void 0);const N=p("leakyreluAlpha",e,t,n);return{stride:l,pad:h,dataFormat:f,dilations:m,biasArg:S,preluArg:T,activationFunc:r,leakyreluAlpha:N}}const XS=(e,t,n,s=lt)=>{switch(e.op){case"Conv1D":{const r=p("stride",e,t,n),a=p("pad",e,t,n),o=p("dataFormat",e,t,n).toUpperCase(),i=p("dilation",e,t,n);return[s.conv1d(p("x",e,t,n),p("filter",e,t,n),r,a,o,i)]}case"Conv2D":{const r=p("strides",e,t,n),a=Rn(e,t,n),o=p("dataFormat",e,t,n).toUpperCase(),i=p("dilations",e,t,n);return[s.conv2d(p("x",e,t,n),p("filter",e,t,n),[r[1],r[2]],a,o,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:r,pad:a,dataFormat:o,dilations:i,biasArg:u,preluArg:c,activationFunc:l,leakyreluAlpha:h}=Xa(e,t,n);return[s.fused.conv2d({x:p("x",e,t,n),filter:p("filter",e,t,n),strides:[r[1],r[2]],pad:a,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:l,preluActivationWeights:c,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:a,dataFormat:o,dilations:i,biasArg:u,preluArg:c,activationFunc:l,leakyreluAlpha:h}=Xa(e,t,n);return[s.fused.depthwiseConv2d({x:p("x",e,t,n),filter:p("filter",e,t,n),strides:[r[1],r[2]],pad:a,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:l,preluActivationWeights:c,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=p("outputShape",e,t,n),a=p("strides",e,t,n),o=Rn(e,t,n);return[s.conv2dTranspose(p("x",e,t,n),p("filter",e,t,n),r,[a[1],a[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=p("strides",e,t,n),a=Rn(e,t,n),o=p("dilations",e,t,n),i=p("dataFormat",e,t,n).toUpperCase();return[s.depthwiseConv2d(p("input",e,t,n),p("filter",e,t,n),[r[1],r[2]],a,i,[o[1],o[2]])]}case"Conv3D":{const r=p("strides",e,t,n),a=p("pad",e,t,n),o=p("dataFormat",e,t,n).toUpperCase(),i=p("dilations",e,t,n);return[s.conv3d(p("x",e,t,n),p("filter",e,t,n),[r[1],r[2],r[3]],a,o,[i[1],i[2],i[3]])]}case"AvgPool":{const r=p("strides",e,t,n),a=p("pad",e,t,n),o=p("kernelSize",e,t,n);return[s.avgPool(p("x",e,t,n),[o[1],o[2]],[r[1],r[2]],a)]}case"MaxPool":{const r=p("strides",e,t,n),a=p("pad",e,t,n),o=p("kernelSize",e,t,n);return[s.maxPool(p("x",e,t,n),[o[1],o[2]],[r[1],r[2]],a)]}case"MaxPoolWithArgmax":{const r=p("strides",e,t,n),a=p("pad",e,t,n),o=p("kernelSize",e,t,n),i=p("includeBatchInIndex",e,t,n),{result:u,indexes:c}=s.maxPoolWithArgmax(p("x",e,t,n),[o[1],o[2]],[r[1],r[2]],a,i);return[u,c]}case"AvgPool3D":{const r=p("strides",e,t,n),a=p("pad",e,t,n),o=p("kernelSize",e,t,n);return[s.avgPool3d(p("x",e,t,n),[o[1],o[2],o[3]],[r[1],r[2],r[3]],a)]}case"MaxPool3D":{const r=p("strides",e,t,n),a=p("pad",e,t,n),o=p("kernelSize",e,t,n);return[s.maxPool3d(p("x",e,t,n),[o[1],o[2],o[3]],[r[1],r[2],r[3]],a)]}case"Dilation2D":{const r=p("strides",e,t,n),a=p("pad",e,t,n),o=p("dilations",e,t,n),i=r[1],u=r[2],c=o[1],l=o[2];return[s.dilation2d(p("x",e,t,n),p("filter",e,t,n),[i,u],a,[c,l],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const ZS=(e,t,n,s=lt)=>{switch(e.op){case"Fill":{const r=p("shape",e,t,n),a=p("dtype",e,t,n),o=p("value",e,t,n);return[s.fill(r,o,a)]}case"LinSpace":{const r=p("start",e,t,n),a=p("stop",e,t,n),o=p("num",e,t,n);return[s.linspace(r,a,o)]}case"Multinomial":{const r=p("logits",e,t,n),a=p("numSamples",e,t,n),o=p("seed",e,t,n);return[s.multinomial(r,a,o)]}case"OneHot":{const r=p("indices",e,t,n),a=p("depth",e,t,n),o=p("onValue",e,t,n),i=p("offValue",e,t,n),u=p("dtype",e,t,n);return[s.oneHot(r,a,o,i,u)]}case"Ones":return[s.ones(p("shape",e,t,n),p("dtype",e,t,n))];case"OnesLike":return[s.onesLike(p("x",e,t,n))];case"RandomStandardNormal":return[s.randomStandardNormal(p("shape",e,t,n),p("dtype",e,t,n),p("seed",e,t,n))];case"RandomUniform":return[s.randomUniform(p("shape",e,t,n),p("minval",e,t,n),p("maxval",e,t,n),p("dtype",e,t,n))];case"RandomUniformInt":return[s.randomUniformInt(p("shape",e,t,n),p("minval",e,t,n),p("maxval",e,t,n),p("seed",e,t,n))];case"Range":{const r=p("start",e,t,n),a=p("stop",e,t,n),o=p("step",e,t,n);return[s.range(r,a,o,p("dtype",e,t,n))]}case"TruncatedNormal":{const r=p("shape",e,t,n),a=p("mean",e,t,n),o=p("stdDev",e,t,n),i=p("seed",e,t,n);return[s.truncatedNormal(r,a,o,p("dtype",e,t,n),i)]}case"Zeros":return[s.zeros(p("shape",e,t,n),p("dtype",e,t,n))];case"ZerosLike":return[s.zerosLike(p("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Ns(e,t,n){const s=p("boxes",e,t,n),r=p("scores",e,t,n),a=p("maxOutputSize",e,t,n),o=p("iouThreshold",e,t,n),i=p("scoreThreshold",e,t,n),u=p("softNmsSigma",e,t,n);return{boxes:s,scores:r,maxOutputSize:a,iouThreshold:o,scoreThreshold:i,softNmsSigma:u}}const JS=async(e,t,n,s,r=lt)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:c,softNmsSigma:l}=Ns(e,t,n),h=await r.image.nonMaxSuppressionWithScoreAsync(a,o,i,u,c,l);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:c}=Ns(e,t,n),l=p("padToMaxOutputSize",e,t,n),h=await r.image.nonMaxSuppressionPaddedAsync(a,o,i,u,c,l);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:c}=Ns(e,t,n);return[await r.image.nonMaxSuppressionAsync(a,o,i,u,c)]}case"Where":{const a=r.cast(p("condition",e,t,n),"bool"),o=[await r.whereAsync(a)];return a.dispose(),o}case"ListDiff":return r.setdiff1dAsync(p("x",e,t,n),p("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}};const YS=(e,t,n,s=lt)=>{switch(e.op){case"LowerBound":{const r=p("sortedSequence",e,t,n),a=p("values",e,t,n);return[s.lowerBound(r,a)]}case"TopKV2":{const r=p("x",e,t,n),a=p("k",e,t,n),o=p("sorted",e,t,n),i=s.topk(r,a,o);return[i.values,i.indices]}case"UpperBound":{const r=p("sortedSequence",e,t,n),a=p("values",e,t,n);return[s.upperBound(r,a)]}case"Unique":{const r=p("x",e,t,n),a=s.unique(r);return[a.values,a.indices]}case"UniqueV2":{const r=p("x",e,t,n),a=p("axis",e,t,n),o=s.unique(r,a);return[o.values,o.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const QS=(e,t,n,s=lt)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const r=p("default",e,t,n);return[ct(e.name,t,n)||r];case"Placeholder":return[ct(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const l=p("x",e,t,n);return[jt(l)]}case"IdentityN":return p("x",e,t,n).map(l=>jt(l));case"Snapshot":const a=p("x",e,t,n);return[jt(a)];case"Shape":return[s.tensor1d(p("x",e,t,n).shape,"int32")];case"ShapeN":return p("x",e,t,n).map(l=>s.tensor1d(l.shape));case"Size":return[s.scalar(p("x",e,t,n).size,"int32")];case"Rank":return[s.scalar(p("x",e,t,n).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const o=p("x",e,t,n),i=p("data",e,t,n),u=p("message",e,t,n),c=p("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let l=0;l<i.length;l++)console.log(Array.prototype.slice.call(i[l].dataSync()).slice(0,c));return[o];default:throw TypeError(`Node type ${e.op} is not implemented`)}};class tT{get id(){return this.handle.id}constructor(t,n){this.keyDType=t,this.valueDType=n,this.handle=M(0),this.tensorMap=new Map,Ot(this.handle)}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return M(this.size(),"int32")}async import(t,n){this.checkKeyAndValueTensor(t,n);const s=await t.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),j(()=>{const r=le(n),a=s.length,o=r.length;g(a===o,()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${o} elements.`);for(let i=0;i<a;i++){const u=s[i],c=r[i];Ot(c),this.tensorMap.set(u,c)}return this.handle})}async find(t,n){this.checkKeyAndValueTensor(t,n);const s=await t.data();return j(()=>{const r=[];for(let a=0;a<s.length;a++){const o=s[a],i=this.findWithDefault(o,n);r.push(i)}return Wt(r)})}findWithDefault(t,n){const s=this.tensorMap.get(t);return s??n}checkKeyAndValueTensor(t,n){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(n.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}}const eT=async(e,t,n,s)=>{switch(e.op){case"HashTable":case"HashTableV2":{const r=s.getHashTableHandleByName(e.name);if(r!=null)return[r];{const a=p("keyDType",e,t,n),o=p("valueDType",e,t,n),i=new tT(a,o);return s.addHashTable(e.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=p("tableHandle",e,t,n,s),a=p("keys",e,t,n),o=p("values",e,t,n);return[await s.getHashTableById(r.id).import(a,o)]}case"LookupTableFind":case"LookupTableFindV2":{const r=p("tableHandle",e,t,n,s),a=p("keys",e,t,n),o=p("defaultValue",e,t,n);return[await s.getHashTableById(r.id).find(a,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=p("tableHandle",e,t,n,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const nT=(e,t,n,s=lt)=>{switch(e.op){case"ResizeBilinear":{const r=p("images",e,t,n),a=p("size",e,t,n),o=p("alignCorners",e,t,n),i=p("halfPixelCenters",e,t,n);return[s.image.resizeBilinear(r,[a[0],a[1]],o,i)]}case"ResizeNearestNeighbor":{const r=p("images",e,t,n),a=p("size",e,t,n),o=p("alignCorners",e,t,n),i=p("halfPixelCenters",e,t,n);return[s.image.resizeNearestNeighbor(r,[a[0],a[1]],o,i)]}case"CropAndResize":{const r=p("image",e,t,n),a=p("boxes",e,t,n),o=p("boxInd",e,t,n),i=p("cropSize",e,t,n),u=p("method",e,t,n),c=p("extrapolationValue",e,t,n);return[s.image.cropAndResize(r,a,o,i,u,c)]}case"ImageProjectiveTransformV3":{const r=p("images",e,t,n),a=p("transforms",e,t,n),o=p("outputShape",e,t,n),i=p("fillValue",e,t,n),u=p("interpolation",e,t,n),c=p("fillMode",e,t,n);return[s.image.transform(r,a,u.toLowerCase(),c.toLowerCase(),i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const sT=(e,t,n,s=lt)=>{switch(e.op){case"Equal":return[s.equal(p("a",e,t,n),p("b",e,t,n))];case"NotEqual":return[s.notEqual(p("a",e,t,n),p("b",e,t,n))];case"Greater":return[s.greater(p("a",e,t,n),p("b",e,t,n))];case"GreaterEqual":return[s.greaterEqual(p("a",e,t,n),p("b",e,t,n))];case"Less":return[s.less(p("a",e,t,n),p("b",e,t,n))];case"LessEqual":return[s.lessEqual(p("a",e,t,n),p("b",e,t,n))];case"LogicalAnd":return[s.logicalAnd(p("a",e,t,n),p("b",e,t,n))];case"LogicalNot":return[s.logicalNot(p("a",e,t,n))];case"LogicalOr":return[s.logicalOr(p("a",e,t,n),p("b",e,t,n))];case"Select":case"SelectV2":return[s.where(p("condition",e,t,n),p("a",e,t,n),p("b",e,t,n))];case"BitwiseAnd":return[s.bitwiseAnd(p("a",e,t,n),p("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};const rT=(e,t,n,s=lt)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(p("a",e,t,n),p("b",e,t,n),p("transposeA",e,t,n),p("transposeB",e,t,n))];case"Einsum":return[s.einsum(p("equation",e,t,n),...p("tensors",e,t,n))];case"Transpose":return[s.transpose(p("x",e,t,n),p("perm",e,t,n))];case"_FusedMatMul":const[r,a]=p("fusedOps",e,t,n),o=r==="biasadd",i=a==="prelu",u=p("numArgs",e,t,n),c=p("leakyreluAlpha",e,t,n);if(o){if(i&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[l,h]=p("args",e,t,n);return[s.fused.matMul({a:p("a",e,t,n),b:p("b",e,t,n),transposeA:p("transposeA",e,t,n),transposeB:p("transposeB",e,t,n),bias:l,activation:a,preluActivationWeights:h,leakyreluAlpha:c})];case"MatrixBandPart":return[s.linalg.bandPart(p("a",e,t,n),p("numLower",e,t,n),p("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};const aT=(e,t,n,s=lt)=>{switch(e.op){case"EuclideanNorm":return[s.euclideanNorm(p("x",e,t,n),p("axis",e,t,n),p("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(p("x",e,t,n),p("mean",e,t,n),p("variance",e,t,n),p("offset",e,t,n),p("scale",e,t,n),p("epsilon",e,t,n))];case"FusedBatchNormV3":return[s.batchNorm(p("x",e,t,n),p("mean",e,t,n),p("variance",e,t,n),p("offset",e,t,n),p("scale",e,t,n),p("epsilon",e,t,n))];case"LRN":return[s.localResponseNormalization(p("x",e,t,n),p("radius",e,t,n),p("bias",e,t,n),p("alpha",e,t,n),p("beta",e,t,n))];case"Softmax":return[s.softmax(p("x",e,t,n))];case"LogSoftmax":return[s.logSoftmax(p("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};const oT=(e,t,n,s=lt)=>{switch(e.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:a}=s.raggedGather(p("paramsNestedSplits",e,t,n),p("paramsDenseValues",e,t,n),p("indices",e,t,n),p("outputRaggedRank",e,t,n));return r.concat(a)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:a}=s.raggedRange(p("starts",e,t,n),p("limits",e,t,n),p("splits",e,t,n));return[r,a]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(p("shape",e,t,n),p("values",e,t,n),p("defaultValue",e,t,n),p("rowPartitionTensors",e,t,n),p("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};const iT=(e,t,n,s=lt)=>{switch(e.op){case"Max":{const i=p("axis",e,t,n),u=p("keepDims",e,t,n);return[s.max(p("x",e,t,n),i,u)]}case"Mean":{const i=p("axis",e,t,n),u=p("keepDims",e,t,n);return[s.mean(p("x",e,t,n),i,u)]}case"Min":{const i=p("axis",e,t,n),u=p("keepDims",e,t,n);return[s.min(p("x",e,t,n),i,u)]}case"Sum":{const i=p("axis",e,t,n),u=p("keepDims",e,t,n);return[s.sum(p("x",e,t,n),i,u)]}case"All":{const i=p("axis",e,t,n),u=p("keepDims",e,t,n);return[s.all(p("x",e,t,n),i,u)]}case"Any":{const i=p("axis",e,t,n),u=p("keepDims",e,t,n);return[s.any(p("x",e,t,n),i,u)]}case"ArgMax":{const i=p("axis",e,t,n);return[s.argMax(p("x",e,t,n),i)]}case"ArgMin":{const i=p("axis",e,t,n);return[s.argMin(p("x",e,t,n),i)]}case"Prod":{const i=p("axis",e,t,n),u=p("keepDims",e,t,n);return[s.prod(p("x",e,t,n),i,u)]}case"Cumprod":{const i=p("axis",e,t,n),u=p("exclusive",e,t,n),c=p("reverse",e,t,n);return[s.cumprod(p("x",e,t,n),i,u,c)]}case"Cumsum":{const i=p("axis",e,t,n),u=p("exclusive",e,t,n),c=p("reverse",e,t,n);return[s.cumsum(p("x",e,t,n),i,u,c)]}case"Bincount":const r=p("x",e,t,n),a=p("weights",e,t,n),o=p("size",e,t,n);return[s.bincount(r,a,o)];case"DenseBincount":{const i=p("x",e,t,n),u=p("weights",e,t,n),c=p("size",e,t,n),l=p("binaryOutput",e,t,n);return[s.denseBincount(i,u,c,l)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const uT=(e,t,n,s=lt)=>{switch(e.op){case"ConcatV2":case"Concat":{const r=p("n",e,t,n),a=p("axis",e,t,n);let o=p("tensors",e,t,n);return o=o.slice(0,r),[s.concat(o,a)]}case"Gather":{const r=p("x",e,t,n),a=p("indices",e,t,n);return[s.gather(r,s.cast(a,"int32"),0)]}case"GatherV2":{const r=p("axis",e,t,n),a=p("batchDims",e,t,n),o=p("x",e,t,n),i=p("indices",e,t,n);return[s.gather(o,s.cast(i,"int32"),r,a)]}case"Reverse":{const r=p("dims",e,t,n),a=[];for(let i=0;i<r.length;i++)r[i]&&a.push(i);const o=p("x",e,t,n);return[s.reverse(o,a)]}case"ReverseV2":{const r=p("axis",e,t,n),a=p("x",e,t,n);return[s.reverse(a,r)]}case"Slice":{const r=p("begin",e,t,n),a=p("size",e,t,n);return[s.slice(p("x",e,t,n),r,a)]}case"StridedSlice":{const r=p("begin",e,t,n),a=p("end",e,t,n),o=p("strides",e,t,n),i=p("beginMask",e,t,n),u=p("endMask",e,t,n),c=p("ellipsisMask",e,t,n),l=p("newAxisMask",e,t,n),h=p("shrinkAxisMask",e,t,n),f=p("x",e,t,n);return[s.stridedSlice(f,r,a,o,i,u,c,l,h)]}case"Pack":return j(()=>{const r=p("axis",e,t,n),a=p("tensors",e,t,n),o=a[0].shape,i=s.squeeze(a[0]).shape,u=a.map(c=>{const l=Rt(c.shape,o);if(!l&&!Rt(s.squeeze(c).shape,i))throw new Error("the input tensors shape does not match");return l?c:s.reshape(c,o)});return[s.stack(u,r)]});case"Unpack":{const r=p("axis",e,t,n),a=p("tensor",e,t,n);return s.unstack(a,r)}case"Tile":{const r=p("reps",e,t,n);return[s.tile(p("x",e,t,n),r)]}case"Split":case"SplitV":{const r=p("axis",e,t,n),a=p("numOrSizeSplits",e,t,n),o=p("x",e,t,n);return s.split(o,a,r)}case"ScatterNd":{const r=p("indices",e,t,n),a=p("values",e,t,n),o=p("shape",e,t,n);return[s.scatterND(r,a,o)]}case"GatherNd":{const r=p("x",e,t,n),a=p("indices",e,t,n);return[s.gatherND(r,a)]}case"SparseToDense":{const r=p("sparseIndices",e,t,n),a=p("outputShape",e,t,n),o=p("sparseValues",e,t,n),i=p("defaultValue",e,t,n);return[s.sparseToDense(r,o,a,o.dtype===i.dtype?i:s.cast(i,o.dtype))]}case"TensorScatterUpdate":{const r=p("indices",e,t,n),a=p("values",e,t,n),o=p("tensor",e,t,n);return[s.tensorScatterUpdate(o,r,a)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const cT=(e,t,n,s=lt)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:a,emptyRowIndicator:o,reverseIndexMap:i}=s.sparse.sparseFillEmptyRows(p("indices",e,t,n),p("values",e,t,n),p("denseShape",e,t,n),p("defaultValue",e,t,n));return[r,a,o,i]}case"SparseReshape":{const{outputIndices:r,outputShape:a}=s.sparse.sparseReshape(p("inputIndices",e,t,n),p("inputShape",e,t,n),p("newShape",e,t,n));return[r,a]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(p("data",e,t,n),p("indices",e,t,n),p("segmentIds",e,t,n))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(p("data",e,t,n),p("indices",e,t,n),p("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};const lT=(e,t,n,s=lt)=>{switch(e.op){case"FFT":return[s.fft(p("x",e,t,n))];case"IFFT":return[s.ifft(p("x",e,t,n))];case"RFFT":return[s.rfft(p("x",e,t,n))];case"IRFFT":return[s.irfft(p("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};const hT=(e,t,n,s=lt)=>{switch(e.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(p("input",e,t,n),p("pattern",e,t,n),p("rewrite",e,t,n),p("replaceGlobal",e,t,n))];case"StringNGrams":{const{nGrams:r,nGramsSplits:a}=s.string.stringNGrams(p("data",e,t,n),p("dataSplits",e,t,n),p("separator",e,t,n),p("nGramWidths",e,t,n),p("leftPad",e,t,n),p("rightPad",e,t,n),p("padWidth",e,t,n),p("preserveShortSequences",e,t,n));return[r,a]}case"StringSplit":{const{indices:r,values:a,shape:o}=s.string.stringSplit(p("input",e,t,n),p("delimiter",e,t,n),p("skipEmpty",e,t,n));return[r,a,o]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(p("input",e,t,n),p("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};const pT=(e,t,n,s=lt)=>{switch(e.op){case"Cast":return[s.cast(p("x",e,t,n),p("dtype",e,t,n))];case"ExpandDims":{const r=p("axis",e,t,n);return[s.expandDims(p("x",e,t,n),r)]}case"Squeeze":{const r=p("axis",e,t,n);return[s.squeeze(p("x",e,t,n),r)]}case"Reshape":return[s.reshape(p("x",e,t,n),p("shape",e,t,n))];case"EnsureShape":return[s.ensureShape(p("x",e,t,n),p("shape",e,t,n))];case"MirrorPad":return[s.mirrorPad(p("x",e,t,n),p("padding",e,t,n),p("mode",e,t,n))];case"PadV2":case"Pad":return[s.pad(p("x",e,t,n),p("padding",e,t,n),p("constantValue",e,t,n))];case"SpaceToBatchND":{const r=p("blockShape",e,t,n),a=p("paddings",e,t,n);return[s.spaceToBatchND(p("x",e,t,n),r,a)]}case"BatchToSpaceND":{const r=p("blockShape",e,t,n),a=p("crops",e,t,n);return[s.batchToSpaceND(p("x",e,t,n),r,a)]}case"DepthToSpace":{const r=p("blockSize",e,t,n),a=p("dataFormat",e,t,n).toUpperCase();return[s.depthToSpace(p("x",e,t,n),r,a)]}case"BroadcastTo":return[s.broadcastTo(p("x",e,t,n),p("shape",e,t,n))];case"BroadcastArgs":return[s.broadcastArgs(p("s0",e,t,n),p("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Za(e,t,n,s,r=j){const a=((o,i,u)=>{switch(o.category){case"arithmetic":return r(()=>WS(o,i,u));case"basic_math":return r(()=>MS(o,i,u));case"control":return KS(o,i,u);case"convolution":return r(()=>XS(o,i,u));case"creation":return r(()=>ZS(o,i,u));case"dynamic":return JS(o,i,u);case"evaluation":return r(()=>YS(o,i,u));case"image":return r(()=>nT(o,i,u));case"graph":return r(()=>QS(o,i,u));case"logical":return r(()=>sT(o,i,u));case"matrices":return r(()=>rT(o,i,u));case"normalization":return r(()=>aT(o,i,u));case"ragged":return r(()=>oT(o,i,u));case"reduction":return r(()=>iT(o,i,u));case"slice_join":return r(()=>uT(o,i,u));case"sparse":return r(()=>cT(o,i,u));case"spectral":return r(()=>lT(o,i,u));case"string":return r(()=>hT(o,i,u));case"transformation":return r(()=>pT(o,i,u));case"hash_table":return eT(o,i,u,s);case"custom":const c=Ep(o.op);if(c&&c.customExecutor)return c.customExecutor(new VS(o,i,u));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return re(a)?a.then(o=>[].concat(o)):[].concat(a)}class Ja{constructor(t={},n={},s={},r={},a){this.weightMap=t,this.tensorArrayMap=n,this.tensorListMap=s,this.functionMap=r,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,n){return{id:t,frameName:n,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let n=0;n<this.contexts.length-1;n++){const s=this.contexts.slice(0,this.contexts.length-n);t.push(this.contextIdforContexts(s))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(n=>n.id===0&&n.iterationId===0?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(t);for(const n in this.tensorListMap)this.tensorListMap[n].clearAndClose(t)}}function Ya(e,t,n,s){const r=new Set,a=[];let o=null,i=null;const u=new Set,c=new Set(Object.keys(e).map(f=>Nt(f)[0]));s=s||[];const l=new Set(s.map(f=>Nt(f.name)[0])),h=[...t];for(;h.length>0;){const f=h.pop();if((ge(f)||NT(f)||ST(f))&&o==null&&(o=f,i=o.children.map(m=>m.name).filter(m=>r.has(m))),r.add(f.name),n[f.name]==null&&!c.has(f.name)&&!l.has(f.name)){if(f.inputs.length===0){a.push(f.name);continue}f.inputs.forEach(m=>{u.has(m.name)||(u.add(m.name),h.push(m))})}}return{inputs:e,outputs:t,usedNodes:r,missingInputs:a,dynamicNode:o,syncInputs:i}}function fT(e,t){const{usedNodes:n,inputs:s}=t,r=Object.keys(s).map(N=>Nt(N)[0]).map(N=>e.nodes[N]),a=e.initNodes||[],o=N=>n.has(typeof N=="string"?N:N.name);function i(N){return[...new Map(N.map(E=>[E.name,E])).values()]}const u=i([...r,...e.weights,...a]).filter(o),c=i([...u,...Object.values(e.nodes)]).filter(o),l=new Map(c.map(N=>[N.name,N])),h={};for(const N of c){h[N.name]=h[N.name]||0;for(const E of N.children)o(E)||(h[E.name]=Number.POSITIVE_INFINITY),h[E.name]=(h[E.name]||0)+1}const f=Object.entries(h).filter(([,N])=>N===0).map(([N])=>N),m=[...f];for(;f.length>0;){const N=f.pop(),E=l.get(N);for(const O of E.children.filter(o))--h[O.name]===0&&(m.push(O.name),f.push(O.name))}const S=m.map(N=>l.get(N)),T=dT(S,u);return mT(T,u),T}function dT(e,t){const n=new Map(e.map(o=>[o.name,o])),s=t.map(o=>o.name),r=new Set(s);for(;s.length>0;){const o=s.pop(),i=n.get(o);for(const u of i.children)!n.has(u.name)||r.has(u.name)||(r.add(u.name),s.push(u.name))}return e.filter(o=>r.has(o.name))}class xn extends Error{constructor(t){super(`NodesExecutionOrderError: ${t}`)}}function mT(e,t){const n=new Map(e.map((i,u)=>[i.name,u])),s=new Set(t.map(i=>i.name)),r=i=>s.has(typeof i=="string"?i:i.name),a=new Set(e.map(i=>i.name)),o=i=>a.has(typeof i=="string"?i:i.name);for(const i of e){for(const u of i.children.filter(o)){if(!n.has(u.name))throw new xn(`Child ${u.name} of node ${i.name} is unreachable.`);if(n.get(i.name)>n.get(u.name))throw new xn(`Node ${i.name} is scheduled to run after its child ${u.name}.`)}if(!r(i))for(const u of i.inputs){if(!n.has(u.name))throw new xn(`Input ${u.name} of node ${i.name} is unreachable.`);if(n.get(u.name)>n.get(i.name))throw new xn(`Node ${i.name} is scheduled to run before its input ${u.name}.`)}}}function gT(e){const t=new Map(e.map((i,u)=>[i.name,u])),n=Number.MAX_SAFE_INTEGER,s=e.map((i,u)=>ge(i)?n:u),r=i=>{const u=s[t.get(i.name)];return u??-1},a=e.map((i,u)=>i.children.map(r).reduce((c,l)=>Math.max(c,l),s[u])),o=new Map;for(let i=0;i<e.length;++i){const u=a[i];if(u===n)continue;const c=e[i],l=e[u];o.has(l.name)||o.set(l.name,[]),o.get(l.name).push(c)}return o}const yT=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),bT=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),wT=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function ge(e){return yT.has(e.op)}function NT(e){return bT.has(e.op)}function ST(e){return wT.has(e.op)}class Kn{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const n=Object.keys(t).map(s=>t[s].map(r=>r.id));this._weightIds=[].concat(...n),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>(t[n]=this._functions[n].signature,t),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(s=>{this._functionExecutorMap[s]=new Kn(t.functions[s],this)})}getCompilationKey(t,n){const s=t.map(a=>a.name).sort(),r=n.map(a=>a.name).sort();return s.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(t,n){const s=Ya(t,n,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:o}=s;if(a!=null)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(r.length>0){const c=n.map(h=>h.name),l=Object.keys(t);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${l}]. Missing the following inputs: [${r}]`)}const i=fT(this.graph,s),u=gT(i);return{orderedNodes:i,nodeLiveUntilMap:u}}cloneAndKeepTensor(t){if(t==null)return null;const n=t.clone();return Ot(n),n}cloneTensorList(t){return t?t.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([n,s])=>[n,this.cloneTensorList(s)]))}execute(t,n){this.disposeIntermediateTensors(),t=this.mapInputs(t);const s=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n);const r=s.map(f=>this.graph.nodes[Nt(f)[0]]),a=n.map(f=>Nt(f)[0]),o=new Set(a);let i=a.map(f=>this.graph.nodes[f]);i.length===0&&(i=this._outputs);const u=this.getCompilationKey(r,i);let c=this.compiledMap.get(u);c==null&&(c=this.compile(t,i),this.compiledMap.set(u,c));try{this.keepIntermediateTensors=P().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}const l={},h={};return j(()=>{const f=new Ja(this.weightMap,l,h,this.functionExecutorMap,this.parseNodeNameCache),m=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(E=>{const[O,$]=Nt(E,f),I=[];I[$]=t[E],m[O]=I,this.keepIntermediateTensors&&(this.clonedTensorsMap[O]=this.cloneTensorList(I))});const S=this.getFrozenTensorIds(m),{orderedNodes:T,nodeLiveUntilMap:N}=c;for(const E of T){if(m[E.name])continue;const O=Za(E,m,f,this._resourceManager);if(re(O))throw new Error(`The execution of the op '${E.op}' returned a promise. Please use model.executeAsync() instead.`);m[E.name]=O,this.keepIntermediateTensors&&(this.clonedTensorsMap[E.name]=this.cloneTensorList(O)),this.checkTensorForDisposalWithNodeLiveUntilInfo(E,m,f,S,o,N.get(E.name))}return this.parent==null&&f.dispose(S),n.map(E=>ct(E,m,f))})}getFrozenTensorIds(t){const n=[].concat.apply([],Object.keys(t).map(s=>t[s]).map(s=>s.map(r=>r.id)));return new Set(n)}checkTensorForDisposal(t,n,s,r,a,o,i){if(!(ge(n)||o.has(t))){for(const u of s[t])u!=null&&(i[u.id]=(i[u.id]||0)+n.children.length);for(const u of n.inputs){if(ge(u))continue;const c=qa(u.name,s,r);if(c!=null)for(const l of c){if(!l||l.kept||a.has(l.id))continue;const h=i[l.id];h===1?(l.dispose(),delete i[l.id]):h!=null&&i[l.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,n,s,r,a,o){function i(u){return ge(u)||a.has(u.name)}if(!(ge(t)||o==null))for(const u of o){if(i(u))continue;const c=qa(u.name,n,s);for(const l of c)!l||l.kept||r.has(l.id)||l.dispose()}}async executeAsync(t,n){return this._executeAsync(t,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(const n of t)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,n,s=!1,r={},a={}){this.disposeIntermediateTensors(),s||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=P().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}const o=new Ja(this.weightMap,r,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const i=await this.executeWithControlFlow(t,o,n,s),u=n.map(f=>ct(f,i,o)),c=u.map(f=>f.id),l=Object.keys(t).map(f=>t[f].id),h=new Set([...c,...l,...this.weightIds]);return Object.values(i).forEach(f=>{f.forEach(m=>{m&&!m.isDisposed&&!h.has(m.id)&&m.dispose()})}),this.parent==null&&o.dispose(h),u}async executeFunctionAsync(t,n,s){const r=t.reduce((a,o,i)=>(a[this.inputs[i].name]=o,a),{});return this._executeAsync(r,this.outputNodes,!0,n,s)}async executeWithControlFlow(t,n,s,r){const a=Object.keys(t),o=a.map(I=>this.graph.nodes[Nt(I)[0]]),i=s.map(I=>Nt(I)[0]),u=new Set(i);let c=i.map(I=>this.graph.nodes[I]);c.length===0&&(c=this._outputs);const{usedNodes:l,missingInputs:h,dynamicNode:f,syncInputs:m}=Ya(t,c,this.weightMap,this._initNodes),S=[...o,...this.graph.weights,...this._initNodes||[]].map(I=>({node:I,contexts:n.currentContext})),T=Object.assign({},this.weightMap);Object.keys(t).forEach(I=>{const[D,x]=Nt(I),F=[];F[x]=t[I],T[D]=F});const N={},E=this.getFrozenTensorIds(T),O={};for(;S.length>0;){const I=this.processStack(o,S,n,T,O,E,u,N,l);await Promise.all(I)}f==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const $=c.filter(I=>!ge(I)&&!ct(I.name,T,n)).map(I=>I.name);if($.length>0){let I="";throw f!=null&&(I=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${m}]`),new Error(`Cannot compute the outputs [${$}] from the provided inputs [${a}]. Consider providing the following inputs: [${h}]. ${I}`)}return T}processStack(t,n,s,r,a,o,i,u,c){const l=[];for(;n.length>0;){const h=n.pop();s.currentContext=h.contexts;let f="";if(h.node.op==="Enter"&&p("isConstant",h.node,r,s)&&([f]=Ut(h.node.name,s)),r[h.node.name]==null){const m=Za(h.node,r,s,this._resourceManager);f||([f]=Ut(h.node.name,s));const S=s.currentContext;re(m)?l.push(m.then(T=>(r[f]=T,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(T)),s.currentContext=S,this.checkTensorForDisposal(f,h.node,r,s,o,i,u),this.processChildNodes(h.node,n,s,r,a,c),T))):(r[f]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(m)),this.checkTensorForDisposal(f,h.node,r,s,o,i,u),this.processChildNodes(h.node,n,s,r,a,c))}else this.processChildNodes(h.node,n,s,r,a,c)}return l}processChildNodes(t,n,s,r,a,o){t.children.forEach(i=>{const[u]=Ut(i.name,s);a[u]||!o.has(i.name)||(i.op==="Merge"?i.inputNames.some(c=>!!ct(c,r,s))&&(a[u]=!0,n.push({contexts:s.currentContext,node:i})):i.inputNames.every(c=>!!ct(c,r,s))&&(a[u]=!0,n.push({contexts:s.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{const s=t[n],[r]=Nt(n),a=this.graph.nodes[r];if(a.attrParams.shape&&a.attrParams.shape.value){const o=a.attrParams.shape.value,i=o.length===s.shape.length&&s.shape.every((u,c)=>o[c]===-1||o[c]===u);g(i,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${o}], but was [${s.shape}]`)}a.attrParams.dtype&&a.attrParams.dtype.value&&g(s.dtype===a.attrParams.dtype.value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(t){var n,s;const r={};for(const a in t){const o=(s=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||s===void 0?void 0:s[a];o!=null?r[o.name]=t[a]:r[a]=t[a]}return r}checkInputs(t){const n=Object.keys(t).filter(s=>{const[r]=Nt(s);return this.graph.nodes[r]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(t){return t.map(n=>{var s,r;const a=(r=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||r===void 0?void 0:r[n];return a!=null?a.name:n},{})}checkOutputs(t){t.forEach(n=>{const[s]=Nt(n);if(!this.graph.nodes[s])throw new Error(`The output '${n}' is not found in the graph`)})}}class TT{constructor(t={},n={}){this.hashTableNameToHandle=t,this.hashTableMap=n}addHashTable(t,n){this.hashTableNameToHandle[t]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}const ET="?tfjs-format=file",$T="model.json";class kp{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,n={},s=ia){this.modelUrl=t,this.loadOptions=n,this.version="n/a",this.io=s,n==null&&(this.loadOptions={}),this.resourceManager=new TT}findIOHandler(){const t=this.modelUrl;if(t.load!=null)this.handler=t;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const n=this.io.getLoadHandlers(t,this.loadOptions);if(n.length===0)n.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(n.length>1)throw new Error(`Found more than one (${n.length}) load handlers for URL '${[t]}'`);this.handler=n[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return re(t)?t.then(n=>n.getWeightStream==null?this.loadSync(n):this.loadStreaming(n)):this.loadSync(t)}loadSync(t){const n=this.io.decodeWeights(t.weightData,t.weightSpecs);return this.loadWithWeightMap(t,n)}async loadStreaming(t){if(t.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const n=await Sc(t.getWeightStream(),t.weightSpecs);return this.loadWithWeightMap(t,n)}loadWithWeightMap(t,n){this.artifacts=t;const s=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const a=this.artifacts.userDefinedMetadata;a.signature!=null&&(r=a.signature),a.structuredOutputKeys!=null&&(this.structuredOutputKeys=a.structuredOutputKeys)}if(this.signature=r,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new Kn(Ga.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(n),this.executor.resourceManager=this.resourceManager,t.modelInitializer!=null&&t.modelInitializer.node!=null){const a=Ga.Instance.transformGraph(t.modelInitializer);this.initializer=new Kn(a),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}async save(t,n){if(typeof t=="string"){const s=this.io.getSaveHandlers(t);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${t}'`);t=s[0]}if(t.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}addStructuredOutputNames(t){if(this.structuredOutputKeys){const n=t instanceof nt?[t]:t,s={};return n.forEach((r,a)=>s[this.structuredOutputKeys[a]]=r),s}return t}predict(t,n){const s=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(t,n){const s=await this.executeAsync(t,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(t){var n;if(!(t instanceof nt)&&!Array.isArray(t)){const a=(n=this.signature)===null||n===void 0?void 0:n.inputs;if(a!=null)for(const o in a){const i=a[o];i.resourceId!=null&&(t[o]=this.resourceIdToCapturedInput[i.resourceId])}return t}t=Array.isArray(t)?t:[t];const s=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${t.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((a,o)=>{var i,u,c;const l=(c=(u=(i=this.signature)===null||i===void 0?void 0:i.inputs)===null||u===void 0?void 0:u[o])===null||c===void 0?void 0:c.resourceId;return l!=null?a[o]=this.resourceIdToCapturedInput[l]:a[o]=t[r++],a},{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){const n=this.initializerSignature.outputs,s=Object.keys(n);for(let r=0;r<s.length;r++){const a=s[r],o=n[a];this.resourceIdToCapturedInput[o.resourceId]=t[r]}}}execute(t,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),n=this.normalizeOutputs(n);const s=this.executor.execute(t,n);return s.length>1?s:s[0]}async executeAsync(t,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),t=this.normalizeInputs(t),n=this.normalizeOutputs(n);const s=await this.executor.executeAsync(t,n);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((n,s)=>(n[s]=[t[s]],n),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&mt(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function xT(e,t={},n=ia){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof e=="string"&&(e=vT(e));const s=new kp(e,t,n);return await s.load(),s}function OT(e){if(e==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){const[s,r]=e;if(!s)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in s))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in s))throw new Error("Model JSON is missing 'weightsManifest'");const a=Wn(s.weightsManifest),o=hr(s,a,r);t=Gn(o)}else if("load"in e)t=e;else if("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e)t=Gn(e);else throw new Error("Unknown model format");const n=new kp(t);return n.load(),n}function vT(e){return e.endsWith("/")||(e=e+"/"),`${e}${$T}${ET}`}export{un as $,po as A,b as B,d as C,g as D,At as E,w as F,tf as G,_o as H,Qp as I,ko as J,Io as K,U as L,Ao as M,Lr as N,ef as O,sr as P,Co as Q,Ro as R,Ht as S,cn as T,kr as U,Qn as V,Lo as W,Bo as X,dn as Y,Me as Z,Po as _,fo as a,Vi as a$,dw as a0,al as a1,Vo as a2,Sn as a3,nf as a4,Wo as a5,eg as a6,Uo as a7,yh as a8,jo as a9,Rh as aA,vg as aB,bi as aC,ar as aD,Si as aE,Ti as aF,Ei as aG,$i as aH,$n as aI,Ai as aJ,Ii as aK,uf as aL,lf as aM,Ci as aN,Tn as aO,Nr as aP,Ri as aQ,Fi as aR,jn as aS,ff as aT,Bi as aU,pf as aV,Li as aW,zi as aX,Tg as aY,q as aZ,ee as a_,bh as aa,Go as ab,$g as ac,pl as ad,fn as ae,Zo as af,Xt as ag,bw as ah,Nw as ai,ti as aj,rf as ak,sf as al,si as am,af as an,ri as ao,ie as ap,oi as aq,ii as ar,ui as as,pi as at,fi as au,di as av,ph as aw,Ce as ax,mi as ay,Wt as az,It as b,Ju as b$,Wi as b0,Mi as b1,G as b2,Ui as b3,$r as b4,qi as b5,Gi as b6,Yi as b7,ve as b8,Ji as b9,hN as bA,_u as bB,ku as bC,$u as bD,cl as bE,vu as bF,ll as bG,Eu as bH,j0 as bI,qe as bJ,Cu as bK,Iu as bL,we as bM,Ou as bN,yr as bO,Du as bP,ht as bQ,Au as bR,yf as bS,zu as bT,tc as bU,qu as bV,xu as bW,Gu as bX,Hu as bY,or as bZ,On as b_,Qi as ba,le as bb,tu as bc,eu as bd,ze as be,Pe as bf,nu as bg,su as bh,hl as bi,ei as bj,cu as bk,du as bl,lu as bm,hu as bn,fu as bo,gf as bp,pu as bq,mf as br,mu as bs,ue as bt,gu as bu,yu as bv,Su as bw,Or as bx,Tu as by,lN as bz,Z as c,Br as c$,Yu as c0,Rr as c1,vr as c2,Mt as c3,Qu as c4,Nf as c5,cc as c6,St as c7,xc as c8,Oc as c9,ss as cA,dr as cB,pn as cC,qr as cD,kl as cE,_l as cF,Il as cG,_r as cH,xl as cI,Dl as cJ,Cl as cK,xr as cL,Ir as cM,Dr as cN,Rl as cO,Cr as cP,Ne as cQ,ln as cR,Un as cS,hn as cT,zl as cU,Vl as cV,En as cW,Fr as cX,qn as cY,jl as cZ,Zl as c_,Cc as ca,Rc as cb,Fc as cc,Lc as cd,Bc as ce,Pc as cf,zc as cg,Vc as ch,Wc as ci,gr as cj,Nn as ck,Ye as cl,Yc as cm,Qc as cn,nt as co,rl as cp,ol as cq,dl as cr,Yn as cs,gl as ct,bl as cu,wl as cv,Sr as cw,Sl as cx,$l as cy,vl as cz,zt as d,ul as d$,Jl as d0,ih as d1,kn as d2,Ur as d3,o1 as d4,u1 as d5,rs as d6,jr as d7,fh as d8,dh as d9,ns as dA,Dh as dB,Er as dC,tp as dD,rp as dE,Yt as dF,ap as dG,Lh as dH,Rt as dI,mt as dJ,P as dK,Z0 as dL,uo as dM,Ot as dN,je as dO,K0 as dP,Gt as dQ,he as dR,to as dS,cd as dT,Dd as dU,wd as dV,vd as dW,Cd as dX,b0 as dY,d0 as dZ,wc as d_,gh as da,Eh as db,Ar as dc,Gr as dd,as as de,$h as df,vh as dg,Mn as dh,Oh as di,Ch as dj,nn as dk,bc as dl,j as dm,Th as dn,Sh as dp,Nh as dq,wh as dr,vt as ds,Mr as dt,$w as du,sl as dv,nl as dw,el as dx,tl as dy,Uh as dz,W as e,FN as e$,Qh as e0,gw as e1,il as e2,Wl as e3,Hc as e4,Kc as e5,Xc as e6,Ll as e7,qc as e8,Dt as e9,Fo as eA,Xn as eB,uu as eC,Zn as eD,Up as eE,ZN as eF,Oo as eG,Ys as eH,ai as eI,yi as eJ,vi as eK,ki as eL,Of as eM,Hi as eN,Jn as eO,kg as eP,tN as eQ,eN as eR,Lt as eS,nN as eT,Q0 as eU,Vn as eV,M0 as eW,U0 as eX,JN as eY,P0 as eZ,RN as e_,Ve as ea,fl as eb,it as ec,re as ed,ur as ee,Gf as ef,Pr as eg,Re as eh,R0 as ei,Cf as ej,Qa as ek,Op as el,ud as em,Jt as en,Qt as eo,yn as ep,bN as eq,jp as er,zn as es,Pt as et,Bh as eu,Ue as ev,so as ew,yl as ex,Hp as ey,Gp as ez,M as f,SN as f$,LN as f0,BN as f1,PN as f2,zN as f3,VN as f4,WN as f5,MN as f6,UN as f7,jN as f8,qN as f9,Ho as fA,qo as fB,Qs as fC,Ko as fD,Xo as fE,Jo as fF,Yo as fG,Qo as fH,bm as fI,be as fJ,qp as fK,rr as fL,ni as fM,_N as fN,AN as fO,xN as fP,IN as fQ,ON as fR,yN as fS,gN as fT,mN as fU,dN as fV,fN as fW,pN as fX,TN as fY,wN as fZ,NN as f_,Vu as fa,xf as fb,Fn as fc,yd as fd,Mp as fe,Ts as ff,yo as fg,Eg as fh,bo as fi,Mc as fj,wm as fk,aN as fl,oN as fm,iN as fn,uN as fo,cN as fp,xo as fq,Do as fr,Ni as fs,J0 as ft,Y0 as fu,jc as fv,wn as fw,zo as fx,Uc as fy,Mo as fz,X as g,mc as g$,$N as g0,vN as g1,EN as g2,ci as g3,li as g4,mn as g5,hi as g6,Es as g7,$s as g8,gi as g9,Fu as gA,Lu as gB,Bu as gC,Pu as gD,CN as gE,Wu as gF,q0 as gG,V0 as gH,Mu as gI,Uu as gJ,ju as gK,wu as gL,Ku as gM,Xu as gN,Qe as gO,Zu as gP,nc as gQ,zp as gR,Je as gS,Cp as gT,no as gU,Qf as gV,YN as gW,Wp as gX,ae as gY,Rp as gZ,Ln as g_,pp as ga,KN as gb,wi as gc,_i as gd,xi as ge,Oi as gf,Di as gg,Pi as gh,ji as gi,Ki as gj,Kh as gk,Xi as gl,Xh as gm,Zi as gn,Zh as go,gt as gp,ru as gq,au as gr,ou as gs,iu as gt,ec as gu,rN as gv,bu as gw,Ah as gx,Nu as gy,Ru as gz,mo as h,Hl as h$,Fe as h0,sN as h1,qf as h2,Ss as h3,HN as h4,GN as h5,H0 as h6,F0 as h7,ia as h8,v0 as h9,Ol as hA,lo as hB,tr as hC,ep as hD,Jh as hE,qh as hF,Yh as hG,np as hH,sp as hI,Dc as hJ,Gc as hK,br as hL,Zc as hM,Jc as hN,Kt as hO,ml as hP,me as hQ,Nl as hR,vn as hS,Al as hT,Fl as hU,Bl as hV,Pl as hW,Ml as hX,Ul as hY,ql as hZ,Gl as h_,s0 as ha,ub as hb,Rf as hc,pg as hd,Kf as he,Sp as hf,L0 as hg,Xb as hh,td as hi,QN as hj,Qr as hk,ta as hl,ea as hm,na as hn,sa as ho,Tp as hp,ra as hq,ps as hr,sn as hs,_s as ht,dt as hu,Vt as hv,ty as hw,ey as hx,ny as hy,sy as hz,nr as i,AT as i$,Kl as i0,Xl as i1,fr as i2,Yl as i3,Ql as i4,th as i5,eh as i6,rh as i7,ah as i8,oh as i9,rd as iA,ad as iB,od as iC,id as iD,ld as iE,hd as iF,pd as iG,fd as iH,yc as iI,dd as iJ,md as iK,gd as iL,bd as iM,en as iN,vs as iO,Pn as iP,Sf as iQ,Tf as iR,Ef as iS,of as iT,cf as iU,hf as iV,df as iW,bf as iX,kp as iY,xT as iZ,OT as i_,We as ia,uh as ib,ch as ic,lh as id,hh as ie,mh as ig,Kr as ih,kh as ii,_h as ij,Ih as ik,xh as il,Fh as im,Zr as io,cr as ip,Ph as iq,zh as ir,Vh as is,es as it,Wh as iu,Mh as iv,Jr as iw,is as ix,jh as iy,sd as iz,rt as j,IT as j0,_T as j1,wr as k,K as l,C as m,Ct as n,go as o,wo as p,No as q,_ as r,Hr as s,So as t,To as u,B as v,vo as w,Eo as x,$o as y,Tt as z};
